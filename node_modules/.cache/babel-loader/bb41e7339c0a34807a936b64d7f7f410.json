{"ast":null,"code":"/*!\n * Sizzle CSS Selector Engine\n *  Copyright 2011, The Dojo Foundation\n *  Released under the MIT, BSD, and GPL Licenses.\n *  More information: http://sizzlejs.com/\n */\n// Patch for jsdom\nmodule.exports = function (document) {\n  var chunker = /((?:\\((?:\\([^()]+\\)|[^()]+)+\\)|\\[(?:\\[[^\\[\\]]*\\]|['\"][^'\"]*['\"]|[^\\[\\]'\"]+)+\\]|\\\\.|[^ >+~,(\\[\\\\]+)+|[>+~])(\\s*,\\s*)?((?:.|\\r|\\n)*)/g,\n      expando = \"sizcache\" + (Math.random() + '').replace('.', ''),\n      done = 0,\n      toString = Object.prototype.toString,\n      hasDuplicate = false,\n      baseHasDuplicate = true,\n      rBackslash = /\\\\/g,\n      rReturn = /\\r\\n/g,\n      rNonWord = /\\W/; // Here we check if the JavaScript engine is using some sort of\n  // optimization where it does not always call our comparision\n  // function. If that is the case, discard the hasDuplicate value.\n  //   Thus far that includes Google Chrome.\n\n  [0, 0].sort(function () {\n    baseHasDuplicate = false;\n    return 0;\n  });\n\n  var Sizzle = function (selector, context, results, seed) {\n    results = results || []; // PATCH for jsdom\n    // context = context || document;\n    // See: https://github.com/tmpvar/jsdom/issues/375\n\n    context = context || seed[0].ownerDocument;\n    var origContext = context;\n\n    if (context.nodeType !== 1 && context.nodeType !== 9) {\n      return [];\n    }\n\n    if (!selector || typeof selector !== \"string\") {\n      return results;\n    }\n\n    var m,\n        set,\n        checkSet,\n        extra,\n        ret,\n        cur,\n        pop,\n        i,\n        prune = true,\n        contextXML = Sizzle.isXML(context),\n        parts = [],\n        soFar = selector; // Reset the position of the chunker regexp (start from head)\n\n    do {\n      chunker.exec(\"\");\n      m = chunker.exec(soFar);\n\n      if (m) {\n        soFar = m[3];\n        parts.push(m[1]);\n\n        if (m[2]) {\n          extra = m[3];\n          break;\n        }\n      }\n    } while (m);\n\n    if (parts.length > 1 && origPOS.exec(selector)) {\n      if (parts.length === 2 && Expr.relative[parts[0]]) {\n        set = posProcess(parts[0] + parts[1], context, seed);\n      } else {\n        set = Expr.relative[parts[0]] ? [context] : Sizzle(parts.shift(), context);\n\n        while (parts.length) {\n          selector = parts.shift();\n\n          if (Expr.relative[selector]) {\n            selector += parts.shift();\n          }\n\n          set = posProcess(selector, set, seed);\n        }\n      }\n    } else {\n      // Take a shortcut and set the context if the root selector is an ID\n      // (but not if it'll be faster if the inner selector is an ID)\n      if (!seed && parts.length > 1 && context.nodeType === 9 && !contextXML && Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1])) {\n        ret = Sizzle.find(parts.shift(), context, contextXML);\n        context = ret.expr ? Sizzle.filter(ret.expr, ret.set)[0] : ret.set[0];\n      }\n\n      if (context) {\n        ret = seed ? {\n          expr: parts.pop(),\n          set: makeArray(seed)\n        } : Sizzle.find(parts.pop(), parts.length === 1 && (parts[0] === \"~\" || parts[0] === \"+\") && context.parentNode ? context.parentNode : context, contextXML);\n        set = ret.expr ? Sizzle.filter(ret.expr, ret.set) : ret.set;\n\n        if (parts.length > 0) {\n          checkSet = makeArray(set);\n        } else {\n          prune = false;\n        }\n\n        while (parts.length) {\n          cur = parts.pop();\n          pop = cur;\n\n          if (!Expr.relative[cur]) {\n            cur = \"\";\n          } else {\n            pop = parts.pop();\n          }\n\n          if (pop == null) {\n            pop = context;\n          }\n\n          Expr.relative[cur](checkSet, pop, contextXML);\n        }\n      } else {\n        checkSet = parts = [];\n      }\n    }\n\n    if (!checkSet) {\n      checkSet = set;\n    }\n\n    if (!checkSet) {\n      Sizzle.error(cur || selector);\n    }\n\n    if (toString.call(checkSet) === \"[object Array]\") {\n      if (!prune) {\n        results.push.apply(results, checkSet);\n      } else if (context && context.nodeType === 1) {\n        for (i = 0; checkSet[i] != null; i++) {\n          if (checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i]))) {\n            results.push(set[i]);\n          }\n        }\n      } else {\n        for (i = 0; checkSet[i] != null; i++) {\n          if (checkSet[i] && checkSet[i].nodeType === 1) {\n            results.push(set[i]);\n          }\n        }\n      }\n    } else {\n      makeArray(checkSet, results);\n    }\n\n    if (extra) {\n      Sizzle(extra, origContext, results, seed);\n      Sizzle.uniqueSort(results);\n    }\n\n    return results;\n  };\n\n  Sizzle.uniqueSort = function (results) {\n    if (sortOrder) {\n      hasDuplicate = baseHasDuplicate;\n      results.sort(sortOrder);\n\n      if (hasDuplicate) {\n        for (var i = 1; i < results.length; i++) {\n          if (results[i] === results[i - 1]) {\n            results.splice(i--, 1);\n          }\n        }\n      }\n    }\n\n    return results;\n  };\n\n  Sizzle.matches = function (expr, set) {\n    return Sizzle(expr, null, null, set);\n  };\n\n  Sizzle.matchesSelector = function (node, expr) {\n    return Sizzle(expr, null, null, [node]).length > 0;\n  };\n\n  Sizzle.find = function (expr, context, isXML) {\n    var set, i, len, match, type, left;\n\n    if (!expr) {\n      return [];\n    }\n\n    for (i = 0, len = Expr.order.length; i < len; i++) {\n      type = Expr.order[i];\n\n      if (match = Expr.leftMatch[type].exec(expr)) {\n        left = match[1];\n        match.splice(1, 1);\n\n        if (left.substr(left.length - 1) !== \"\\\\\") {\n          match[1] = (match[1] || \"\").replace(rBackslash, \"\");\n          set = Expr.find[type](match, context, isXML);\n\n          if (set != null) {\n            expr = expr.replace(Expr.match[type], \"\");\n            break;\n          }\n        }\n      }\n    }\n\n    if (!set) {\n      set = typeof context.getElementsByTagName !== \"undefined\" ? context.getElementsByTagName(\"*\") : [];\n    }\n\n    return {\n      set: set,\n      expr: expr\n    };\n  };\n\n  Sizzle.filter = function (expr, set, inplace, not) {\n    var match,\n        anyFound,\n        type,\n        found,\n        item,\n        filter,\n        left,\n        i,\n        pass,\n        old = expr,\n        result = [],\n        curLoop = set,\n        isXMLFilter = set && set[0] && Sizzle.isXML(set[0]);\n\n    while (expr && set.length) {\n      for (type in Expr.filter) {\n        if ((match = Expr.leftMatch[type].exec(expr)) != null && match[2]) {\n          filter = Expr.filter[type];\n          left = match[1];\n          anyFound = false;\n          match.splice(1, 1);\n\n          if (left.substr(left.length - 1) === \"\\\\\") {\n            continue;\n          }\n\n          if (curLoop === result) {\n            result = [];\n          }\n\n          if (Expr.preFilter[type]) {\n            match = Expr.preFilter[type](match, curLoop, inplace, result, not, isXMLFilter);\n\n            if (!match) {\n              anyFound = found = true;\n            } else if (match === true) {\n              continue;\n            }\n          }\n\n          if (match) {\n            for (i = 0; (item = curLoop[i]) != null; i++) {\n              if (item) {\n                found = filter(item, match, i, curLoop);\n                pass = not ^ found;\n\n                if (inplace && found != null) {\n                  if (pass) {\n                    anyFound = true;\n                  } else {\n                    curLoop[i] = false;\n                  }\n                } else if (pass) {\n                  result.push(item);\n                  anyFound = true;\n                }\n              }\n            }\n          }\n\n          if (found !== undefined) {\n            if (!inplace) {\n              curLoop = result;\n            }\n\n            expr = expr.replace(Expr.match[type], \"\");\n\n            if (!anyFound) {\n              return [];\n            }\n\n            break;\n          }\n        }\n      } // Improper expression\n\n\n      if (expr === old) {\n        if (anyFound == null) {\n          Sizzle.error(expr);\n        } else {\n          break;\n        }\n      }\n\n      old = expr;\n    }\n\n    return curLoop;\n  };\n\n  Sizzle.error = function (msg) {\n    throw new Error(\"Syntax error, unrecognized expression: \" + msg);\n  };\n  /**\n   * Utility function for retreiving the text value of an array of DOM nodes\n   * @param {Array|Element} elem\n   */\n\n\n  var getText = Sizzle.getText = function (elem) {\n    var i,\n        node,\n        nodeType = elem.nodeType,\n        ret = \"\";\n\n    if (nodeType) {\n      if (nodeType === 1 || nodeType === 9 || nodeType === 11) {\n        // Use textContent || innerText for elements\n        if (typeof elem.textContent === 'string') {\n          return elem.textContent;\n        } else if (typeof elem.innerText === 'string') {\n          // Replace IE's carriage returns\n          return elem.innerText.replace(rReturn, '');\n        } else {\n          // Traverse it's children\n          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n            ret += getText(elem);\n          }\n        }\n      } else if (nodeType === 3 || nodeType === 4) {\n        return elem.nodeValue;\n      }\n    } else {\n      // If no nodeType, this is expected to be an array\n      for (i = 0; node = elem[i]; i++) {\n        // Do not traverse comment nodes\n        if (node.nodeType !== 8) {\n          ret += getText(node);\n        }\n      }\n    }\n\n    return ret;\n  };\n\n  var Expr = Sizzle.selectors = {\n    order: [\"ID\", \"NAME\", \"TAG\"],\n    match: {\n      ID: /#((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)/,\n      CLASS: /\\.((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)/,\n      NAME: /\\[name=['\"]*((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)['\"]*\\]/,\n      ATTR: /\\[\\s*((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)\\s*(?:(\\S?=)\\s*(?:(['\"])(.*?)\\3|(#?(?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)*)|)|)\\s*\\]/,\n      TAG: /^((?:[\\w\\u00c0-\\uFFFF\\*\\-]|\\\\.)+)/,\n      CHILD: /:(only|nth|last|first)-child(?:\\(\\s*(even|odd|(?:[+\\-]?\\d+|(?:[+\\-]?\\d*)?n\\s*(?:[+\\-]\\s*\\d+)?))\\s*\\))?/,\n      POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\\((\\d*)\\))?(?=[^\\-]|$)/,\n      PSEUDO: /:((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)(?:\\((['\"]?)((?:\\([^\\)]+\\)|[^\\(\\)]*)+)\\2\\))?/\n    },\n    leftMatch: {},\n    attrMap: {\n      \"class\": \"className\",\n      \"for\": \"htmlFor\"\n    },\n    attrHandle: {\n      href: function (elem) {\n        return elem.getAttribute(\"href\");\n      },\n      type: function (elem) {\n        return elem.getAttribute(\"type\");\n      }\n    },\n    relative: {\n      \"+\": function (checkSet, part) {\n        var isPartStr = typeof part === \"string\",\n            isTag = isPartStr && !rNonWord.test(part),\n            isPartStrNotTag = isPartStr && !isTag;\n\n        if (isTag) {\n          part = part.toLowerCase();\n        }\n\n        for (var i = 0, l = checkSet.length, elem; i < l; i++) {\n          if (elem = checkSet[i]) {\n            while ((elem = elem.previousSibling) && elem.nodeType !== 1) {}\n\n            checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ? elem || false : elem === part;\n          }\n        }\n\n        if (isPartStrNotTag) {\n          Sizzle.filter(part, checkSet, true);\n        }\n      },\n      \">\": function (checkSet, part) {\n        var elem,\n            isPartStr = typeof part === \"string\",\n            i = 0,\n            l = checkSet.length;\n\n        if (isPartStr && !rNonWord.test(part)) {\n          part = part.toLowerCase();\n\n          for (; i < l; i++) {\n            elem = checkSet[i];\n\n            if (elem) {\n              var parent = elem.parentNode;\n              checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;\n            }\n          }\n        } else {\n          for (; i < l; i++) {\n            elem = checkSet[i];\n\n            if (elem) {\n              checkSet[i] = isPartStr ? elem.parentNode : elem.parentNode === part;\n            }\n          }\n\n          if (isPartStr) {\n            Sizzle.filter(part, checkSet, true);\n          }\n        }\n      },\n      \"\": function (checkSet, part, isXML) {\n        var nodeCheck,\n            doneName = done++,\n            checkFn = dirCheck;\n\n        if (typeof part === \"string\" && !rNonWord.test(part)) {\n          part = part.toLowerCase();\n          nodeCheck = part;\n          checkFn = dirNodeCheck;\n        }\n\n        checkFn(\"parentNode\", part, doneName, checkSet, nodeCheck, isXML);\n      },\n      \"~\": function (checkSet, part, isXML) {\n        var nodeCheck,\n            doneName = done++,\n            checkFn = dirCheck;\n\n        if (typeof part === \"string\" && !rNonWord.test(part)) {\n          part = part.toLowerCase();\n          nodeCheck = part;\n          checkFn = dirNodeCheck;\n        }\n\n        checkFn(\"previousSibling\", part, doneName, checkSet, nodeCheck, isXML);\n      }\n    },\n    find: {\n      ID: function (match, context, isXML) {\n        if (typeof context.getElementById !== \"undefined\" && !isXML) {\n          var m = context.getElementById(match[1]); // Check parentNode to catch when Blackberry 4.6 returns\n          // nodes that are no longer in the document #6963\n\n          return m && m.parentNode ? [m] : [];\n        }\n      },\n      NAME: function (match, context) {\n        if (typeof context.getElementsByName !== \"undefined\") {\n          var ret = [],\n              results = context.getElementsByName(match[1]);\n\n          for (var i = 0, l = results.length; i < l; i++) {\n            if (results[i].getAttribute(\"name\") === match[1]) {\n              ret.push(results[i]);\n            }\n          }\n\n          return ret.length === 0 ? null : ret;\n        }\n      },\n      TAG: function (match, context) {\n        if (typeof context.getElementsByTagName !== \"undefined\") {\n          return context.getElementsByTagName(match[1]);\n        }\n      }\n    },\n    preFilter: {\n      CLASS: function (match, curLoop, inplace, result, not, isXML) {\n        match = \" \" + match[1].replace(rBackslash, \"\") + \" \";\n\n        if (isXML) {\n          return match;\n        }\n\n        for (var i = 0, elem; (elem = curLoop[i]) != null; i++) {\n          if (elem) {\n            if (not ^ (elem.className && (\" \" + elem.className + \" \").replace(/[\\t\\n\\r]/g, \" \").indexOf(match) >= 0)) {\n              if (!inplace) {\n                result.push(elem);\n              }\n            } else if (inplace) {\n              curLoop[i] = false;\n            }\n          }\n        }\n\n        return false;\n      },\n      ID: function (match) {\n        return match[1].replace(rBackslash, \"\");\n      },\n      TAG: function (match, curLoop) {\n        return match[1].replace(rBackslash, \"\").toLowerCase();\n      },\n      CHILD: function (match) {\n        if (match[1] === \"nth\") {\n          if (!match[2]) {\n            Sizzle.error(match[0]);\n          }\n\n          match[2] = match[2].replace(/^\\+|\\s*/g, ''); // parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'\n\n          var test = /(-?)(\\d*)(?:n([+\\-]?\\d*))?/.exec(match[2] === \"even\" && \"2n\" || match[2] === \"odd\" && \"2n+1\" || !/\\D/.test(match[2]) && \"0n+\" + match[2] || match[2]); // calculate the numbers (first)n+(last) including if they are negative\n\n          match[2] = test[1] + (test[2] || 1) - 0;\n          match[3] = test[3] - 0;\n        } else if (match[2]) {\n          Sizzle.error(match[0]);\n        } // TODO: Move to normal caching system\n\n\n        match[0] = done++;\n        return match;\n      },\n      ATTR: function (match, curLoop, inplace, result, not, isXML) {\n        var name = match[1] = match[1].replace(rBackslash, \"\");\n\n        if (!isXML && Expr.attrMap[name]) {\n          match[1] = Expr.attrMap[name];\n        } // Handle if an un-quoted value was used\n\n\n        match[4] = (match[4] || match[5] || \"\").replace(rBackslash, \"\");\n\n        if (match[2] === \"~=\") {\n          match[4] = \" \" + match[4] + \" \";\n        }\n\n        return match;\n      },\n      PSEUDO: function (match, curLoop, inplace, result, not) {\n        if (match[1] === \"not\") {\n          // If we're dealing with a complex expression, or a simple one\n          if ((chunker.exec(match[3]) || \"\").length > 1 || /^\\w/.test(match[3])) {\n            match[3] = Sizzle(match[3], null, null, curLoop);\n          } else {\n            var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);\n\n            if (!inplace) {\n              result.push.apply(result, ret);\n            }\n\n            return false;\n          }\n        } else if (Expr.match.POS.test(match[0]) || Expr.match.CHILD.test(match[0])) {\n          return true;\n        }\n\n        return match;\n      },\n      POS: function (match) {\n        match.unshift(true);\n        return match;\n      }\n    },\n    filters: {\n      enabled: function (elem) {\n        return elem.disabled === false && elem.type !== \"hidden\";\n      },\n      disabled: function (elem) {\n        return elem.disabled === true;\n      },\n      checked: function (elem) {\n        return elem.checked === true;\n      },\n      selected: function (elem) {\n        // Accessing this property makes selected-by-default\n        // options in Safari work properly\n        if (elem.parentNode) {\n          elem.parentNode.selectedIndex;\n        }\n\n        return elem.selected === true;\n      },\n      parent: function (elem) {\n        return !!elem.firstChild;\n      },\n      empty: function (elem) {\n        return !elem.firstChild;\n      },\n      has: function (elem, i, match) {\n        return !!Sizzle(match[3], elem).length;\n      },\n      header: function (elem) {\n        return /h\\d/i.test(elem.nodeName);\n      },\n      text: function (elem) {\n        var attr = elem.getAttribute(\"type\"),\n            type = elem.type; // IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)\n        // use getAttribute instead to test this case\n\n        return elem.nodeName.toLowerCase() === \"input\" && \"text\" === type && (attr === type || attr === null);\n      },\n      radio: function (elem) {\n        return elem.nodeName.toLowerCase() === \"input\" && \"radio\" === elem.type;\n      },\n      checkbox: function (elem) {\n        return elem.nodeName.toLowerCase() === \"input\" && \"checkbox\" === elem.type;\n      },\n      file: function (elem) {\n        return elem.nodeName.toLowerCase() === \"input\" && \"file\" === elem.type;\n      },\n      password: function (elem) {\n        return elem.nodeName.toLowerCase() === \"input\" && \"password\" === elem.type;\n      },\n      submit: function (elem) {\n        var name = elem.nodeName.toLowerCase();\n        return (name === \"input\" || name === \"button\") && \"submit\" === elem.type;\n      },\n      image: function (elem) {\n        return elem.nodeName.toLowerCase() === \"input\" && \"image\" === elem.type;\n      },\n      reset: function (elem) {\n        var name = elem.nodeName.toLowerCase();\n        return (name === \"input\" || name === \"button\") && \"reset\" === elem.type;\n      },\n      button: function (elem) {\n        var name = elem.nodeName.toLowerCase();\n        return name === \"input\" && \"button\" === elem.type || name === \"button\";\n      },\n      input: function (elem) {\n        return /input|select|textarea|button/i.test(elem.nodeName);\n      },\n      focus: function (elem) {\n        return elem === elem.ownerDocument.activeElement;\n      }\n    },\n    setFilters: {\n      first: function (elem, i) {\n        return i === 0;\n      },\n      last: function (elem, i, match, array) {\n        return i === array.length - 1;\n      },\n      even: function (elem, i) {\n        return i % 2 === 0;\n      },\n      odd: function (elem, i) {\n        return i % 2 === 1;\n      },\n      lt: function (elem, i, match) {\n        return i < match[3] - 0;\n      },\n      gt: function (elem, i, match) {\n        return i > match[3] - 0;\n      },\n      nth: function (elem, i, match) {\n        return match[3] - 0 === i;\n      },\n      eq: function (elem, i, match) {\n        return match[3] - 0 === i;\n      }\n    },\n    filter: {\n      PSEUDO: function (elem, match, i, array) {\n        var name = match[1],\n            filter = Expr.filters[name];\n\n        if (filter) {\n          return filter(elem, i, match, array);\n        } else if (name === \"contains\") {\n          return (elem.textContent || elem.innerText || getText([elem]) || \"\").indexOf(match[3]) >= 0;\n        } else if (name === \"not\") {\n          var not = match[3];\n\n          for (var j = 0, l = not.length; j < l; j++) {\n            if (not[j] === elem) {\n              return false;\n            }\n          }\n\n          return true;\n        } else {\n          Sizzle.error(name);\n        }\n      },\n      CHILD: function (elem, match) {\n        var first,\n            last,\n            doneName,\n            parent,\n            cache,\n            count,\n            diff,\n            type = match[1],\n            node = elem;\n\n        switch (type) {\n          case \"only\":\n          case \"first\":\n            while (node = node.previousSibling) {\n              if (node.nodeType === 1) {\n                return false;\n              }\n            }\n\n            if (type === \"first\") {\n              return true;\n            }\n\n            node = elem;\n\n          /* falls through */\n\n          case \"last\":\n            while (node = node.nextSibling) {\n              if (node.nodeType === 1) {\n                return false;\n              }\n            }\n\n            return true;\n\n          case \"nth\":\n            first = match[2];\n            last = match[3];\n\n            if (first === 1 && last === 0) {\n              return true;\n            }\n\n            doneName = match[0];\n            parent = elem.parentNode;\n\n            if (parent && (parent[expando] !== doneName || !elem.nodeIndex)) {\n              count = 0;\n\n              for (node = parent.firstChild; node; node = node.nextSibling) {\n                if (node.nodeType === 1) {\n                  node.nodeIndex = ++count;\n                }\n              }\n\n              parent[expando] = doneName;\n            }\n\n            diff = elem.nodeIndex - last;\n\n            if (first === 0) {\n              return diff === 0;\n            } else {\n              return diff % first === 0 && diff / first >= 0;\n            }\n\n        }\n      },\n      ID: function (elem, match) {\n        return elem.nodeType === 1 && elem.getAttribute(\"id\") === match;\n      },\n      TAG: function (elem, match) {\n        return match === \"*\" && elem.nodeType === 1 || !!elem.nodeName && elem.nodeName.toLowerCase() === match;\n      },\n      CLASS: function (elem, match) {\n        return (\" \" + (elem.className || elem.getAttribute(\"class\")) + \" \").indexOf(match) > -1;\n      },\n      ATTR: function (elem, match) {\n        var name = match[1],\n            result = Sizzle.attr ? Sizzle.attr(elem, name) : Expr.attrHandle[name] ? Expr.attrHandle[name](elem) : elem[name] != null ? elem[name] : elem.getAttribute(name),\n            value = result + \"\",\n            type = match[2],\n            check = match[4];\n        return result == null ? type === \"!=\" : !type && Sizzle.attr ? result != null : type === \"=\" ? value === check : type === \"*=\" ? value.indexOf(check) >= 0 : type === \"~=\" ? (\" \" + value + \" \").indexOf(check) >= 0 : !check ? value && result !== false : type === \"!=\" ? value !== check : type === \"^=\" ? value.indexOf(check) === 0 : type === \"$=\" ? value.substr(value.length - check.length) === check : type === \"|=\" ? value === check || value.substr(0, check.length + 1) === check + \"-\" : false;\n      },\n      POS: function (elem, match, i, array) {\n        var name = match[2],\n            filter = Expr.setFilters[name];\n\n        if (filter) {\n          return filter(elem, i, match, array);\n        }\n      }\n    }\n  };\n\n  var origPOS = Expr.match.POS,\n      fescape = function (all, num) {\n    return \"\\\\\" + (num - 0 + 1);\n  };\n\n  for (var type in Expr.match) {\n    Expr.match[type] = new RegExp(Expr.match[type].source + /(?![^\\[]*\\])(?![^\\(]*\\))/.source);\n    Expr.leftMatch[type] = new RegExp(/(^(?:.|\\r|\\n)*?)/.source + Expr.match[type].source.replace(/\\\\(\\d+)/g, fescape));\n  } // Expose origPOS\n  // \"global\" as in regardless of relation to brackets/parens\n\n\n  Expr.match.globalPOS = origPOS;\n\n  var makeArray = function (array, results) {\n    array = Array.prototype.slice.call(array, 0);\n\n    if (results) {\n      results.push.apply(results, array);\n      return results;\n    }\n\n    return array;\n  }; // Perform a simple check to determine if the browser is capable of\n  // converting a NodeList to an array using builtin methods.\n  // Also verifies that the returned array holds DOM nodes\n  // (which is not the case in the Blackberry browser)\n\n\n  try {\n    Array.prototype.slice.call(document.documentElement.childNodes, 0)[0].nodeType; // Provide a fallback method if it does not work\n  } catch (e) {\n    makeArray = function (array, results) {\n      var i = 0,\n          ret = results || [];\n\n      if (toString.call(array) === \"[object Array]\") {\n        Array.prototype.push.apply(ret, array);\n      } else {\n        if (typeof array.length === \"number\") {\n          for (var l = array.length; i < l; i++) {\n            ret.push(array[i]);\n          }\n        } else {\n          for (; array[i]; i++) {\n            ret.push(array[i]);\n          }\n        }\n      }\n\n      return ret;\n    };\n  }\n\n  var sortOrder, siblingCheck;\n\n  if (document.documentElement.compareDocumentPosition) {\n    sortOrder = function (a, b) {\n      if (a === b) {\n        hasDuplicate = true;\n        return 0;\n      }\n\n      if (!a.compareDocumentPosition || !b.compareDocumentPosition) {\n        return a.compareDocumentPosition ? -1 : 1;\n      }\n\n      return a.compareDocumentPosition(b) & 4 ? -1 : 1;\n    };\n  } else {\n    sortOrder = function (a, b) {\n      // The nodes are identical, we can exit early\n      if (a === b) {\n        hasDuplicate = true;\n        return 0; // Fallback to using sourceIndex (in IE) if it's available on both nodes\n      } else if (a.sourceIndex && b.sourceIndex) {\n        return a.sourceIndex - b.sourceIndex;\n      }\n\n      var al,\n          bl,\n          ap = [],\n          bp = [],\n          aup = a.parentNode,\n          bup = b.parentNode,\n          cur = aup; // If the nodes are siblings (or identical) we can do a quick check\n\n      if (aup === bup) {\n        return siblingCheck(a, b); // If no parents were found then the nodes are disconnected\n      } else if (!aup) {\n        return -1;\n      } else if (!bup) {\n        return 1;\n      } // Otherwise they're somewhere else in the tree so we need\n      // to build up a full list of the parentNodes for comparison\n\n\n      while (cur) {\n        ap.unshift(cur);\n        cur = cur.parentNode;\n      }\n\n      cur = bup;\n\n      while (cur) {\n        bp.unshift(cur);\n        cur = cur.parentNode;\n      }\n\n      al = ap.length;\n      bl = bp.length; // Start walking down the tree looking for a discrepancy\n\n      for (var i = 0; i < al && i < bl; i++) {\n        if (ap[i] !== bp[i]) {\n          return siblingCheck(ap[i], bp[i]);\n        }\n      } // We ended someplace up the tree so do a sibling check\n\n\n      return i === al ? siblingCheck(a, bp[i], -1) : siblingCheck(ap[i], b, 1);\n    };\n\n    siblingCheck = function (a, b, ret) {\n      if (a === b) {\n        return ret;\n      }\n\n      var cur = a.nextSibling;\n\n      while (cur) {\n        if (cur === b) {\n          return -1;\n        }\n\n        cur = cur.nextSibling;\n      }\n\n      return 1;\n    };\n  } // Check to see if the browser returns elements by name when\n  // querying by getElementById (and provide a workaround)\n\n\n  (function () {\n    // We're going to inject a fake input element with a specified name\n    var form = document.createElement(\"div\"),\n        id = \"script\" + new Date().getTime(),\n        root = document.documentElement;\n    form.innerHTML = \"<a name='\" + id + \"'/>\"; // Inject it into the root element, check its status, and remove it quickly\n\n    root.insertBefore(form, root.firstChild); // The workaround has to do additional checks after a getElementById\n    // Which slows things down for other browsers (hence the branching)\n\n    if (document.getElementById(id)) {\n      Expr.find.ID = function (match, context, isXML) {\n        if (typeof context.getElementById !== \"undefined\" && !isXML) {\n          var m = context.getElementById(match[1]);\n          return m ? m.id === match[1] || typeof m.getAttributeNode !== \"undefined\" && m.getAttributeNode(\"id\").nodeValue === match[1] ? [m] : undefined : [];\n        }\n      };\n\n      Expr.filter.ID = function (elem, match) {\n        var node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n        return elem.nodeType === 1 && node && node.nodeValue === match;\n      };\n    }\n\n    root.removeChild(form); // release memory in IE\n\n    root = form = null;\n  })();\n\n  (function () {\n    // Check to see if the browser returns only elements\n    // when doing getElementsByTagName(\"*\")\n    // Create a fake element\n    var div = document.createElement(\"div\");\n    div.appendChild(document.createComment(\"\")); // Make sure no comments are found\n\n    if (div.getElementsByTagName(\"*\").length > 0) {\n      Expr.find.TAG = function (match, context) {\n        var results = context.getElementsByTagName(match[1]); // Filter out possible comments\n\n        if (match[1] === \"*\") {\n          var tmp = [];\n\n          for (var i = 0; results[i]; i++) {\n            if (results[i].nodeType === 1) {\n              tmp.push(results[i]);\n            }\n          }\n\n          results = tmp;\n        }\n\n        return results;\n      };\n    } // Check to see if an attribute returns normalized href attributes\n\n\n    div.innerHTML = \"<a href='#'></a>\";\n\n    if (div.firstChild && typeof div.firstChild.getAttribute !== \"undefined\" && div.firstChild.getAttribute(\"href\") !== \"#\") {\n      Expr.attrHandle.href = function (elem) {\n        return elem.getAttribute(\"href\", 2);\n      };\n    } // release memory in IE\n\n\n    div = null;\n  })(); // Patch for jsdom\n\n\n  if (document.querySelectorAll && false) {\n    (function () {\n      var oldSizzle = Sizzle,\n          div = document.createElement(\"div\"),\n          id = \"__sizzle__\";\n      div.innerHTML = \"<p class='TEST'></p>\"; // Safari can't handle uppercase or unicode characters when\n      // in quirks mode.\n\n      if (div.querySelectorAll && div.querySelectorAll(\".TEST\").length === 0) {\n        return;\n      }\n\n      Sizzle = function (query, context, extra, seed) {\n        context = context || document; // Only use querySelectorAll on non-XML documents\n        // (ID selectors don't work in non-HTML documents)\n\n        if (!seed && !Sizzle.isXML(context)) {\n          // See if we find a selector to speed up\n          var match = /^(\\w+$)|^\\.([\\w\\-]+$)|^#([\\w\\-]+$)/.exec(query);\n\n          if (match && (context.nodeType === 1 || context.nodeType === 9)) {\n            // Speed-up: Sizzle(\"TAG\")\n            if (match[1]) {\n              return makeArray(context.getElementsByTagName(query), extra); // Speed-up: Sizzle(\".CLASS\")\n            } else if (match[2] && Expr.find.CLASS && context.getElementsByClassName) {\n              return makeArray(context.getElementsByClassName(match[2]), extra);\n            }\n          }\n\n          if (context.nodeType === 9) {\n            // Speed-up: Sizzle(\"body\")\n            // The body element only exists once, optimize finding it\n            if (query === \"body\" && context.body) {\n              return makeArray([context.body], extra); // Speed-up: Sizzle(\"#ID\")\n            } else if (match && match[3]) {\n              var elem = context.getElementById(match[3]); // Check parentNode to catch when Blackberry 4.6 returns\n              // nodes that are no longer in the document #6963\n\n              if (elem && elem.parentNode) {\n                // Handle the case where IE and Opera return items\n                // by name instead of ID\n                if (elem.id === match[3]) {\n                  return makeArray([elem], extra);\n                }\n              } else {\n                return makeArray([], extra);\n              }\n            }\n\n            try {\n              return makeArray(context.querySelectorAll(query), extra);\n            } catch (qsaError) {} // qSA works strangely on Element-rooted queries\n            // We can work around this by specifying an extra ID on the root\n            // and working up from there (Thanks to Andrew Dupont for the technique)\n            // IE 8 doesn't work on object elements\n\n          } else if (context.nodeType === 1 && context.nodeName.toLowerCase() !== \"object\") {\n            var oldContext = context,\n                old = context.getAttribute(\"id\"),\n                nid = old || id,\n                hasParent = context.parentNode,\n                relativeHierarchySelector = /^\\s*[+~]/.test(query);\n\n            if (!old) {\n              context.setAttribute(\"id\", nid);\n            } else {\n              nid = nid.replace(/'/g, \"\\\\$&\");\n            }\n\n            if (relativeHierarchySelector && hasParent) {\n              context = context.parentNode;\n            }\n\n            try {\n              if (!relativeHierarchySelector || hasParent) {\n                return makeArray(context.querySelectorAll(\"[id='\" + nid + \"'] \" + query), extra);\n              }\n            } catch (pseudoError) {} finally {\n              if (!old) {\n                oldContext.removeAttribute(\"id\");\n              }\n            }\n          }\n        }\n\n        return oldSizzle(query, context, extra, seed);\n      };\n\n      for (var prop in oldSizzle) {\n        Sizzle[prop] = oldSizzle[prop];\n      } // release memory in IE\n\n\n      div = null;\n    })();\n  }\n\n  (function () {\n    var html = document.documentElement,\n        matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;\n\n    if (matches) {\n      // Check to see if it's possible to do matchesSelector\n      // on a disconnected node (IE 9 fails this)\n      var disconnectedMatch = !matches.call(document.createElement(\"div\"), \"div\"),\n          pseudoWorks = false;\n\n      try {\n        // This should fail with an exception\n        // Gecko does not error, returns false instead\n        matches.call(document.documentElement, \"[test!='']:sizzle\");\n      } catch (pseudoError) {\n        pseudoWorks = true;\n      }\n\n      Sizzle.matchesSelector = function (node, expr) {\n        // Make sure that attribute selectors are quoted\n        expr = expr.replace(/\\=\\s*([^'\"\\]]*)\\s*\\]/g, \"='$1']\");\n\n        if (!Sizzle.isXML(node)) {\n          try {\n            if (pseudoWorks || !Expr.match.PSEUDO.test(expr) && !/!=/.test(expr)) {\n              var ret = matches.call(node, expr); // IE 9's matchesSelector returns false on disconnected nodes\n\n              if (ret || !disconnectedMatch || // As well, disconnected nodes are said to be in a document\n              // fragment in IE 9, so check for that\n              node.document && node.document.nodeType !== 11) {\n                return ret;\n              }\n            }\n          } catch (e) {}\n        }\n\n        return Sizzle(expr, null, null, [node]).length > 0;\n      };\n    }\n  })();\n\n  (function () {\n    var div = document.createElement(\"div\");\n    div.innerHTML = \"<div class='test e'></div><div class='test'></div>\"; // Opera can't find a second classname (in 9.6)\n    // Also, make sure that getElementsByClassName actually exists\n\n    if (!div.getElementsByClassName || div.getElementsByClassName(\"e\").length === 0) {\n      return;\n    } // Safari caches class attributes, doesn't catch changes (in 3.2)\n\n\n    div.lastChild.className = \"e\";\n\n    if (div.getElementsByClassName(\"e\").length === 1) {\n      return;\n    }\n\n    Expr.order.splice(1, 0, \"CLASS\");\n\n    Expr.find.CLASS = function (match, context, isXML) {\n      if (typeof context.getElementsByClassName !== \"undefined\" && !isXML) {\n        return context.getElementsByClassName(match[1]);\n      }\n    }; // release memory in IE\n\n\n    div = null;\n  })();\n\n  function dirNodeCheck(dir, cur, doneName, checkSet, nodeCheck, isXML) {\n    for (var i = 0, l = checkSet.length; i < l; i++) {\n      var elem = checkSet[i];\n\n      if (elem) {\n        var match = false;\n        elem = elem[dir];\n\n        while (elem) {\n          if (elem[expando] === doneName) {\n            match = checkSet[elem.sizset];\n            break;\n          }\n\n          if (elem.nodeType === 1 && !isXML) {\n            elem[expando] = doneName;\n            elem.sizset = i;\n          }\n\n          if (elem.nodeName.toLowerCase() === cur) {\n            match = elem;\n            break;\n          }\n\n          elem = elem[dir];\n        }\n\n        checkSet[i] = match;\n      }\n    }\n  }\n\n  function dirCheck(dir, cur, doneName, checkSet, nodeCheck, isXML) {\n    for (var i = 0, l = checkSet.length; i < l; i++) {\n      var elem = checkSet[i];\n\n      if (elem) {\n        var match = false;\n        elem = elem[dir];\n\n        while (elem) {\n          if (elem[expando] === doneName) {\n            match = checkSet[elem.sizset];\n            break;\n          }\n\n          if (elem.nodeType === 1) {\n            if (!isXML) {\n              elem[expando] = doneName;\n              elem.sizset = i;\n            }\n\n            if (typeof cur !== \"string\") {\n              if (elem === cur) {\n                match = true;\n                break;\n              }\n            } else if (Sizzle.filter(cur, [elem]).length > 0) {\n              match = elem;\n              break;\n            }\n          }\n\n          elem = elem[dir];\n        }\n\n        checkSet[i] = match;\n      }\n    }\n  }\n\n  if (document.documentElement.contains) {\n    Sizzle.contains = function (a, b) {\n      return a !== b && (a.contains ? a.contains(b) : true);\n    };\n  } else if (document.documentElement.compareDocumentPosition) {\n    Sizzle.contains = function (a, b) {\n      return !!(a.compareDocumentPosition(b) & 16);\n    };\n  } else {\n    Sizzle.contains = function () {\n      return false;\n    };\n  }\n\n  Sizzle.isXML = function (elem) {\n    // documentElement is verified for cases where it doesn't yet exist\n    // (such as loading iframes in IE - #4833)\n    var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;\n    return documentElement ? documentElement.nodeName !== \"HTML\" : false;\n  };\n\n  var posProcess = function (selector, context, seed) {\n    var match,\n        tmpSet = [],\n        later = \"\",\n        root = context.nodeType ? [context] : context; // Position selectors must be done after the filter\n    // And so must :not(positional) so we move all PSEUDOs to the end\n\n    while (match = Expr.match.PSEUDO.exec(selector)) {\n      later += match[0];\n      selector = selector.replace(Expr.match.PSEUDO, \"\");\n    }\n\n    selector = Expr.relative[selector] ? selector + \"*\" : selector;\n\n    for (var i = 0, l = root.length; i < l; i++) {\n      Sizzle(selector, root[i], tmpSet, seed);\n    }\n\n    return Sizzle.filter(later, tmpSet);\n  }; // EXPOSE\n\n\n  return Sizzle;\n};","map":null,"metadata":{},"sourceType":"script"}