{"ast":null,"code":"//List from node-htmlparser\nvar singleTags = {\n  area: 1,\n  base: 1,\n  basefont: 1,\n  br: 1,\n  col: 1,\n  frame: 1,\n  hr: 1,\n  img: 1,\n  input: 1,\n  isindex: 1,\n  link: 1,\n  meta: 1,\n  param: 1,\n  embed: 1\n};\nvar expr = {\n  upperCaseChars: /([A-Z])/g,\n  breakBetweenTags: /(<(\\/?\\w+).*?>)(?=<(?!\\/\\2))/gi,\n  singleTag: function () {\n    var tags = [];\n\n    for (var i in singleTags) {\n      tags.push(i);\n    }\n\n    return new RegExp('<' + tags.join('|<'), 'i');\n  }()\n};\n\nvar uncanon = function (str, letter) {\n  return '-' + letter.toLowerCase();\n};\n\nvar HTMLEncode = require('./htmlencoding').HTMLEncode;\n\nexports.stringifyElement = function stringifyElement(element) {\n  var tagName = element.tagName.toLowerCase(),\n      ret = {\n    start: \"<\" + tagName,\n    end: ''\n  },\n      attributes = [],\n      i,\n      attribute = null;\n\n  if (element.attributes.length) {\n    ret.start += \" \";\n\n    for (i = 0; i < element.attributes.length; i++) {\n      attribute = element.attributes.item(i);\n      attributes.push(attribute.name + '=\"' + HTMLEncode(attribute.nodeValue, true) + '\"');\n    }\n  }\n\n  ret.start += attributes.join(\" \");\n\n  if (singleTags[tagName]) {\n    ret.start += \" />\";\n    ret.end = '';\n  } else {\n    ret.start += \">\";\n    ret.end = \"</\" + tagName + \">\";\n  }\n\n  return ret;\n};\n\nvar rawTextElements = /SCRIPT|STYLE/i;\n\nfunction stringifyDoctype(doctype) {\n  if (doctype.ownerDocument && doctype.ownerDocument._fullDT) {\n    return doctype.ownerDocument._fullDT;\n  }\n\n  var dt = '<!DOCTYPE ' + doctype.name;\n\n  if (doctype.publicId) {\n    // Public ID may never contain double quotes, so this is always safe.\n    dt += ' PUBLIC \"' + doctype.publicId + '\" ';\n  }\n\n  if (!doctype.publicId && doctype.systemId) {\n    dt += ' SYSTEM ';\n  }\n\n  if (doctype.systemId) {\n    // System ID may contain double quotes OR single quotes, not never both.\n    if (doctype.systemId.indexOf('\"') > -1) {\n      dt += \"'\" + doctype.systemId + \"'\";\n    } else {\n      dt += '\"' + doctype.systemId + '\"';\n    }\n  }\n\n  dt += '>';\n  return dt;\n}\n\nexports.makeHtmlGenerator = function makeHtmlGenerator(indentUnit, eol) {\n  indentUnit = indentUnit || \"\";\n  eol = eol || \"\";\n  return function generateHtmlRecursive(node, rawText, curIndent) {\n    var ret = \"\",\n        parent,\n        current,\n        i;\n    curIndent = curIndent || \"\";\n\n    if (node) {\n      if (node.nodeType && node.nodeType === node.ENTITY_REFERENCE_NODE) {\n        node = node._entity;\n      }\n\n      var childNodesRawText = rawText || rawTextElements.test(node.nodeName);\n\n      switch (node.nodeType) {\n        case node.ELEMENT_NODE:\n          current = exports.stringifyElement(node);\n\n          if (childNodesRawText) {\n            ret += curIndent + current.start;\n          } else {\n            ret += curIndent + current.start;\n          }\n\n          if (node._childNodes.length > 0) {\n            if (node._childNodes[0].nodeType !== node.TEXT_NODE) {\n              ret += eol;\n            }\n\n            for (i = 0; i < node._childNodes.length; i++) {\n              ret += generateHtmlRecursive(node._childNodes[i], childNodesRawText, curIndent + indentUnit);\n            }\n\n            if (node._childNodes[node._childNodes.length - 1].nodeType !== node.TEXT_NODE) {\n              ret += curIndent;\n            }\n\n            ret += current.end + eol;\n          } else {\n            ret += ((rawText ? node.nodeValue : HTMLEncode(node.nodeValue, false)) || '') + current.end + eol;\n          }\n\n          break;\n\n        case node.TEXT_NODE:\n          // Skip pure whitespace nodes if we're indenting\n          if (!indentUnit || !/^[\\s\\n]*$/.test(node.nodeValue)) {\n            ret += (rawText ? node.nodeValue : HTMLEncode(node.nodeValue, false)) || '';\n          }\n\n          break;\n\n        case node.COMMENT_NODE:\n          ret += curIndent + '<!--' + node.nodeValue + '-->' + eol;\n          break;\n\n        case node.DOCUMENT_NODE:\n          for (i = 0; i < node._childNodes.length; i++) {\n            ret += generateHtmlRecursive(node._childNodes[i], childNodesRawText, curIndent);\n          }\n\n          break;\n\n        case node.DOCUMENT_TYPE_NODE:\n          ret += stringifyDoctype(node);\n          break;\n      }\n    }\n\n    return ret;\n  };\n};\n\nexports.domToHtml = function (dom, noformat, raw) {\n  var htmlGenerator = exports.makeHtmlGenerator(noformat ? \"\" : \"  \", noformat ? \"\" : \"\\n\");\n\n  if (dom.toArray) {\n    // node list\n    dom = dom.toArray();\n  }\n\n  if (typeof dom.length !== 'undefined') {\n    var ret = \"\";\n\n    for (var i = 0, len = dom.length; i < len; i++) {\n      ret += htmlGenerator(dom[i], raw);\n    }\n\n    return ret;\n  } else {\n    // single node\n    return htmlGenerator(dom, raw);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}