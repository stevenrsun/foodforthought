{"ast":null,"code":"var HTMLDecode = require('./htmlencoding').HTMLDecode;\n\nfunction HtmlToDom(parser) {\n  if (parser && parser.write) {\n    // sax parser\n    this.appendHtmlToElement = function (html, element) {\n      var currentElement = element,\n          currentLevel = 0;\n\n      parser.onerror = function (e) {};\n\n      parser.ontext = function (t) {\n        var ownerDocument = currentElement.ownerDocument || currentElement;\n        var newText = ownerDocument.createTextNode(t);\n        currentElement.appendChild(newText);\n      };\n\n      parser.onopentag = function (node) {\n        var nodeName = node.name.toLowerCase(),\n            document = currentElement.ownerDocument || currentElement,\n            newElement = document.createElement(nodeName),\n            i = 0,\n            length = node.attributes && node.attributes.length ? node.attributes.length : 0;\n\n        for (i in node.attributes) {\n          if (node.attributes.hasOwnProperty(i)) {\n            newElement.setAttribute(i, node.attributes[i]);\n          }\n        }\n\n        for (i = 0; i < node.attributes.length; i++) {\n          newElement.setAttribute(i, node.attributes.item(i));\n        }\n\n        currentElement.appendChild(newElement);\n        currentElement = newElement;\n      };\n\n      parser.onclosetag = function (node) {\n        currentElement = currentElement.parentNode;\n      };\n\n      parser.write(html).close();\n      return element;\n    };\n  } else if (parser && (parser.ParseHtml || parser.DefaultHandler)) {\n    // Forgiving HTML parser\n    if (parser.ParseHtml) {// davglass/node-htmlparser\n    } else if (parser.DefaultHandler) {\n      // tautologistics/node-htmlparser\n      var handler = new parser.DefaultHandler(),\n          parserInstance = new parser.Parser(handler);\n\n      parser.ParseHtml = function (rawHtml) {\n        parserInstance.includeLocation = false;\n        parserInstance.parseComplete(rawHtml);\n        return handler.dom;\n      };\n    }\n\n    this.appendHtmlToElement = function (html, element) {\n      if (typeof html !== 'string') {\n        html += '';\n      }\n\n      var parsed = parser.ParseHtml(html);\n\n      for (var i = 0; i < parsed.length; i++) {\n        setChild(element, parsed[i]);\n      }\n\n      return element;\n    };\n  } else if (parser && parser.moduleName == 'HTML5') {\n    /* HTML5 parser */\n    this.appendHtmlToElement = function (html, element) {\n      if (typeof html !== 'string') {\n        html += '';\n      }\n\n      if (html.length > 0) {\n        if (element.nodeType == 9) {\n          new parser.Parser({\n            document: element\n          }).parse(html);\n        } else {\n          var p = new parser.Parser({\n            document: element.ownerDocument\n          });\n          p.parse_fragment(html, element);\n        }\n      }\n    };\n  } else {\n    this.appendHtmlToElement = function () {\n      console.log('');\n      console.log('###########################################################');\n      console.log('#  WARNING: No HTML parser could be found.');\n      console.log('#  Element.innerHTML setter support has been disabled');\n      console.log('#  Element.innerHTML getter support will still function');\n      console.log('#  Download: http://github.com/tautologistics/node-htmlparser');\n      console.log('###########################################################');\n      console.log('');\n    };\n  }\n}\n\n; // utility function for forgiving parser\n\nfunction setChild(parent, node) {\n  var c,\n      newNode,\n      currentDocument = parent._ownerDocument || parent;\n\n  switch (node.type) {\n    case 'tag':\n    case 'script':\n    case 'style':\n      try {\n        newNode = currentDocument.createElement(node.name);\n\n        if (node.location) {\n          newNode.sourceLocation = node.location;\n          newNode.sourceLocation.file = parent.sourceLocation.file;\n        }\n      } catch (err) {\n        currentDocument.raise('error', 'invalid markup', {\n          exception: err,\n          node: node\n        });\n        return null;\n      }\n\n      break;\n\n    case 'text':\n      newNode = currentDocument.createTextNode(HTMLDecode(node.data));\n      break;\n\n    case 'comment':\n      newNode = currentDocument.createComment(node.data);\n      break;\n\n    default:\n      return null;\n      break;\n  }\n\n  if (!newNode) return null;\n\n  if (node.attribs) {\n    for (c in node.attribs) {\n      // catchin errors here helps with improperly escaped attributes\n      // but properly fixing parent should (can only?) be done in the htmlparser itself\n      try {\n        newNode.setAttribute(c.toLowerCase(), HTMLDecode(node.attribs[c]));\n      } catch (e2) {\n        /* noop */\n      }\n    }\n  }\n\n  if (node.children) {\n    for (c = 0; c < node.children.length; c++) {\n      setChild(newNode, node.children[c]);\n    }\n  }\n\n  try {\n    return parent.appendChild(newNode);\n  } catch (err) {\n    currentDocument.raise('error', err.message, {\n      exception: err,\n      node: node\n    });\n    return null;\n  }\n}\n\nexports.HtmlToDom = HtmlToDom;","map":null,"metadata":{},"sourceType":"script"}