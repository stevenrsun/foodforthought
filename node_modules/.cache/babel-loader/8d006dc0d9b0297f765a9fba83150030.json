{"ast":null,"code":"(function () {\n  var d3_format_decimalPoint = \".\",\n      d3_format_thousandsSeparator = \",\",\n      d3_format_grouping = [3, 3];\n  if (!Date.now) Date.now = function () {\n    return +new Date();\n  };\n\n  try {\n    document.createElement(\"div\").style.setProperty(\"opacity\", 0, \"\");\n  } catch (error) {\n    var d3_style_prototype = CSSStyleDeclaration.prototype,\n        d3_style_setProperty = d3_style_prototype.setProperty;\n\n    d3_style_prototype.setProperty = function (name, value, priority) {\n      d3_style_setProperty.call(this, name, value + \"\", priority);\n    };\n  }\n\n  d3 = {\n    version: \"3.0.0\"\n  };\n  var π = Math.PI,\n      ε = 1e-6,\n      d3_radians = π / 180,\n      d3_degrees = 180 / π;\n\n  function d3_target(d) {\n    return d.target;\n  }\n\n  function d3_source(d) {\n    return d.source;\n  }\n\n  function d3_class(ctor, properties) {\n    try {\n      for (var key in properties) {\n        Object.defineProperty(ctor.prototype, key, {\n          value: properties[key],\n          enumerable: false\n        });\n      }\n    } catch (e) {\n      ctor.prototype = properties;\n    }\n  }\n\n  var d3_array = d3_arraySlice;\n\n  function d3_arrayCopy(pseudoarray) {\n    var i = -1,\n        n = pseudoarray.length,\n        array = [];\n\n    while (++i < n) array.push(pseudoarray[i]);\n\n    return array;\n  }\n\n  function d3_arraySlice(pseudoarray) {\n    return Array.prototype.slice.call(pseudoarray);\n  }\n\n  try {\n    d3_array(document.documentElement.childNodes)[0].nodeType;\n  } catch (e) {\n    d3_array = d3_arrayCopy;\n  }\n\n  var d3_arraySubclass = [].__proto__ ? function (array, prototype) {\n    array.__proto__ = prototype;\n  } : function (array, prototype) {\n    for (var property in prototype) array[property] = prototype[property];\n  };\n\n  d3.map = function (object) {\n    var map = new d3_Map();\n\n    for (var key in object) map.set(key, object[key]);\n\n    return map;\n  };\n\n  function d3_Map() {}\n\n  d3_class(d3_Map, {\n    has: function (key) {\n      return d3_map_prefix + key in this;\n    },\n    get: function (key) {\n      return this[d3_map_prefix + key];\n    },\n    set: function (key, value) {\n      return this[d3_map_prefix + key] = value;\n    },\n    remove: function (key) {\n      key = d3_map_prefix + key;\n      return key in this && delete this[key];\n    },\n    keys: function () {\n      var keys = [];\n      this.forEach(function (key) {\n        keys.push(key);\n      });\n      return keys;\n    },\n    values: function () {\n      var values = [];\n      this.forEach(function (key, value) {\n        values.push(value);\n      });\n      return values;\n    },\n    entries: function () {\n      var entries = [];\n      this.forEach(function (key, value) {\n        entries.push({\n          key: key,\n          value: value\n        });\n      });\n      return entries;\n    },\n    forEach: function (f) {\n      for (var key in this) {\n        if (key.charCodeAt(0) === d3_map_prefixCode) {\n          f.call(this, key.substring(1), this[key]);\n        }\n      }\n    }\n  });\n  var d3_map_prefix = \"\\0\",\n      d3_map_prefixCode = d3_map_prefix.charCodeAt(0);\n\n  function d3_identity(d) {\n    return d;\n  }\n\n  function d3_true() {\n    return true;\n  }\n\n  function d3_functor(v) {\n    return typeof v === \"function\" ? v : function () {\n      return v;\n    };\n  }\n\n  d3.functor = d3_functor;\n\n  d3.rebind = function (target, source) {\n    var i = 1,\n        n = arguments.length,\n        method;\n\n    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);\n\n    return target;\n  };\n\n  function d3_rebind(target, source, method) {\n    return function () {\n      var value = method.apply(source, arguments);\n      return arguments.length ? target : value;\n    };\n  }\n\n  d3.ascending = function (a, b) {\n    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n  };\n\n  d3.descending = function (a, b) {\n    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\n  };\n\n  d3.mean = function (array, f) {\n    var n = array.length,\n        a,\n        m = 0,\n        i = -1,\n        j = 0;\n\n    if (arguments.length === 1) {\n      while (++i < n) if (d3_number(a = array[i])) m += (a - m) / ++j;\n    } else {\n      while (++i < n) if (d3_number(a = f.call(array, array[i], i))) m += (a - m) / ++j;\n    }\n\n    return j ? m : undefined;\n  };\n\n  d3.median = function (array, f) {\n    if (arguments.length > 1) array = array.map(f);\n    array = array.filter(d3_number);\n    return array.length ? d3.quantile(array.sort(d3.ascending), .5) : undefined;\n  };\n\n  d3.min = function (array, f) {\n    var i = -1,\n        n = array.length,\n        a,\n        b;\n\n    if (arguments.length === 1) {\n      while (++i < n && ((a = array[i]) == null || a != a)) a = undefined;\n\n      while (++i < n) if ((b = array[i]) != null && a > b) a = b;\n    } else {\n      while (++i < n && ((a = f.call(array, array[i], i)) == null || a != a)) a = undefined;\n\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;\n    }\n\n    return a;\n  };\n\n  d3.max = function (array, f) {\n    var i = -1,\n        n = array.length,\n        a,\n        b;\n\n    if (arguments.length === 1) {\n      while (++i < n && ((a = array[i]) == null || a != a)) a = undefined;\n\n      while (++i < n) if ((b = array[i]) != null && b > a) a = b;\n    } else {\n      while (++i < n && ((a = f.call(array, array[i], i)) == null || a != a)) a = undefined;\n\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;\n    }\n\n    return a;\n  };\n\n  d3.extent = function (array, f) {\n    var i = -1,\n        n = array.length,\n        a,\n        b,\n        c;\n\n    if (arguments.length === 1) {\n      while (++i < n && ((a = c = array[i]) == null || a != a)) a = c = undefined;\n\n      while (++i < n) if ((b = array[i]) != null) {\n        if (a > b) a = b;\n        if (c < b) c = b;\n      }\n    } else {\n      while (++i < n && ((a = c = f.call(array, array[i], i)) == null || a != a)) a = undefined;\n\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {\n        if (a > b) a = b;\n        if (c < b) c = b;\n      }\n    }\n\n    return [a, c];\n  };\n\n  d3.random = {\n    normal: function (µ, σ) {\n      var n = arguments.length;\n      if (n < 2) σ = 1;\n      if (n < 1) µ = 0;\n      return function () {\n        var x, y, r;\n\n        do {\n          x = Math.random() * 2 - 1;\n          y = Math.random() * 2 - 1;\n          r = x * x + y * y;\n        } while (!r || r > 1);\n\n        return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);\n      };\n    },\n    logNormal: function (µ, σ) {\n      var n = arguments.length;\n      if (n < 2) σ = 1;\n      if (n < 1) µ = 0;\n      var random = d3.random.normal();\n      return function () {\n        return Math.exp(µ + σ * random());\n      };\n    },\n    irwinHall: function (m) {\n      return function () {\n        for (var s = 0, j = 0; j < m; j++) s += Math.random();\n\n        return s / m;\n      };\n    }\n  };\n\n  function d3_number(x) {\n    return x != null && !isNaN(x);\n  }\n\n  d3.sum = function (array, f) {\n    var s = 0,\n        n = array.length,\n        a,\n        i = -1;\n\n    if (arguments.length === 1) {\n      while (++i < n) if (!isNaN(a = +array[i])) s += a;\n    } else {\n      while (++i < n) if (!isNaN(a = +f.call(array, array[i], i))) s += a;\n    }\n\n    return s;\n  };\n\n  d3.quantile = function (values, p) {\n    var H = (values.length - 1) * p + 1,\n        h = Math.floor(H),\n        v = +values[h - 1],\n        e = H - h;\n    return e ? v + e * (values[h] - v) : v;\n  };\n\n  d3.shuffle = function (array) {\n    var m = array.length,\n        t,\n        i;\n\n    while (m) {\n      i = Math.random() * m-- | 0;\n      t = array[m], array[m] = array[i], array[i] = t;\n    }\n\n    return array;\n  };\n\n  d3.transpose = function (matrix) {\n    return d3.zip.apply(d3, matrix);\n  };\n\n  d3.zip = function () {\n    if (!(n = arguments.length)) return [];\n\n    for (var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i < m;) {\n      for (var j = -1, n, zip = zips[i] = new Array(n); ++j < n;) {\n        zip[j] = arguments[j][i];\n      }\n    }\n\n    return zips;\n  };\n\n  function d3_zipLength(d) {\n    return d.length;\n  }\n\n  d3.bisector = function (f) {\n    return {\n      left: function (a, x, lo, hi) {\n        if (arguments.length < 3) lo = 0;\n        if (arguments.length < 4) hi = a.length;\n\n        while (lo < hi) {\n          var mid = lo + hi >>> 1;\n          if (f.call(a, a[mid], mid) < x) lo = mid + 1;else hi = mid;\n        }\n\n        return lo;\n      },\n      right: function (a, x, lo, hi) {\n        if (arguments.length < 3) lo = 0;\n        if (arguments.length < 4) hi = a.length;\n\n        while (lo < hi) {\n          var mid = lo + hi >>> 1;\n          if (x < f.call(a, a[mid], mid)) hi = mid;else lo = mid + 1;\n        }\n\n        return lo;\n      }\n    };\n  };\n\n  var d3_bisector = d3.bisector(function (d) {\n    return d;\n  });\n  d3.bisectLeft = d3_bisector.left;\n  d3.bisect = d3.bisectRight = d3_bisector.right;\n\n  d3.nest = function () {\n    var nest = {},\n        keys = [],\n        sortKeys = [],\n        sortValues,\n        rollup;\n\n    function map(array, depth) {\n      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;\n      var i = -1,\n          n = array.length,\n          key = keys[depth++],\n          keyValue,\n          object,\n          valuesByKey = new d3_Map(),\n          values,\n          o = {};\n\n      while (++i < n) {\n        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {\n          values.push(object);\n        } else {\n          valuesByKey.set(keyValue, [object]);\n        }\n      }\n\n      valuesByKey.forEach(function (keyValue, values) {\n        o[keyValue] = map(values, depth);\n      });\n      return o;\n    }\n\n    function entries(map, depth) {\n      if (depth >= keys.length) return map;\n      var a = [],\n          sortKey = sortKeys[depth++],\n          key;\n\n      for (key in map) {\n        a.push({\n          key: key,\n          values: entries(map[key], depth)\n        });\n      }\n\n      if (sortKey) a.sort(function (a, b) {\n        return sortKey(a.key, b.key);\n      });\n      return a;\n    }\n\n    nest.map = function (array) {\n      return map(array, 0);\n    };\n\n    nest.entries = function (array) {\n      return entries(map(array, 0), 0);\n    };\n\n    nest.key = function (d) {\n      keys.push(d);\n      return nest;\n    };\n\n    nest.sortKeys = function (order) {\n      sortKeys[keys.length - 1] = order;\n      return nest;\n    };\n\n    nest.sortValues = function (order) {\n      sortValues = order;\n      return nest;\n    };\n\n    nest.rollup = function (f) {\n      rollup = f;\n      return nest;\n    };\n\n    return nest;\n  };\n\n  d3.keys = function (map) {\n    var keys = [];\n\n    for (var key in map) keys.push(key);\n\n    return keys;\n  };\n\n  d3.values = function (map) {\n    var values = [];\n\n    for (var key in map) values.push(map[key]);\n\n    return values;\n  };\n\n  d3.entries = function (map) {\n    var entries = [];\n\n    for (var key in map) entries.push({\n      key: key,\n      value: map[key]\n    });\n\n    return entries;\n  };\n\n  d3.permute = function (array, indexes) {\n    var permutes = [],\n        i = -1,\n        n = indexes.length;\n\n    while (++i < n) permutes[i] = array[indexes[i]];\n\n    return permutes;\n  };\n\n  d3.merge = function (arrays) {\n    return Array.prototype.concat.apply([], arrays);\n  };\n\n  function d3_collapse(s) {\n    return s.trim().replace(/\\s+/g, \" \");\n  }\n\n  d3.range = function (start, stop, step) {\n    if (arguments.length < 3) {\n      step = 1;\n\n      if (arguments.length < 2) {\n        stop = start;\n        start = 0;\n      }\n    }\n\n    if ((stop - start) / step === Infinity) throw new Error(\"infinite range\");\n    var range = [],\n        k = d3_range_integerScale(Math.abs(step)),\n        i = -1,\n        j;\n    start *= k, stop *= k, step *= k;\n    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k);else while ((j = start + step * ++i) < stop) range.push(j / k);\n    return range;\n  };\n\n  function d3_range_integerScale(x) {\n    var k = 1;\n\n    while (x * k % 1) k *= 10;\n\n    return k;\n  }\n\n  d3.requote = function (s) {\n    return s.replace(d3_requote_re, \"\\\\$&\");\n  };\n\n  var d3_requote_re = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n\n  d3.round = function (x, n) {\n    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);\n  };\n\n  d3.xhr = function (url, mimeType, callback) {\n    var xhr = {},\n        dispatch = d3.dispatch(\"progress\", \"load\", \"error\"),\n        headers = {},\n        response = d3_identity,\n        request = new (window.XDomainRequest && /^(http(s)?:)?\\/\\//.test(url) ? XDomainRequest : XMLHttpRequest)();\n    \"onload\" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function () {\n      request.readyState > 3 && respond();\n    };\n\n    function respond() {\n      var s = request.status;\n      !s && request.responseText || s >= 200 && s < 300 || s === 304 ? dispatch.load.call(xhr, response.call(xhr, request)) : dispatch.error.call(xhr, request);\n    }\n\n    request.onprogress = function (event) {\n      var o = d3.event;\n      d3.event = event;\n\n      try {\n        dispatch.progress.call(xhr, request);\n      } finally {\n        d3.event = o;\n      }\n    };\n\n    xhr.header = function (name, value) {\n      name = (name + \"\").toLowerCase();\n      if (arguments.length < 2) return headers[name];\n      if (value == null) delete headers[name];else headers[name] = value + \"\";\n      return xhr;\n    };\n\n    xhr.mimeType = function (value) {\n      if (!arguments.length) return mimeType;\n      mimeType = value == null ? null : value + \"\";\n      return xhr;\n    };\n\n    xhr.response = function (value) {\n      response = value;\n      return xhr;\n    };\n\n    [\"get\", \"post\"].forEach(function (method) {\n      xhr[method] = function () {\n        return xhr.send.apply(xhr, [method].concat(d3_array(arguments)));\n      };\n    });\n\n    xhr.send = function (method, data, callback) {\n      if (arguments.length === 2 && typeof data === \"function\") callback = data, data = null;\n      request.open(method, url, true);\n      if (mimeType != null && !(\"accept\" in headers)) headers[\"accept\"] = mimeType + \",*/*\";\n      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);\n      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);\n      if (callback != null) xhr.on(\"error\", callback).on(\"load\", function (request) {\n        callback(null, request);\n      });\n      request.send(data == null ? null : data);\n      return xhr;\n    };\n\n    xhr.abort = function () {\n      request.abort();\n      return xhr;\n    };\n\n    d3.rebind(xhr, dispatch, \"on\");\n    if (arguments.length === 2 && typeof mimeType === \"function\") callback = mimeType, mimeType = null;\n    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));\n  };\n\n  function d3_xhr_fixCallback(callback) {\n    return callback.length === 1 ? function (error, request) {\n      callback(error == null ? request : null);\n    } : callback;\n  }\n\n  d3.text = function () {\n    return d3.xhr.apply(d3, arguments).response(d3_text);\n  };\n\n  function d3_text(request) {\n    return request.responseText;\n  }\n\n  d3.json = function (url, callback) {\n    return d3.xhr(url, \"application/json\", callback).response(d3_json);\n  };\n\n  function d3_json(request) {\n    return JSON.parse(request.responseText);\n  }\n\n  d3.html = function (url, callback) {\n    return d3.xhr(url, \"text/html\", callback).response(d3_html);\n  };\n\n  function d3_html(request) {\n    var range = document.createRange();\n    range.selectNode(document.body);\n    return range.createContextualFragment(request.responseText);\n  }\n\n  d3.xml = function () {\n    return d3.xhr.apply(d3, arguments).response(d3_xml);\n  };\n\n  function d3_xml(request) {\n    return request.responseXML;\n  }\n\n  var d3_nsPrefix = {\n    svg: \"http://www.w3.org/2000/svg\",\n    xhtml: \"http://www.w3.org/1999/xhtml\",\n    xlink: \"http://www.w3.org/1999/xlink\",\n    xml: \"http://www.w3.org/XML/1998/namespace\",\n    xmlns: \"http://www.w3.org/2000/xmlns/\"\n  };\n  d3.ns = {\n    prefix: d3_nsPrefix,\n    qualify: function (name) {\n      var i = name.indexOf(\":\"),\n          prefix = name;\n\n      if (i >= 0) {\n        prefix = name.substring(0, i);\n        name = name.substring(i + 1);\n      }\n\n      return d3_nsPrefix.hasOwnProperty(prefix) ? {\n        space: d3_nsPrefix[prefix],\n        local: name\n      } : name;\n    }\n  };\n\n  d3.dispatch = function () {\n    var dispatch = new d3_dispatch(),\n        i = -1,\n        n = arguments.length;\n\n    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);\n\n    return dispatch;\n  };\n\n  function d3_dispatch() {}\n\n  d3_dispatch.prototype.on = function (type, listener) {\n    var i = type.indexOf(\".\"),\n        name = \"\";\n\n    if (i > 0) {\n      name = type.substring(i + 1);\n      type = type.substring(0, i);\n    }\n\n    return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);\n  };\n\n  function d3_dispatch_event(dispatch) {\n    var listeners = [],\n        listenerByName = new d3_Map();\n\n    function event() {\n      var z = listeners,\n          i = -1,\n          n = z.length,\n          l;\n\n      while (++i < n) if (l = z[i].on) l.apply(this, arguments);\n\n      return dispatch;\n    }\n\n    event.on = function (name, listener) {\n      var l = listenerByName.get(name),\n          i;\n      if (arguments.length < 2) return l && l.on;\n\n      if (l) {\n        l.on = null;\n        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));\n        listenerByName.remove(name);\n      }\n\n      if (listener) listeners.push(listenerByName.set(name, {\n        on: listener\n      }));\n      return dispatch;\n    };\n\n    return event;\n  }\n\n  d3.format = function (specifier) {\n    var match = d3_format_re.exec(specifier),\n        fill = match[1] || \" \",\n        align = match[2] || \">\",\n        sign = match[3] || \"\",\n        basePrefix = match[4] || \"\",\n        zfill = match[5],\n        width = +match[6],\n        comma = match[7],\n        precision = match[8],\n        type = match[9],\n        scale = 1,\n        suffix = \"\",\n        integer = false;\n    if (precision) precision = +precision.substring(1);\n\n    if (zfill || fill === \"0\" && align === \"=\") {\n      zfill = fill = \"0\";\n      align = \"=\";\n      if (comma) width -= Math.floor((width - 1) / 4);\n    }\n\n    switch (type) {\n      case \"n\":\n        comma = true;\n        type = \"g\";\n        break;\n\n      case \"%\":\n        scale = 100;\n        suffix = \"%\";\n        type = \"f\";\n        break;\n\n      case \"p\":\n        scale = 100;\n        suffix = \"%\";\n        type = \"r\";\n        break;\n\n      case \"b\":\n      case \"o\":\n      case \"x\":\n      case \"X\":\n        if (basePrefix) basePrefix = \"0\" + type.toLowerCase();\n\n      case \"c\":\n      case \"d\":\n        integer = true;\n        precision = 0;\n        break;\n\n      case \"s\":\n        scale = -1;\n        type = \"r\";\n        break;\n    }\n\n    if (basePrefix === \"#\") basePrefix = \"\";\n    if (type == \"r\" && !precision) type = \"g\";\n    type = d3_format_types.get(type) || d3_format_typeDefault;\n    var zcomma = zfill && comma;\n    return function (value) {\n      if (integer && value % 1) return \"\";\n      var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, \"-\") : sign;\n\n      if (scale < 0) {\n        var prefix = d3.formatPrefix(value, precision);\n        value = prefix.scale(value);\n        suffix = prefix.symbol;\n      } else {\n        value *= scale;\n      }\n\n      value = type(value, precision);\n      if (!zfill && comma) value = d3_format_group(value);\n      var length = basePrefix.length + value.length + (zcomma ? 0 : negative.length),\n          padding = length < width ? new Array(length = width - length + 1).join(fill) : \"\";\n      if (zcomma) value = d3_format_group(padding + value);\n      if (d3_format_decimalPoint) value.replace(\".\", d3_format_decimalPoint);\n      negative += basePrefix;\n      return (align === \"<\" ? negative + value + padding : align === \">\" ? padding + negative + value : align === \"^\" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + suffix;\n    };\n  };\n\n  var d3_format_re = /(?:([^{])?([<>=^]))?([+\\- ])?(#)?(0)?([0-9]+)?(,)?(\\.[0-9]+)?([a-zA-Z%])?/;\n  var d3_format_types = d3.map({\n    b: function (x) {\n      return x.toString(2);\n    },\n    c: function (x) {\n      return String.fromCharCode(x);\n    },\n    o: function (x) {\n      return x.toString(8);\n    },\n    x: function (x) {\n      return x.toString(16);\n    },\n    X: function (x) {\n      return x.toString(16).toUpperCase();\n    },\n    g: function (x, p) {\n      return x.toPrecision(p);\n    },\n    e: function (x, p) {\n      return x.toExponential(p);\n    },\n    f: function (x, p) {\n      return x.toFixed(p);\n    },\n    r: function (x, p) {\n      return d3.round(x, p = d3_format_precision(x, p)).toFixed(Math.max(0, Math.min(20, p)));\n    }\n  });\n\n  function d3_format_precision(x, p) {\n    return p - (x ? 1 + Math.floor(Math.log(x + Math.pow(10, 1 + Math.floor(Math.log(x) / Math.LN10) - p)) / Math.LN10) : 1);\n  }\n\n  function d3_format_typeDefault(x) {\n    return x + \"\";\n  }\n\n  var d3_format_group = d3_identity;\n\n  if (d3_format_grouping) {\n    var d3_format_groupingLength = d3_format_grouping.length;\n\n    d3_format_group = function (value) {\n      var i = value.lastIndexOf(\".\"),\n          f = i >= 0 ? \".\" + value.substring(i + 1) : (i = value.length, \"\"),\n          t = [],\n          j = 0,\n          g = d3_format_grouping[0];\n\n      while (i > 0 && g > 0) {\n        t.push(value.substring(i -= g, i + g));\n        g = d3_format_grouping[j = (j + 1) % d3_format_groupingLength];\n      }\n\n      return t.reverse().join(d3_format_thousandsSeparator || \"\") + f;\n    };\n  }\n\n  var d3_formatPrefixes = [\"y\", \"z\", \"a\", \"f\", \"p\", \"n\", \"μ\", \"m\", \"\", \"k\", \"M\", \"G\", \"T\", \"P\", \"E\", \"Z\", \"Y\"].map(d3_formatPrefix);\n\n  d3.formatPrefix = function (value, precision) {\n    var i = 0;\n\n    if (value) {\n      if (value < 0) value *= -1;\n      if (precision) value = d3.round(value, d3_format_precision(value, precision));\n      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);\n      i = Math.max(-24, Math.min(24, Math.floor((i <= 0 ? i + 1 : i - 1) / 3) * 3));\n    }\n\n    return d3_formatPrefixes[8 + i / 3];\n  };\n\n  function d3_formatPrefix(d, i) {\n    var k = Math.pow(10, Math.abs(8 - i) * 3);\n    return {\n      scale: i > 8 ? function (d) {\n        return d / k;\n      } : function (d) {\n        return d * k;\n      },\n      symbol: d\n    };\n  }\n\n  var d3_ease_default = function () {\n    return d3_identity;\n  };\n\n  var d3_ease = d3.map({\n    linear: d3_ease_default,\n    poly: d3_ease_poly,\n    quad: function () {\n      return d3_ease_quad;\n    },\n    cubic: function () {\n      return d3_ease_cubic;\n    },\n    sin: function () {\n      return d3_ease_sin;\n    },\n    exp: function () {\n      return d3_ease_exp;\n    },\n    circle: function () {\n      return d3_ease_circle;\n    },\n    elastic: d3_ease_elastic,\n    back: d3_ease_back,\n    bounce: function () {\n      return d3_ease_bounce;\n    }\n  });\n  var d3_ease_mode = d3.map({\n    \"in\": d3_identity,\n    out: d3_ease_reverse,\n    \"in-out\": d3_ease_reflect,\n    \"out-in\": function (f) {\n      return d3_ease_reflect(d3_ease_reverse(f));\n    }\n  });\n\n  d3.ease = function (name) {\n    var i = name.indexOf(\"-\"),\n        t = i >= 0 ? name.substring(0, i) : name,\n        m = i >= 0 ? name.substring(i + 1) : \"in\";\n    t = d3_ease.get(t) || d3_ease_default;\n    m = d3_ease_mode.get(m) || d3_identity;\n    return d3_ease_clamp(m(t.apply(null, Array.prototype.slice.call(arguments, 1))));\n  };\n\n  function d3_ease_clamp(f) {\n    return function (t) {\n      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);\n    };\n  }\n\n  function d3_ease_reverse(f) {\n    return function (t) {\n      return 1 - f(1 - t);\n    };\n  }\n\n  function d3_ease_reflect(f) {\n    return function (t) {\n      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));\n    };\n  }\n\n  function d3_ease_quad(t) {\n    return t * t;\n  }\n\n  function d3_ease_cubic(t) {\n    return t * t * t;\n  }\n\n  function d3_ease_cubicInOut(t) {\n    if (t <= 0) return 0;\n    if (t >= 1) return 1;\n    var t2 = t * t,\n        t3 = t2 * t;\n    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);\n  }\n\n  function d3_ease_poly(e) {\n    return function (t) {\n      return Math.pow(t, e);\n    };\n  }\n\n  function d3_ease_sin(t) {\n    return 1 - Math.cos(t * π / 2);\n  }\n\n  function d3_ease_exp(t) {\n    return Math.pow(2, 10 * (t - 1));\n  }\n\n  function d3_ease_circle(t) {\n    return 1 - Math.sqrt(1 - t * t);\n  }\n\n  function d3_ease_elastic(a, p) {\n    var s;\n    if (arguments.length < 2) p = .45;\n    if (arguments.length) s = p / (2 * π) * Math.asin(1 / a);else a = 1, s = p / 4;\n    return function (t) {\n      return 1 + a * Math.pow(2, 10 * -t) * Math.sin((t - s) * 2 * π / p);\n    };\n  }\n\n  function d3_ease_back(s) {\n    if (!s) s = 1.70158;\n    return function (t) {\n      return t * t * ((s + 1) * t - s);\n    };\n  }\n\n  function d3_ease_bounce(t) {\n    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;\n  }\n\n  d3.event = null;\n\n  function d3_eventCancel() {\n    d3.event.stopPropagation();\n    d3.event.preventDefault();\n  }\n\n  function d3_eventSource() {\n    var e = d3.event,\n        s;\n\n    while (s = e.sourceEvent) e = s;\n\n    return e;\n  }\n\n  function d3_eventDispatch(target) {\n    var dispatch = new d3_dispatch(),\n        i = 0,\n        n = arguments.length;\n\n    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);\n\n    dispatch.of = function (thiz, argumentz) {\n      return function (e1) {\n        try {\n          var e0 = e1.sourceEvent = d3.event;\n          e1.target = target;\n          d3.event = e1;\n          dispatch[e1.type].apply(thiz, argumentz);\n        } finally {\n          d3.event = e0;\n        }\n      };\n    };\n\n    return dispatch;\n  }\n\n  d3.transform = function (string) {\n    var g = document.createElementNS(d3.ns.prefix.svg, \"g\");\n    return (d3.transform = function (string) {\n      g.setAttribute(\"transform\", string);\n      var t = g.transform.baseVal.consolidate();\n      return new d3_transform(t ? t.matrix : d3_transformIdentity);\n    })(string);\n  };\n\n  function d3_transform(m) {\n    var r0 = [m.a, m.b],\n        r1 = [m.c, m.d],\n        kx = d3_transformNormalize(r0),\n        kz = d3_transformDot(r0, r1),\n        ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;\n\n    if (r0[0] * r1[1] < r1[0] * r0[1]) {\n      r0[0] *= -1;\n      r0[1] *= -1;\n      kx *= -1;\n      kz *= -1;\n    }\n\n    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;\n    this.translate = [m.e, m.f];\n    this.scale = [kx, ky];\n    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;\n  }\n\n  d3_transform.prototype.toString = function () {\n    return \"translate(\" + this.translate + \")rotate(\" + this.rotate + \")skewX(\" + this.skew + \")scale(\" + this.scale + \")\";\n  };\n\n  function d3_transformDot(a, b) {\n    return a[0] * b[0] + a[1] * b[1];\n  }\n\n  function d3_transformNormalize(a) {\n    var k = Math.sqrt(d3_transformDot(a, a));\n\n    if (k) {\n      a[0] /= k;\n      a[1] /= k;\n    }\n\n    return k;\n  }\n\n  function d3_transformCombine(a, b, k) {\n    a[0] += k * b[0];\n    a[1] += k * b[1];\n    return a;\n  }\n\n  var d3_transformIdentity = {\n    a: 1,\n    b: 0,\n    c: 0,\n    d: 1,\n    e: 0,\n    f: 0\n  };\n\n  d3.interpolate = function (a, b) {\n    var i = d3.interpolators.length,\n        f;\n\n    while (--i >= 0 && !(f = d3.interpolators[i](a, b)));\n\n    return f;\n  };\n\n  d3.interpolateNumber = function (a, b) {\n    b -= a;\n    return function (t) {\n      return a + b * t;\n    };\n  };\n\n  d3.interpolateRound = function (a, b) {\n    b -= a;\n    return function (t) {\n      return Math.round(a + b * t);\n    };\n  };\n\n  d3.interpolateString = function (a, b) {\n    var m,\n        i,\n        j,\n        s0 = 0,\n        s1 = 0,\n        s = [],\n        q = [],\n        n,\n        o;\n    d3_interpolate_number.lastIndex = 0;\n\n    for (i = 0; m = d3_interpolate_number.exec(b); ++i) {\n      if (m.index) s.push(b.substring(s0, s1 = m.index));\n      q.push({\n        i: s.length,\n        x: m[0]\n      });\n      s.push(null);\n      s0 = d3_interpolate_number.lastIndex;\n    }\n\n    if (s0 < b.length) s.push(b.substring(s0));\n\n    for (i = 0, n = q.length; (m = d3_interpolate_number.exec(a)) && i < n; ++i) {\n      o = q[i];\n\n      if (o.x == m[0]) {\n        if (o.i) {\n          if (s[o.i + 1] == null) {\n            s[o.i - 1] += o.x;\n            s.splice(o.i, 1);\n\n            for (j = i + 1; j < n; ++j) q[j].i--;\n          } else {\n            s[o.i - 1] += o.x + s[o.i + 1];\n            s.splice(o.i, 2);\n\n            for (j = i + 1; j < n; ++j) q[j].i -= 2;\n          }\n        } else {\n          if (s[o.i + 1] == null) {\n            s[o.i] = o.x;\n          } else {\n            s[o.i] = o.x + s[o.i + 1];\n            s.splice(o.i + 1, 1);\n\n            for (j = i + 1; j < n; ++j) q[j].i--;\n          }\n        }\n\n        q.splice(i, 1);\n        n--;\n        i--;\n      } else {\n        o.x = d3.interpolateNumber(parseFloat(m[0]), parseFloat(o.x));\n      }\n    }\n\n    while (i < n) {\n      o = q.pop();\n\n      if (s[o.i + 1] == null) {\n        s[o.i] = o.x;\n      } else {\n        s[o.i] = o.x + s[o.i + 1];\n        s.splice(o.i + 1, 1);\n      }\n\n      n--;\n    }\n\n    if (s.length === 1) {\n      return s[0] == null ? q[0].x : function () {\n        return b;\n      };\n    }\n\n    return function (t) {\n      for (i = 0; i < n; ++i) s[(o = q[i]).i] = o.x(t);\n\n      return s.join(\"\");\n    };\n  };\n\n  d3.interpolateTransform = function (a, b) {\n    var s = [],\n        q = [],\n        n,\n        A = d3.transform(a),\n        B = d3.transform(b),\n        ta = A.translate,\n        tb = B.translate,\n        ra = A.rotate,\n        rb = B.rotate,\n        wa = A.skew,\n        wb = B.skew,\n        ka = A.scale,\n        kb = B.scale;\n\n    if (ta[0] != tb[0] || ta[1] != tb[1]) {\n      s.push(\"translate(\", null, \",\", null, \")\");\n      q.push({\n        i: 1,\n        x: d3.interpolateNumber(ta[0], tb[0])\n      }, {\n        i: 3,\n        x: d3.interpolateNumber(ta[1], tb[1])\n      });\n    } else if (tb[0] || tb[1]) {\n      s.push(\"translate(\" + tb + \")\");\n    } else {\n      s.push(\"\");\n    }\n\n    if (ra != rb) {\n      if (ra - rb > 180) rb += 360;else if (rb - ra > 180) ra += 360;\n      q.push({\n        i: s.push(s.pop() + \"rotate(\", null, \")\") - 2,\n        x: d3.interpolateNumber(ra, rb)\n      });\n    } else if (rb) {\n      s.push(s.pop() + \"rotate(\" + rb + \")\");\n    }\n\n    if (wa != wb) {\n      q.push({\n        i: s.push(s.pop() + \"skewX(\", null, \")\") - 2,\n        x: d3.interpolateNumber(wa, wb)\n      });\n    } else if (wb) {\n      s.push(s.pop() + \"skewX(\" + wb + \")\");\n    }\n\n    if (ka[0] != kb[0] || ka[1] != kb[1]) {\n      n = s.push(s.pop() + \"scale(\", null, \",\", null, \")\");\n      q.push({\n        i: n - 4,\n        x: d3.interpolateNumber(ka[0], kb[0])\n      }, {\n        i: n - 2,\n        x: d3.interpolateNumber(ka[1], kb[1])\n      });\n    } else if (kb[0] != 1 || kb[1] != 1) {\n      s.push(s.pop() + \"scale(\" + kb + \")\");\n    }\n\n    n = q.length;\n    return function (t) {\n      var i = -1,\n          o;\n\n      while (++i < n) s[(o = q[i]).i] = o.x(t);\n\n      return s.join(\"\");\n    };\n  };\n\n  d3.interpolateRgb = function (a, b) {\n    a = d3.rgb(a);\n    b = d3.rgb(b);\n    var ar = a.r,\n        ag = a.g,\n        ab = a.b,\n        br = b.r - ar,\n        bg = b.g - ag,\n        bb = b.b - ab;\n    return function (t) {\n      return \"#\" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));\n    };\n  };\n\n  d3.interpolateHsl = function (a, b) {\n    a = d3.hsl(a);\n    b = d3.hsl(b);\n    var h0 = a.h,\n        s0 = a.s,\n        l0 = a.l,\n        h1 = b.h - h0,\n        s1 = b.s - s0,\n        l1 = b.l - l0;\n    if (h1 > 180) h1 -= 360;else if (h1 < -180) h1 += 360;\n    return function (t) {\n      return d3_hsl_rgb(h0 + h1 * t, s0 + s1 * t, l0 + l1 * t) + \"\";\n    };\n  };\n\n  d3.interpolateLab = function (a, b) {\n    a = d3.lab(a);\n    b = d3.lab(b);\n    var al = a.l,\n        aa = a.a,\n        ab = a.b,\n        bl = b.l - al,\n        ba = b.a - aa,\n        bb = b.b - ab;\n    return function (t) {\n      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + \"\";\n    };\n  };\n\n  d3.interpolateHcl = function (a, b) {\n    a = d3.hcl(a);\n    b = d3.hcl(b);\n    var ah = a.h,\n        ac = a.c,\n        al = a.l,\n        bh = b.h - ah,\n        bc = b.c - ac,\n        bl = b.l - al;\n    if (bh > 180) bh -= 360;else if (bh < -180) bh += 360;\n    return function (t) {\n      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + \"\";\n    };\n  };\n\n  d3.interpolateArray = function (a, b) {\n    var x = [],\n        c = [],\n        na = a.length,\n        nb = b.length,\n        n0 = Math.min(a.length, b.length),\n        i;\n\n    for (i = 0; i < n0; ++i) x.push(d3.interpolate(a[i], b[i]));\n\n    for (; i < na; ++i) c[i] = a[i];\n\n    for (; i < nb; ++i) c[i] = b[i];\n\n    return function (t) {\n      for (i = 0; i < n0; ++i) c[i] = x[i](t);\n\n      return c;\n    };\n  };\n\n  d3.interpolateObject = function (a, b) {\n    var i = {},\n        c = {},\n        k;\n\n    for (k in a) {\n      if (k in b) {\n        i[k] = d3_interpolateByName(k)(a[k], b[k]);\n      } else {\n        c[k] = a[k];\n      }\n    }\n\n    for (k in b) {\n      if (!(k in a)) {\n        c[k] = b[k];\n      }\n    }\n\n    return function (t) {\n      for (k in i) c[k] = i[k](t);\n\n      return c;\n    };\n  };\n\n  var d3_interpolate_number = /[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g;\n\n  function d3_interpolateByName(name) {\n    return name == \"transform\" ? d3.interpolateTransform : d3.interpolate;\n  }\n\n  d3.interpolators = [d3.interpolateObject, function (a, b) {\n    return b instanceof Array && d3.interpolateArray(a, b);\n  }, function (a, b) {\n    return (typeof a === \"string\" || typeof b === \"string\") && d3.interpolateString(a + \"\", b + \"\");\n  }, function (a, b) {\n    return (typeof b === \"string\" ? d3_rgb_names.has(b) || /^(#|rgb\\(|hsl\\()/.test(b) : b instanceof d3_Color) && d3.interpolateRgb(a, b);\n  }, function (a, b) {\n    return !isNaN(a = +a) && !isNaN(b = +b) && d3.interpolateNumber(a, b);\n  }];\n\n  function d3_uninterpolateNumber(a, b) {\n    b = b - (a = +a) ? 1 / (b - a) : 0;\n    return function (x) {\n      return (x - a) * b;\n    };\n  }\n\n  function d3_uninterpolateClamp(a, b) {\n    b = b - (a = +a) ? 1 / (b - a) : 0;\n    return function (x) {\n      return Math.max(0, Math.min(1, (x - a) * b));\n    };\n  }\n\n  function d3_Color() {}\n\n  d3_Color.prototype.toString = function () {\n    return this.rgb() + \"\";\n  };\n\n  d3.rgb = function (r, g, b) {\n    return arguments.length === 1 ? r instanceof d3_Rgb ? d3_rgb(r.r, r.g, r.b) : d3_rgb_parse(\"\" + r, d3_rgb, d3_hsl_rgb) : d3_rgb(~~r, ~~g, ~~b);\n  };\n\n  function d3_rgb(r, g, b) {\n    return new d3_Rgb(r, g, b);\n  }\n\n  function d3_Rgb(r, g, b) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n  }\n\n  var d3_rgbPrototype = d3_Rgb.prototype = new d3_Color();\n\n  d3_rgbPrototype.brighter = function (k) {\n    k = Math.pow(.7, arguments.length ? k : 1);\n    var r = this.r,\n        g = this.g,\n        b = this.b,\n        i = 30;\n    if (!r && !g && !b) return d3_rgb(i, i, i);\n    if (r && r < i) r = i;\n    if (g && g < i) g = i;\n    if (b && b < i) b = i;\n    return d3_rgb(Math.min(255, Math.floor(r / k)), Math.min(255, Math.floor(g / k)), Math.min(255, Math.floor(b / k)));\n  };\n\n  d3_rgbPrototype.darker = function (k) {\n    k = Math.pow(.7, arguments.length ? k : 1);\n    return d3_rgb(Math.floor(k * this.r), Math.floor(k * this.g), Math.floor(k * this.b));\n  };\n\n  d3_rgbPrototype.hsl = function () {\n    return d3_rgb_hsl(this.r, this.g, this.b);\n  };\n\n  d3_rgbPrototype.toString = function () {\n    return \"#\" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);\n  };\n\n  function d3_rgb_hex(v) {\n    return v < 16 ? \"0\" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);\n  }\n\n  function d3_rgb_parse(format, rgb, hsl) {\n    var r = 0,\n        g = 0,\n        b = 0,\n        m1,\n        m2,\n        name;\n    m1 = /([a-z]+)\\((.*)\\)/i.exec(format);\n\n    if (m1) {\n      m2 = m1[2].split(\",\");\n\n      switch (m1[1]) {\n        case \"hsl\":\n          {\n            return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);\n          }\n\n        case \"rgb\":\n          {\n            return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));\n          }\n      }\n    }\n\n    if (name = d3_rgb_names.get(format)) return rgb(name.r, name.g, name.b);\n\n    if (format != null && format.charAt(0) === \"#\") {\n      if (format.length === 4) {\n        r = format.charAt(1);\n        r += r;\n        g = format.charAt(2);\n        g += g;\n        b = format.charAt(3);\n        b += b;\n      } else if (format.length === 7) {\n        r = format.substring(1, 3);\n        g = format.substring(3, 5);\n        b = format.substring(5, 7);\n      }\n\n      r = parseInt(r, 16);\n      g = parseInt(g, 16);\n      b = parseInt(b, 16);\n    }\n\n    return rgb(r, g, b);\n  }\n\n  function d3_rgb_hsl(r, g, b) {\n    var min = Math.min(r /= 255, g /= 255, b /= 255),\n        max = Math.max(r, g, b),\n        d = max - min,\n        h,\n        s,\n        l = (max + min) / 2;\n\n    if (d) {\n      s = l < .5 ? d / (max + min) : d / (2 - max - min);\n      if (r == max) h = (g - b) / d + (g < b ? 6 : 0);else if (g == max) h = (b - r) / d + 2;else h = (r - g) / d + 4;\n      h *= 60;\n    } else {\n      s = h = 0;\n    }\n\n    return d3_hsl(h, s, l);\n  }\n\n  function d3_rgb_lab(r, g, b) {\n    r = d3_rgb_xyz(r);\n    g = d3_rgb_xyz(g);\n    b = d3_rgb_xyz(b);\n    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X),\n        y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y),\n        z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);\n    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));\n  }\n\n  function d3_rgb_xyz(r) {\n    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);\n  }\n\n  function d3_rgb_parseNumber(c) {\n    var f = parseFloat(c);\n    return c.charAt(c.length - 1) === \"%\" ? Math.round(f * 2.55) : f;\n  }\n\n  var d3_rgb_names = d3.map({\n    aliceblue: \"#f0f8ff\",\n    antiquewhite: \"#faebd7\",\n    aqua: \"#00ffff\",\n    aquamarine: \"#7fffd4\",\n    azure: \"#f0ffff\",\n    beige: \"#f5f5dc\",\n    bisque: \"#ffe4c4\",\n    black: \"#000000\",\n    blanchedalmond: \"#ffebcd\",\n    blue: \"#0000ff\",\n    blueviolet: \"#8a2be2\",\n    brown: \"#a52a2a\",\n    burlywood: \"#deb887\",\n    cadetblue: \"#5f9ea0\",\n    chartreuse: \"#7fff00\",\n    chocolate: \"#d2691e\",\n    coral: \"#ff7f50\",\n    cornflowerblue: \"#6495ed\",\n    cornsilk: \"#fff8dc\",\n    crimson: \"#dc143c\",\n    cyan: \"#00ffff\",\n    darkblue: \"#00008b\",\n    darkcyan: \"#008b8b\",\n    darkgoldenrod: \"#b8860b\",\n    darkgray: \"#a9a9a9\",\n    darkgreen: \"#006400\",\n    darkgrey: \"#a9a9a9\",\n    darkkhaki: \"#bdb76b\",\n    darkmagenta: \"#8b008b\",\n    darkolivegreen: \"#556b2f\",\n    darkorange: \"#ff8c00\",\n    darkorchid: \"#9932cc\",\n    darkred: \"#8b0000\",\n    darksalmon: \"#e9967a\",\n    darkseagreen: \"#8fbc8f\",\n    darkslateblue: \"#483d8b\",\n    darkslategray: \"#2f4f4f\",\n    darkslategrey: \"#2f4f4f\",\n    darkturquoise: \"#00ced1\",\n    darkviolet: \"#9400d3\",\n    deeppink: \"#ff1493\",\n    deepskyblue: \"#00bfff\",\n    dimgray: \"#696969\",\n    dimgrey: \"#696969\",\n    dodgerblue: \"#1e90ff\",\n    firebrick: \"#b22222\",\n    floralwhite: \"#fffaf0\",\n    forestgreen: \"#228b22\",\n    fuchsia: \"#ff00ff\",\n    gainsboro: \"#dcdcdc\",\n    ghostwhite: \"#f8f8ff\",\n    gold: \"#ffd700\",\n    goldenrod: \"#daa520\",\n    gray: \"#808080\",\n    green: \"#008000\",\n    greenyellow: \"#adff2f\",\n    grey: \"#808080\",\n    honeydew: \"#f0fff0\",\n    hotpink: \"#ff69b4\",\n    indianred: \"#cd5c5c\",\n    indigo: \"#4b0082\",\n    ivory: \"#fffff0\",\n    khaki: \"#f0e68c\",\n    lavender: \"#e6e6fa\",\n    lavenderblush: \"#fff0f5\",\n    lawngreen: \"#7cfc00\",\n    lemonchiffon: \"#fffacd\",\n    lightblue: \"#add8e6\",\n    lightcoral: \"#f08080\",\n    lightcyan: \"#e0ffff\",\n    lightgoldenrodyellow: \"#fafad2\",\n    lightgray: \"#d3d3d3\",\n    lightgreen: \"#90ee90\",\n    lightgrey: \"#d3d3d3\",\n    lightpink: \"#ffb6c1\",\n    lightsalmon: \"#ffa07a\",\n    lightseagreen: \"#20b2aa\",\n    lightskyblue: \"#87cefa\",\n    lightslategray: \"#778899\",\n    lightslategrey: \"#778899\",\n    lightsteelblue: \"#b0c4de\",\n    lightyellow: \"#ffffe0\",\n    lime: \"#00ff00\",\n    limegreen: \"#32cd32\",\n    linen: \"#faf0e6\",\n    magenta: \"#ff00ff\",\n    maroon: \"#800000\",\n    mediumaquamarine: \"#66cdaa\",\n    mediumblue: \"#0000cd\",\n    mediumorchid: \"#ba55d3\",\n    mediumpurple: \"#9370db\",\n    mediumseagreen: \"#3cb371\",\n    mediumslateblue: \"#7b68ee\",\n    mediumspringgreen: \"#00fa9a\",\n    mediumturquoise: \"#48d1cc\",\n    mediumvioletred: \"#c71585\",\n    midnightblue: \"#191970\",\n    mintcream: \"#f5fffa\",\n    mistyrose: \"#ffe4e1\",\n    moccasin: \"#ffe4b5\",\n    navajowhite: \"#ffdead\",\n    navy: \"#000080\",\n    oldlace: \"#fdf5e6\",\n    olive: \"#808000\",\n    olivedrab: \"#6b8e23\",\n    orange: \"#ffa500\",\n    orangered: \"#ff4500\",\n    orchid: \"#da70d6\",\n    palegoldenrod: \"#eee8aa\",\n    palegreen: \"#98fb98\",\n    paleturquoise: \"#afeeee\",\n    palevioletred: \"#db7093\",\n    papayawhip: \"#ffefd5\",\n    peachpuff: \"#ffdab9\",\n    peru: \"#cd853f\",\n    pink: \"#ffc0cb\",\n    plum: \"#dda0dd\",\n    powderblue: \"#b0e0e6\",\n    purple: \"#800080\",\n    red: \"#ff0000\",\n    rosybrown: \"#bc8f8f\",\n    royalblue: \"#4169e1\",\n    saddlebrown: \"#8b4513\",\n    salmon: \"#fa8072\",\n    sandybrown: \"#f4a460\",\n    seagreen: \"#2e8b57\",\n    seashell: \"#fff5ee\",\n    sienna: \"#a0522d\",\n    silver: \"#c0c0c0\",\n    skyblue: \"#87ceeb\",\n    slateblue: \"#6a5acd\",\n    slategray: \"#708090\",\n    slategrey: \"#708090\",\n    snow: \"#fffafa\",\n    springgreen: \"#00ff7f\",\n    steelblue: \"#4682b4\",\n    tan: \"#d2b48c\",\n    teal: \"#008080\",\n    thistle: \"#d8bfd8\",\n    tomato: \"#ff6347\",\n    turquoise: \"#40e0d0\",\n    violet: \"#ee82ee\",\n    wheat: \"#f5deb3\",\n    white: \"#ffffff\",\n    whitesmoke: \"#f5f5f5\",\n    yellow: \"#ffff00\",\n    yellowgreen: \"#9acd32\"\n  });\n  d3_rgb_names.forEach(function (key, value) {\n    d3_rgb_names.set(key, d3_rgb_parse(value, d3_rgb, d3_hsl_rgb));\n  });\n\n  d3.hsl = function (h, s, l) {\n    return arguments.length === 1 ? h instanceof d3_Hsl ? d3_hsl(h.h, h.s, h.l) : d3_rgb_parse(\"\" + h, d3_rgb_hsl, d3_hsl) : d3_hsl(+h, +s, +l);\n  };\n\n  function d3_hsl(h, s, l) {\n    return new d3_Hsl(h, s, l);\n  }\n\n  function d3_Hsl(h, s, l) {\n    this.h = h;\n    this.s = s;\n    this.l = l;\n  }\n\n  var d3_hslPrototype = d3_Hsl.prototype = new d3_Color();\n\n  d3_hslPrototype.brighter = function (k) {\n    k = Math.pow(.7, arguments.length ? k : 1);\n    return d3_hsl(this.h, this.s, this.l / k);\n  };\n\n  d3_hslPrototype.darker = function (k) {\n    k = Math.pow(.7, arguments.length ? k : 1);\n    return d3_hsl(this.h, this.s, k * this.l);\n  };\n\n  d3_hslPrototype.rgb = function () {\n    return d3_hsl_rgb(this.h, this.s, this.l);\n  };\n\n  function d3_hsl_rgb(h, s, l) {\n    var m1, m2;\n    h = h % 360;\n    if (h < 0) h += 360;\n    s = s < 0 ? 0 : s > 1 ? 1 : s;\n    l = l < 0 ? 0 : l > 1 ? 1 : l;\n    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;\n    m1 = 2 * l - m2;\n\n    function v(h) {\n      if (h > 360) h -= 360;else if (h < 0) h += 360;\n      if (h < 60) return m1 + (m2 - m1) * h / 60;\n      if (h < 180) return m2;\n      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;\n      return m1;\n    }\n\n    function vv(h) {\n      return Math.round(v(h) * 255);\n    }\n\n    return d3_rgb(vv(h + 120), vv(h), vv(h - 120));\n  }\n\n  d3.hcl = function (h, c, l) {\n    return arguments.length === 1 ? h instanceof d3_Hcl ? d3_hcl(h.h, h.c, h.l) : h instanceof d3_Lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : d3_hcl(+h, +c, +l);\n  };\n\n  function d3_hcl(h, c, l) {\n    return new d3_Hcl(h, c, l);\n  }\n\n  function d3_Hcl(h, c, l) {\n    this.h = h;\n    this.c = c;\n    this.l = l;\n  }\n\n  var d3_hclPrototype = d3_Hcl.prototype = new d3_Color();\n\n  d3_hclPrototype.brighter = function (k) {\n    return d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));\n  };\n\n  d3_hclPrototype.darker = function (k) {\n    return d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));\n  };\n\n  d3_hclPrototype.rgb = function () {\n    return d3_hcl_lab(this.h, this.c, this.l).rgb();\n  };\n\n  function d3_hcl_lab(h, c, l) {\n    return d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);\n  }\n\n  d3.lab = function (l, a, b) {\n    return arguments.length === 1 ? l instanceof d3_Lab ? d3_lab(l.l, l.a, l.b) : l instanceof d3_Hcl ? d3_hcl_lab(l.l, l.c, l.h) : d3_rgb_lab((l = d3.rgb(l)).r, l.g, l.b) : d3_lab(+l, +a, +b);\n  };\n\n  function d3_lab(l, a, b) {\n    return new d3_Lab(l, a, b);\n  }\n\n  function d3_Lab(l, a, b) {\n    this.l = l;\n    this.a = a;\n    this.b = b;\n  }\n\n  var d3_lab_K = 18;\n  var d3_lab_X = .95047,\n      d3_lab_Y = 1,\n      d3_lab_Z = 1.08883;\n  var d3_labPrototype = d3_Lab.prototype = new d3_Color();\n\n  d3_labPrototype.brighter = function (k) {\n    return d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);\n  };\n\n  d3_labPrototype.darker = function (k) {\n    return d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);\n  };\n\n  d3_labPrototype.rgb = function () {\n    return d3_lab_rgb(this.l, this.a, this.b);\n  };\n\n  function d3_lab_rgb(l, a, b) {\n    var y = (l + 16) / 116,\n        x = y + a / 500,\n        z = y - b / 200;\n    x = d3_lab_xyz(x) * d3_lab_X;\n    y = d3_lab_xyz(y) * d3_lab_Y;\n    z = d3_lab_xyz(z) * d3_lab_Z;\n    return d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));\n  }\n\n  function d3_lab_hcl(l, a, b) {\n    return d3_hcl(Math.atan2(b, a) / π * 180, Math.sqrt(a * a + b * b), l);\n  }\n\n  function d3_lab_xyz(x) {\n    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;\n  }\n\n  function d3_xyz_lab(x) {\n    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;\n  }\n\n  function d3_xyz_rgb(r) {\n    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));\n  }\n\n  function d3_selection(groups) {\n    d3_arraySubclass(groups, d3_selectionPrototype);\n    return groups;\n  }\n\n  var d3_select = function (s, n) {\n    return n.querySelector(s);\n  },\n      d3_selectAll = function (s, n) {\n    return n.querySelectorAll(s);\n  },\n      d3_selectRoot = document.documentElement,\n      d3_selectMatcher = d3_selectRoot.matchesSelector || d3_selectRoot.webkitMatchesSelector || d3_selectRoot.mozMatchesSelector || d3_selectRoot.msMatchesSelector || d3_selectRoot.oMatchesSelector,\n      d3_selectMatches = function (n, s) {\n    return d3_selectMatcher.call(n, s);\n  };\n\n  if (typeof Sizzle === \"function\") {\n    d3_select = function (s, n) {\n      return Sizzle(s, n)[0] || null;\n    };\n\n    d3_selectAll = function (s, n) {\n      return Sizzle.uniqueSort(Sizzle(s, n));\n    };\n\n    d3_selectMatches = Sizzle.matchesSelector;\n  }\n\n  var d3_selectionPrototype = [];\n\n  d3.selection = function () {\n    return d3_selectionRoot;\n  };\n\n  d3.selection.prototype = d3_selectionPrototype;\n\n  d3_selectionPrototype.select = function (selector) {\n    var subgroups = [],\n        subgroup,\n        subnode,\n        group,\n        node;\n    if (typeof selector !== \"function\") selector = d3_selection_selector(selector);\n\n    for (var j = -1, m = this.length; ++j < m;) {\n      subgroups.push(subgroup = []);\n      subgroup.parentNode = (group = this[j]).parentNode;\n\n      for (var i = -1, n = group.length; ++i < n;) {\n        if (node = group[i]) {\n          subgroup.push(subnode = selector.call(node, node.__data__, i));\n          if (subnode && \"__data__\" in node) subnode.__data__ = node.__data__;\n        } else {\n          subgroup.push(null);\n        }\n      }\n    }\n\n    return d3_selection(subgroups);\n  };\n\n  function d3_selection_selector(selector) {\n    return function () {\n      return d3_select(selector, this);\n    };\n  }\n\n  d3_selectionPrototype.selectAll = function (selector) {\n    var subgroups = [],\n        subgroup,\n        node;\n    if (typeof selector !== \"function\") selector = d3_selection_selectorAll(selector);\n\n    for (var j = -1, m = this.length; ++j < m;) {\n      for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n        if (node = group[i]) {\n          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i)));\n          subgroup.parentNode = node;\n        }\n      }\n    }\n\n    return d3_selection(subgroups);\n  };\n\n  function d3_selection_selectorAll(selector) {\n    return function () {\n      return d3_selectAll(selector, this);\n    };\n  }\n\n  d3_selectionPrototype.attr = function (name, value) {\n    if (arguments.length < 2) {\n      if (typeof name === \"string\") {\n        var node = this.node();\n        name = d3.ns.qualify(name);\n        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);\n      }\n\n      for (value in name) this.each(d3_selection_attr(value, name[value]));\n\n      return this;\n    }\n\n    return this.each(d3_selection_attr(name, value));\n  };\n\n  function d3_selection_attr(name, value) {\n    name = d3.ns.qualify(name);\n\n    function attrNull() {\n      this.removeAttribute(name);\n    }\n\n    function attrNullNS() {\n      this.removeAttributeNS(name.space, name.local);\n    }\n\n    function attrConstant() {\n      this.setAttribute(name, value);\n    }\n\n    function attrConstantNS() {\n      this.setAttributeNS(name.space, name.local, value);\n    }\n\n    function attrFunction() {\n      var x = value.apply(this, arguments);\n      if (x == null) this.removeAttribute(name);else this.setAttribute(name, x);\n    }\n\n    function attrFunctionNS() {\n      var x = value.apply(this, arguments);\n      if (x == null) this.removeAttributeNS(name.space, name.local);else this.setAttributeNS(name.space, name.local, x);\n    }\n\n    return value == null ? name.local ? attrNullNS : attrNull : typeof value === \"function\" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;\n  }\n\n  d3_selectionPrototype.classed = function (name, value) {\n    if (arguments.length < 2) {\n      if (typeof name === \"string\") {\n        var node = this.node(),\n            n = (name = name.trim().split(/^|\\s+/g)).length,\n            i = -1;\n\n        if (value = node.classList) {\n          while (++i < n) if (!value.contains(name[i])) return false;\n        } else {\n          value = node.className;\n          if (value.baseVal != null) value = value.baseVal;\n\n          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\n        }\n\n        return true;\n      }\n\n      for (value in name) this.each(d3_selection_classed(value, name[value]));\n\n      return this;\n    }\n\n    return this.each(d3_selection_classed(name, value));\n  };\n\n  function d3_selection_classedRe(name) {\n    return new RegExp(\"(?:^|\\\\s+)\" + d3.requote(name) + \"(?:\\\\s+|$)\", \"g\");\n  }\n\n  function d3_selection_classed(name, value) {\n    name = name.trim().split(/\\s+/).map(d3_selection_classedName);\n    var n = name.length;\n\n    function classedConstant() {\n      var i = -1;\n\n      while (++i < n) name[i](this, value);\n    }\n\n    function classedFunction() {\n      var i = -1,\n          x = value.apply(this, arguments);\n\n      while (++i < n) name[i](this, x);\n    }\n\n    return typeof value === \"function\" ? classedFunction : classedConstant;\n  }\n\n  function d3_selection_classedName(name) {\n    var re = d3_selection_classedRe(name);\n    return function (node, value) {\n      if (c = node.classList) return value ? c.add(name) : c.remove(name);\n      var c = node.className,\n          cb = c.baseVal != null,\n          cv = cb ? c.baseVal : c;\n\n      if (value) {\n        re.lastIndex = 0;\n\n        if (!re.test(cv)) {\n          cv = d3_collapse(cv + \" \" + name);\n          if (cb) c.baseVal = cv;else node.className = cv;\n        }\n      } else if (cv) {\n        cv = d3_collapse(cv.replace(re, \" \"));\n        if (cb) c.baseVal = cv;else node.className = cv;\n      }\n    };\n  }\n\n  d3_selectionPrototype.style = function (name, value, priority) {\n    var n = arguments.length;\n\n    if (n < 3) {\n      if (typeof name !== \"string\") {\n        if (n < 2) value = \"\";\n\n        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\n\n        return this;\n      }\n\n      if (n < 2) return getComputedStyle(this.node(), null).getPropertyValue(name);\n      priority = \"\";\n    }\n\n    return this.each(d3_selection_style(name, value, priority));\n  };\n\n  function d3_selection_style(name, value, priority) {\n    function styleNull() {\n      this.style.removeProperty(name);\n    }\n\n    function styleConstant() {\n      this.style.setProperty(name, value, priority);\n    }\n\n    function styleFunction() {\n      var x = value.apply(this, arguments);\n      if (x == null) this.style.removeProperty(name);else this.style.setProperty(name, x, priority);\n    }\n\n    return value == null ? styleNull : typeof value === \"function\" ? styleFunction : styleConstant;\n  }\n\n  d3_selectionPrototype.property = function (name, value) {\n    if (arguments.length < 2) {\n      if (typeof name === \"string\") return this.node()[name];\n\n      for (value in name) this.each(d3_selection_property(value, name[value]));\n\n      return this;\n    }\n\n    return this.each(d3_selection_property(name, value));\n  };\n\n  function d3_selection_property(name, value) {\n    function propertyNull() {\n      delete this[name];\n    }\n\n    function propertyConstant() {\n      this[name] = value;\n    }\n\n    function propertyFunction() {\n      var x = value.apply(this, arguments);\n      if (x == null) delete this[name];else this[name] = x;\n    }\n\n    return value == null ? propertyNull : typeof value === \"function\" ? propertyFunction : propertyConstant;\n  }\n\n  d3_selectionPrototype.text = function (value) {\n    return arguments.length ? this.each(typeof value === \"function\" ? function () {\n      var v = value.apply(this, arguments);\n      this.textContent = v == null ? \"\" : v;\n    } : value == null ? function () {\n      this.textContent = \"\";\n    } : function () {\n      this.textContent = value;\n    }) : this.node().textContent;\n  };\n\n  d3_selectionPrototype.html = function (value) {\n    return arguments.length ? this.each(typeof value === \"function\" ? function () {\n      var v = value.apply(this, arguments);\n      this.innerHTML = v == null ? \"\" : v;\n    } : value == null ? function () {\n      this.innerHTML = \"\";\n    } : function () {\n      this.innerHTML = value;\n    }) : this.node().innerHTML;\n  };\n\n  d3_selectionPrototype.append = function (name) {\n    name = d3.ns.qualify(name);\n\n    function append() {\n      return this.appendChild(document.createElementNS(this.namespaceURI, name));\n    }\n\n    function appendNS() {\n      return this.appendChild(document.createElementNS(name.space, name.local));\n    }\n\n    return this.select(name.local ? appendNS : append);\n  };\n\n  d3_selectionPrototype.insert = function (name, before) {\n    name = d3.ns.qualify(name);\n\n    function insert() {\n      return this.insertBefore(document.createElementNS(this.namespaceURI, name), d3_select(before, this));\n    }\n\n    function insertNS() {\n      return this.insertBefore(document.createElementNS(name.space, name.local), d3_select(before, this));\n    }\n\n    return this.select(name.local ? insertNS : insert);\n  };\n\n  d3_selectionPrototype.remove = function () {\n    return this.each(function () {\n      var parent = this.parentNode;\n      if (parent) parent.removeChild(this);\n    });\n  };\n\n  d3_selectionPrototype.data = function (value, key) {\n    var i = -1,\n        n = this.length,\n        group,\n        node;\n\n    if (!arguments.length) {\n      value = new Array(n = (group = this[0]).length);\n\n      while (++i < n) {\n        if (node = group[i]) {\n          value[i] = node.__data__;\n        }\n      }\n\n      return value;\n    }\n\n    function bind(group, groupData) {\n      var i,\n          n = group.length,\n          m = groupData.length,\n          n0 = Math.min(n, m),\n          n1 = Math.max(n, m),\n          updateNodes = [],\n          enterNodes = [],\n          exitNodes = [],\n          node,\n          nodeData;\n\n      if (key) {\n        var nodeByKeyValue = new d3_Map(),\n            keyValues = [],\n            keyValue,\n            j = groupData.length;\n\n        for (i = -1; ++i < n;) {\n          keyValue = key.call(node = group[i], node.__data__, i);\n\n          if (nodeByKeyValue.has(keyValue)) {\n            exitNodes[j++] = node;\n          } else {\n            nodeByKeyValue.set(keyValue, node);\n          }\n\n          keyValues.push(keyValue);\n        }\n\n        for (i = -1; ++i < m;) {\n          keyValue = key.call(groupData, nodeData = groupData[i], i);\n\n          if (nodeByKeyValue.has(keyValue)) {\n            updateNodes[i] = node = nodeByKeyValue.get(keyValue);\n            node.__data__ = nodeData;\n            enterNodes[i] = exitNodes[i] = null;\n          } else {\n            enterNodes[i] = d3_selection_dataNode(nodeData);\n            updateNodes[i] = exitNodes[i] = null;\n          }\n\n          nodeByKeyValue.remove(keyValue);\n        }\n\n        for (i = -1; ++i < n;) {\n          if (nodeByKeyValue.has(keyValues[i])) {\n            exitNodes[i] = group[i];\n          }\n        }\n      } else {\n        for (i = -1; ++i < n0;) {\n          node = group[i];\n          nodeData = groupData[i];\n\n          if (node) {\n            node.__data__ = nodeData;\n            updateNodes[i] = node;\n            enterNodes[i] = exitNodes[i] = null;\n          } else {\n            enterNodes[i] = d3_selection_dataNode(nodeData);\n            updateNodes[i] = exitNodes[i] = null;\n          }\n        }\n\n        for (; i < m; ++i) {\n          enterNodes[i] = d3_selection_dataNode(groupData[i]);\n          updateNodes[i] = exitNodes[i] = null;\n        }\n\n        for (; i < n1; ++i) {\n          exitNodes[i] = group[i];\n          enterNodes[i] = updateNodes[i] = null;\n        }\n      }\n\n      enterNodes.update = updateNodes;\n      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;\n      enter.push(enterNodes);\n      update.push(updateNodes);\n      exit.push(exitNodes);\n    }\n\n    var enter = d3_selection_enter([]),\n        update = d3_selection([]),\n        exit = d3_selection([]);\n\n    if (typeof value === \"function\") {\n      while (++i < n) {\n        bind(group = this[i], value.call(group, group.parentNode.__data__, i));\n      }\n    } else {\n      while (++i < n) {\n        bind(group = this[i], value);\n      }\n    }\n\n    update.enter = function () {\n      return enter;\n    };\n\n    update.exit = function () {\n      return exit;\n    };\n\n    return update;\n  };\n\n  function d3_selection_dataNode(data) {\n    return {\n      __data__: data\n    };\n  }\n\n  d3_selectionPrototype.datum = function (value) {\n    return arguments.length ? this.property(\"__data__\", value) : this.property(\"__data__\");\n  };\n\n  d3_selectionPrototype.filter = function (filter) {\n    var subgroups = [],\n        subgroup,\n        group,\n        node;\n    if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n    for (var j = 0, m = this.length; j < m; j++) {\n      subgroups.push(subgroup = []);\n      subgroup.parentNode = (group = this[j]).parentNode;\n\n      for (var i = 0, n = group.length; i < n; i++) {\n        if ((node = group[i]) && filter.call(node, node.__data__, i)) {\n          subgroup.push(node);\n        }\n      }\n    }\n\n    return d3_selection(subgroups);\n  };\n\n  function d3_selection_filter(selector) {\n    return function () {\n      return d3_selectMatches(this, selector);\n    };\n  }\n\n  d3_selectionPrototype.order = function () {\n    for (var j = -1, m = this.length; ++j < m;) {\n      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {\n        if (node = group[i]) {\n          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\n          next = node;\n        }\n      }\n    }\n\n    return this;\n  };\n\n  d3_selectionPrototype.sort = function (comparator) {\n    comparator = d3_selection_sortComparator.apply(this, arguments);\n\n    for (var j = -1, m = this.length; ++j < m;) this[j].sort(comparator);\n\n    return this.order();\n  };\n\n  function d3_selection_sortComparator(comparator) {\n    if (!arguments.length) comparator = d3.ascending;\n    return function (a, b) {\n      return comparator(a && a.__data__, b && b.__data__);\n    };\n  }\n\n  d3_selectionPrototype.on = function (type, listener, capture) {\n    var n = arguments.length;\n\n    if (n < 3) {\n      if (typeof type !== \"string\") {\n        if (n < 2) listener = false;\n\n        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\n\n        return this;\n      }\n\n      if (n < 2) return (n = this.node()[\"__on\" + type]) && n._;\n      capture = false;\n    }\n\n    return this.each(d3_selection_on(type, listener, capture));\n  };\n\n  function d3_selection_on(type, listener, capture) {\n    var name = \"__on\" + type,\n        i = type.indexOf(\".\");\n    if (i > 0) type = type.substring(0, i);\n\n    function onRemove() {\n      var wrapper = this[name];\n\n      if (wrapper) {\n        this.removeEventListener(type, wrapper, wrapper.$);\n        delete this[name];\n      }\n    }\n\n    function onAdd() {\n      var node = this,\n          args = d3_array(arguments);\n      onRemove.call(this);\n      this.addEventListener(type, this[name] = wrapper, wrapper.$ = capture);\n      wrapper._ = listener;\n\n      function wrapper(e) {\n        var o = d3.event;\n        d3.event = e;\n        args[0] = node.__data__;\n\n        try {\n          listener.apply(node, args);\n        } finally {\n          d3.event = o;\n        }\n      }\n    }\n\n    return listener ? onAdd : onRemove;\n  }\n\n  d3_selectionPrototype.each = function (callback) {\n    return d3_selection_each(this, function (node, i, j) {\n      callback.call(node, node.__data__, i, j);\n    });\n  };\n\n  function d3_selection_each(groups, callback) {\n    for (var j = 0, m = groups.length; j < m; j++) {\n      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\n        if (node = group[i]) callback(node, i, j);\n      }\n    }\n\n    return groups;\n  }\n\n  d3_selectionPrototype.call = function (callback) {\n    var args = d3_array(arguments);\n    callback.apply(args[0] = this, args);\n    return this;\n  };\n\n  d3_selectionPrototype.empty = function () {\n    return !this.node();\n  };\n\n  d3_selectionPrototype.node = function () {\n    for (var j = 0, m = this.length; j < m; j++) {\n      for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n        var node = group[i];\n        if (node) return node;\n      }\n    }\n\n    return null;\n  };\n\n  d3_selectionPrototype.transition = function () {\n    var id = d3_transitionInheritId || ++d3_transitionId,\n        subgroups = [],\n        subgroup,\n        node,\n        transition = Object.create(d3_transitionInherit);\n    transition.time = Date.now();\n\n    for (var j = -1, m = this.length; ++j < m;) {\n      subgroups.push(subgroup = []);\n\n      for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n        if (node = group[i]) d3_transitionNode(node, i, id, transition);\n        subgroup.push(node);\n      }\n    }\n\n    return d3_transition(subgroups, id);\n  };\n\n  var d3_selectionRoot = d3_selection([[document]]);\n  d3_selectionRoot[0].parentNode = d3_selectRoot;\n\n  d3.select = function (selector) {\n    return typeof selector === \"string\" ? d3_selectionRoot.select(selector) : d3_selection([[selector]]);\n  };\n\n  d3.selectAll = function (selector) {\n    return typeof selector === \"string\" ? d3_selectionRoot.selectAll(selector) : d3_selection([d3_array(selector)]);\n  };\n\n  function d3_selection_enter(selection) {\n    d3_arraySubclass(selection, d3_selection_enterPrototype);\n    return selection;\n  }\n\n  var d3_selection_enterPrototype = [];\n  d3.selection.enter = d3_selection_enter;\n  d3.selection.enter.prototype = d3_selection_enterPrototype;\n  d3_selection_enterPrototype.append = d3_selectionPrototype.append;\n  d3_selection_enterPrototype.insert = d3_selectionPrototype.insert;\n  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\n  d3_selection_enterPrototype.node = d3_selectionPrototype.node;\n\n  d3_selection_enterPrototype.select = function (selector) {\n    var subgroups = [],\n        subgroup,\n        subnode,\n        upgroup,\n        group,\n        node;\n\n    for (var j = -1, m = this.length; ++j < m;) {\n      upgroup = (group = this[j]).update;\n      subgroups.push(subgroup = []);\n      subgroup.parentNode = group.parentNode;\n\n      for (var i = -1, n = group.length; ++i < n;) {\n        if (node = group[i]) {\n          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i));\n          subnode.__data__ = node.__data__;\n        } else {\n          subgroup.push(null);\n        }\n      }\n    }\n\n    return d3_selection(subgroups);\n  };\n\n  function d3_transition(groups, id) {\n    d3_arraySubclass(groups, d3_transitionPrototype);\n    groups.id = id;\n    return groups;\n  }\n\n  var d3_transitionPrototype = [],\n      d3_transitionId = 0,\n      d3_transitionInheritId,\n      d3_transitionInherit = {\n    ease: d3_ease_cubicInOut,\n    delay: 0,\n    duration: 250\n  };\n  d3_transitionPrototype.call = d3_selectionPrototype.call;\n  d3_transitionPrototype.empty = d3_selectionPrototype.empty;\n  d3_transitionPrototype.node = d3_selectionPrototype.node;\n\n  d3.transition = function (selection) {\n    return arguments.length ? d3_transitionInheritId ? selection.transition() : selection : d3_selectionRoot.transition();\n  };\n\n  d3.transition.prototype = d3_transitionPrototype;\n\n  function d3_transitionNode(node, i, id, inherit) {\n    var lock = node.__transition__ || (node.__transition__ = {\n      active: 0,\n      count: 0\n    }),\n        transition = lock[id];\n\n    if (!transition) {\n      var time = inherit.time;\n      transition = lock[id] = {\n        tween: new d3_Map(),\n        event: d3.dispatch(\"start\", \"end\"),\n        time: time,\n        ease: inherit.ease,\n        delay: inherit.delay,\n        duration: inherit.duration\n      };\n      ++lock.count;\n      d3.timer(function (elapsed) {\n        var d = node.__data__,\n            ease = transition.ease,\n            event = transition.event,\n            delay = transition.delay,\n            duration = transition.duration,\n            tweened = [];\n        return delay <= elapsed ? start(elapsed) : d3.timer(start, delay, time), 1;\n\n        function start(elapsed) {\n          if (lock.active > id) return stop();\n          lock.active = id;\n          event.start.call(node, d, i);\n          transition.tween.forEach(function (key, value) {\n            if (value = value.call(node, d, i)) {\n              tweened.push(value);\n            }\n          });\n          if (!tick(elapsed)) d3.timer(tick, 0, time);\n          return 1;\n        }\n\n        function tick(elapsed) {\n          if (lock.active !== id) return stop();\n          var t = (elapsed - delay) / duration,\n              e = ease(t),\n              n = tweened.length;\n\n          while (n > 0) {\n            tweened[--n].call(node, e);\n          }\n\n          if (t >= 1) {\n            stop();\n            event.end.call(node, d, i);\n            return 1;\n          }\n        }\n\n        function stop() {\n          if (--lock.count) delete lock[id];else delete node.__transition__;\n          return 1;\n        }\n      }, 0, time);\n      return transition;\n    }\n  }\n\n  d3_transitionPrototype.select = function (selector) {\n    var id = this.id,\n        subgroups = [],\n        subgroup,\n        subnode,\n        node;\n    if (typeof selector !== \"function\") selector = d3_selection_selector(selector);\n\n    for (var j = -1, m = this.length; ++j < m;) {\n      subgroups.push(subgroup = []);\n\n      for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i))) {\n          if (\"__data__\" in node) subnode.__data__ = node.__data__;\n          d3_transitionNode(subnode, i, id, node.__transition__[id]);\n          subgroup.push(subnode);\n        } else {\n          subgroup.push(null);\n        }\n      }\n    }\n\n    return d3_transition(subgroups, id);\n  };\n\n  d3_transitionPrototype.selectAll = function (selector) {\n    var id = this.id,\n        subgroups = [],\n        subgroup,\n        subnodes,\n        node,\n        subnode,\n        transition;\n    if (typeof selector !== \"function\") selector = d3_selection_selectorAll(selector);\n\n    for (var j = -1, m = this.length; ++j < m;) {\n      for (var group = this[j], i = -1, n = group.length; ++i < n;) {\n        if (node = group[i]) {\n          transition = node.__transition__[id];\n          subnodes = selector.call(node, node.__data__, i);\n          subgroups.push(subgroup = []);\n\n          for (var k = -1, o = subnodes.length; ++k < o;) {\n            d3_transitionNode(subnode = subnodes[k], k, id, transition);\n            subgroup.push(subnode);\n          }\n        }\n      }\n    }\n\n    return d3_transition(subgroups, id);\n  };\n\n  d3_transitionPrototype.filter = function (filter) {\n    var subgroups = [],\n        subgroup,\n        group,\n        node;\n    if (typeof filter !== \"function\") filter = d3_selection_filter(filter);\n\n    for (var j = 0, m = this.length; j < m; j++) {\n      subgroups.push(subgroup = []);\n\n      for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n        if ((node = group[i]) && filter.call(node, node.__data__, i)) {\n          subgroup.push(node);\n        }\n      }\n    }\n\n    return d3_transition(subgroups, this.id, this.time).ease(this.ease());\n  };\n\n  d3_transitionPrototype.attr = function (nameNS, value) {\n    if (arguments.length < 2) {\n      for (value in nameNS) this.attr(value, nameNS[value]);\n\n      return this;\n    }\n\n    var interpolate = d3_interpolateByName(nameNS),\n        name = d3.ns.qualify(nameNS);\n\n    function attrNull() {\n      this.removeAttribute(name);\n    }\n\n    function attrNullNS() {\n      this.removeAttributeNS(name.space, name.local);\n    }\n\n    return d3_transition_tween(this, \"attr.\" + nameNS, value, function (b) {\n      function attrString() {\n        var a = this.getAttribute(name),\n            i;\n        return a !== b && (i = interpolate(a, b), function (t) {\n          this.setAttribute(name, i(t));\n        });\n      }\n\n      function attrStringNS() {\n        var a = this.getAttributeNS(name.space, name.local),\n            i;\n        return a !== b && (i = interpolate(a, b), function (t) {\n          this.setAttributeNS(name.space, name.local, i(t));\n        });\n      }\n\n      return b == null ? name.local ? attrNullNS : attrNull : (b += \"\", name.local ? attrStringNS : attrString);\n    });\n  };\n\n  d3_transitionPrototype.attrTween = function (nameNS, tween) {\n    var name = d3.ns.qualify(nameNS);\n\n    function attrTween(d, i) {\n      var f = tween.call(this, d, i, this.getAttribute(name));\n      return f && function (t) {\n        this.setAttribute(name, f(t));\n      };\n    }\n\n    function attrTweenNS(d, i) {\n      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));\n      return f && function (t) {\n        this.setAttributeNS(name.space, name.local, f(t));\n      };\n    }\n\n    return this.tween(\"attr.\" + nameNS, name.local ? attrTweenNS : attrTween);\n  };\n\n  d3_transitionPrototype.style = function (name, value, priority) {\n    var n = arguments.length;\n\n    if (n < 3) {\n      if (typeof name !== \"string\") {\n        if (n < 2) value = \"\";\n\n        for (priority in name) this.style(priority, name[priority], value);\n\n        return this;\n      }\n\n      priority = \"\";\n    }\n\n    var interpolate = d3_interpolateByName(name);\n\n    function styleNull() {\n      this.style.removeProperty(name);\n    }\n\n    return d3_transition_tween(this, \"style.\" + name, value, function (b) {\n      function styleString() {\n        var a = getComputedStyle(this, null).getPropertyValue(name),\n            i;\n        return a !== b && (i = interpolate(a, b), function (t) {\n          this.style.setProperty(name, i(t), priority);\n        });\n      }\n\n      return b == null ? styleNull : (b += \"\", styleString);\n    });\n  };\n\n  d3_transitionPrototype.styleTween = function (name, tween, priority) {\n    if (arguments.length < 3) priority = \"\";\n    return this.tween(\"style.\" + name, function (d, i) {\n      var f = tween.call(this, d, i, getComputedStyle(this, null).getPropertyValue(name));\n      return f && function (t) {\n        this.style.setProperty(name, f(t), priority);\n      };\n    });\n  };\n\n  d3_transitionPrototype.text = function (value) {\n    return d3_transition_tween(this, \"text\", value, d3_transition_text);\n  };\n\n  function d3_transition_text(b) {\n    if (b == null) b = \"\";\n    return function () {\n      this.textContent = b;\n    };\n  }\n\n  d3_transitionPrototype.remove = function () {\n    return this.each(\"end.transition\", function () {\n      var p;\n      if (!this.__transition__ && (p = this.parentNode)) p.removeChild(this);\n    });\n  };\n\n  d3_transitionPrototype.ease = function (value) {\n    var id = this.id;\n    if (arguments.length < 1) return this.node().__transition__[id].ease;\n    if (typeof value !== \"function\") value = d3.ease.apply(d3, arguments);\n    return d3_selection_each(this, function (node) {\n      node.__transition__[id].ease = value;\n    });\n  };\n\n  d3_transitionPrototype.delay = function (value) {\n    var id = this.id;\n    return d3_selection_each(this, typeof value === \"function\" ? function (node, i, j) {\n      node.__transition__[id].delay = value.call(node, node.__data__, i, j) | 0;\n    } : (value |= 0, function (node) {\n      node.__transition__[id].delay = value;\n    }));\n  };\n\n  d3_transitionPrototype.duration = function (value) {\n    var id = this.id;\n    return d3_selection_each(this, typeof value === \"function\" ? function (node, i, j) {\n      node.__transition__[id].duration = Math.max(1, value.call(node, node.__data__, i, j) | 0);\n    } : (value = Math.max(1, value | 0), function (node) {\n      node.__transition__[id].duration = value;\n    }));\n  };\n\n  d3_transitionPrototype.each = function (type, listener) {\n    var id = this.id;\n\n    if (arguments.length < 2) {\n      var inherit = d3_transitionInherit,\n          inheritId = d3_transitionInheritId;\n      d3_transitionInheritId = id;\n      d3_selection_each(this, function (node, i, j) {\n        d3_transitionInherit = node.__transition__[id];\n        type.call(node, node.__data__, i, j);\n      });\n      d3_transitionInherit = inherit;\n      d3_transitionInheritId = inheritId;\n    } else {\n      d3_selection_each(this, function (node) {\n        node.__transition__[id].event.on(type, listener);\n      });\n    }\n\n    return this;\n  };\n\n  d3_transitionPrototype.transition = function () {\n    var id0 = this.id,\n        id1 = ++d3_transitionId,\n        subgroups = [],\n        subgroup,\n        group,\n        node,\n        transition;\n\n    for (var j = 0, m = this.length; j < m; j++) {\n      subgroups.push(subgroup = []);\n\n      for (var group = this[j], i = 0, n = group.length; i < n; i++) {\n        if (node = group[i]) {\n          transition = Object.create(node.__transition__[id0]);\n          transition.delay += transition.duration;\n          d3_transitionNode(node, i, id1, transition);\n        }\n\n        subgroup.push(node);\n      }\n    }\n\n    return d3_transition(subgroups, id1);\n  };\n\n  d3_transitionPrototype.tween = function (name, tween) {\n    var id = this.id;\n    if (arguments.length < 2) return this.node().__transition__[id].tween.get(name);\n    return d3_selection_each(this, tween == null ? function (node) {\n      node.__transition__[id].tween.remove(name);\n    } : function (node) {\n      node.__transition__[id].tween.set(name, tween);\n    });\n  };\n\n  function d3_transition_tween(groups, name, value, tween) {\n    var id = groups.id;\n    return d3_selection_each(groups, typeof value === \"function\" ? function (node, i, j) {\n      node.__transition__[id].tween.set(name, tween(value.call(node, node.__data__, i, j)));\n    } : (value = tween(value), function (node) {\n      node.__transition__[id].tween.set(name, value);\n    }));\n  }\n\n  var d3_timer_id = 0,\n      d3_timer_byId = {},\n      d3_timer_queue = null,\n      d3_timer_interval,\n      d3_timer_timeout;\n\n  d3.timer = function (callback, delay, then) {\n    if (arguments.length < 3) {\n      if (arguments.length < 2) delay = 0;else if (!isFinite(delay)) return;\n      then = Date.now();\n    }\n\n    var timer = d3_timer_byId[callback.id];\n\n    if (timer && timer.callback === callback) {\n      timer.then = then;\n      timer.delay = delay;\n    } else d3_timer_byId[callback.id = ++d3_timer_id] = d3_timer_queue = {\n      callback: callback,\n      then: then,\n      delay: delay,\n      next: d3_timer_queue\n    };\n\n    if (!d3_timer_interval) {\n      d3_timer_timeout = clearTimeout(d3_timer_timeout);\n      d3_timer_interval = 1;\n      d3_timer_frame(d3_timer_step);\n    }\n  };\n\n  function d3_timer_step() {\n    var elapsed,\n        now = Date.now(),\n        t1 = d3_timer_queue;\n\n    while (t1) {\n      elapsed = now - t1.then;\n      if (elapsed >= t1.delay) t1.flush = t1.callback(elapsed);\n      t1 = t1.next;\n    }\n\n    var delay = d3_timer_flush() - now;\n\n    if (delay > 24) {\n      if (isFinite(delay)) {\n        clearTimeout(d3_timer_timeout);\n        d3_timer_timeout = setTimeout(d3_timer_step, delay);\n      }\n\n      d3_timer_interval = 0;\n    } else {\n      d3_timer_interval = 1;\n      d3_timer_frame(d3_timer_step);\n    }\n  }\n\n  d3.timer.flush = function () {\n    var elapsed,\n        now = Date.now(),\n        t1 = d3_timer_queue;\n\n    while (t1) {\n      elapsed = now - t1.then;\n      if (!t1.delay) t1.flush = t1.callback(elapsed);\n      t1 = t1.next;\n    }\n\n    d3_timer_flush();\n  };\n\n  function d3_timer_flush() {\n    var t0 = null,\n        t1 = d3_timer_queue,\n        then = Infinity;\n\n    while (t1) {\n      if (t1.flush) {\n        delete d3_timer_byId[t1.callback.id];\n        t1 = t0 ? t0.next = t1.next : d3_timer_queue = t1.next;\n      } else {\n        then = Math.min(then, t1.then + t1.delay);\n        t1 = (t0 = t1).next;\n      }\n    }\n\n    return then;\n  }\n\n  var d3_timer_frame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {\n    setTimeout(callback, 17);\n  };\n\n  d3.mouse = function (container) {\n    return d3_mousePoint(container, d3_eventSource());\n  };\n\n  var d3_mouse_bug44083 = /WebKit/.test(navigator.userAgent) ? -1 : 0;\n\n  function d3_mousePoint(container, e) {\n    var svg = container.ownerSVGElement || container;\n\n    if (svg.createSVGPoint) {\n      var point = svg.createSVGPoint();\n\n      if (d3_mouse_bug44083 < 0 && (window.scrollX || window.scrollY)) {\n        svg = d3.select(document.body).append(\"svg\").style(\"position\", \"absolute\").style(\"top\", 0).style(\"left\", 0);\n        var ctm = svg[0][0].getScreenCTM();\n        d3_mouse_bug44083 = !(ctm.f || ctm.e);\n        svg.remove();\n      }\n\n      if (d3_mouse_bug44083) {\n        point.x = e.pageX;\n        point.y = e.pageY;\n      } else {\n        point.x = e.clientX;\n        point.y = e.clientY;\n      }\n\n      point = point.matrixTransform(container.getScreenCTM().inverse());\n      return [point.x, point.y];\n    }\n\n    var rect = container.getBoundingClientRect();\n    return [e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop];\n  }\n\n  d3.touches = function (container, touches) {\n    if (arguments.length < 2) touches = d3_eventSource().touches;\n    return touches ? d3_array(touches).map(function (touch) {\n      var point = d3_mousePoint(container, touch);\n      point.identifier = touch.identifier;\n      return point;\n    }) : [];\n  };\n\n  function d3_noop() {}\n\n  d3.scale = {};\n\n  function d3_scaleExtent(domain) {\n    var start = domain[0],\n        stop = domain[domain.length - 1];\n    return start < stop ? [start, stop] : [stop, start];\n  }\n\n  function d3_scaleRange(scale) {\n    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());\n  }\n\n  function d3_scale_nice(domain, nice) {\n    var i0 = 0,\n        i1 = domain.length - 1,\n        x0 = domain[i0],\n        x1 = domain[i1],\n        dx;\n\n    if (x1 < x0) {\n      dx = i0, i0 = i1, i1 = dx;\n      dx = x0, x0 = x1, x1 = dx;\n    }\n\n    if (nice = nice(x1 - x0)) {\n      domain[i0] = nice.floor(x0);\n      domain[i1] = nice.ceil(x1);\n    }\n\n    return domain;\n  }\n\n  function d3_scale_niceDefault() {\n    return Math;\n  }\n\n  d3.scale.linear = function () {\n    return d3_scale_linear([0, 1], [0, 1], d3.interpolate, false);\n  };\n\n  function d3_scale_linear(domain, range, interpolate, clamp) {\n    var output, input;\n\n    function rescale() {\n      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear,\n          uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;\n      output = linear(domain, range, uninterpolate, interpolate);\n      input = linear(range, domain, uninterpolate, d3.interpolate);\n      return scale;\n    }\n\n    function scale(x) {\n      return output(x);\n    }\n\n    scale.invert = function (y) {\n      return input(y);\n    };\n\n    scale.domain = function (x) {\n      if (!arguments.length) return domain;\n      domain = x.map(Number);\n      return rescale();\n    };\n\n    scale.range = function (x) {\n      if (!arguments.length) return range;\n      range = x;\n      return rescale();\n    };\n\n    scale.rangeRound = function (x) {\n      return scale.range(x).interpolate(d3.interpolateRound);\n    };\n\n    scale.clamp = function (x) {\n      if (!arguments.length) return clamp;\n      clamp = x;\n      return rescale();\n    };\n\n    scale.interpolate = function (x) {\n      if (!arguments.length) return interpolate;\n      interpolate = x;\n      return rescale();\n    };\n\n    scale.ticks = function (m) {\n      return d3_scale_linearTicks(domain, m);\n    };\n\n    scale.tickFormat = function (m) {\n      return d3_scale_linearTickFormat(domain, m);\n    };\n\n    scale.nice = function () {\n      d3_scale_nice(domain, d3_scale_linearNice);\n      return rescale();\n    };\n\n    scale.copy = function () {\n      return d3_scale_linear(domain, range, interpolate, clamp);\n    };\n\n    return rescale();\n  }\n\n  function d3_scale_linearRebind(scale, linear) {\n    return d3.rebind(scale, linear, \"range\", \"rangeRound\", \"interpolate\", \"clamp\");\n  }\n\n  function d3_scale_linearNice(dx) {\n    dx = Math.pow(10, Math.round(Math.log(dx) / Math.LN10) - 1);\n    return dx && {\n      floor: function (x) {\n        return Math.floor(x / dx) * dx;\n      },\n      ceil: function (x) {\n        return Math.ceil(x / dx) * dx;\n      }\n    };\n  }\n\n  function d3_scale_linearTickRange(domain, m) {\n    var extent = d3_scaleExtent(domain),\n        span = extent[1] - extent[0],\n        step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)),\n        err = m / span * step;\n    if (err <= .15) step *= 10;else if (err <= .35) step *= 5;else if (err <= .75) step *= 2;\n    extent[0] = Math.ceil(extent[0] / step) * step;\n    extent[1] = Math.floor(extent[1] / step) * step + step * .5;\n    extent[2] = step;\n    return extent;\n  }\n\n  function d3_scale_linearTicks(domain, m) {\n    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));\n  }\n\n  function d3_scale_linearTickFormat(domain, m) {\n    return d3.format(\",.\" + Math.max(0, -Math.floor(Math.log(d3_scale_linearTickRange(domain, m)[2]) / Math.LN10 + .01)) + \"f\");\n  }\n\n  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {\n    var u = uninterpolate(domain[0], domain[1]),\n        i = interpolate(range[0], range[1]);\n    return function (x) {\n      return i(u(x));\n    };\n  }\n\n  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {\n    var u = [],\n        i = [],\n        j = 0,\n        k = Math.min(domain.length, range.length) - 1;\n\n    if (domain[k] < domain[0]) {\n      domain = domain.slice().reverse();\n      range = range.slice().reverse();\n    }\n\n    while (++j <= k) {\n      u.push(uninterpolate(domain[j - 1], domain[j]));\n      i.push(interpolate(range[j - 1], range[j]));\n    }\n\n    return function (x) {\n      var j = d3.bisect(domain, x, 1, k) - 1;\n      return i[j](u[j](x));\n    };\n  }\n\n  d3.scale.log = function () {\n    return d3_scale_log(d3.scale.linear(), d3_scale_logp);\n  };\n\n  function d3_scale_log(linear, log) {\n    var pow = log.pow;\n\n    function scale(x) {\n      return linear(log(x));\n    }\n\n    scale.invert = function (x) {\n      return pow(linear.invert(x));\n    };\n\n    scale.domain = function (x) {\n      if (!arguments.length) return linear.domain().map(pow);\n      log = x[0] < 0 ? d3_scale_logn : d3_scale_logp;\n      pow = log.pow;\n      linear.domain(x.map(log));\n      return scale;\n    };\n\n    scale.nice = function () {\n      linear.domain(d3_scale_nice(linear.domain(), d3_scale_niceDefault));\n      return scale;\n    };\n\n    scale.ticks = function () {\n      var extent = d3_scaleExtent(linear.domain()),\n          ticks = [];\n\n      if (extent.every(isFinite)) {\n        var i = Math.floor(extent[0]),\n            j = Math.ceil(extent[1]),\n            u = pow(extent[0]),\n            v = pow(extent[1]);\n\n        if (log === d3_scale_logn) {\n          ticks.push(pow(i));\n\n          for (; i++ < j;) for (var k = 9; k > 0; k--) ticks.push(pow(i) * k);\n        } else {\n          for (; i < j; i++) for (var k = 1; k < 10; k++) ticks.push(pow(i) * k);\n\n          ticks.push(pow(i));\n        }\n\n        for (i = 0; ticks[i] < u; i++) {}\n\n        for (j = ticks.length; ticks[j - 1] > v; j--) {}\n\n        ticks = ticks.slice(i, j);\n      }\n\n      return ticks;\n    };\n\n    scale.tickFormat = function (n, format) {\n      if (arguments.length < 2) format = d3_scale_logFormat;\n      if (!arguments.length) return format;\n      var k = Math.max(.1, n / scale.ticks().length),\n          f = log === d3_scale_logn ? (e = -1e-12, Math.floor) : (e = 1e-12, Math.ceil),\n          e;\n      return function (d) {\n        return d / pow(f(log(d) + e)) <= k ? format(d) : \"\";\n      };\n    };\n\n    scale.copy = function () {\n      return d3_scale_log(linear.copy(), log);\n    };\n\n    return d3_scale_linearRebind(scale, linear);\n  }\n\n  var d3_scale_logFormat = d3.format(\".0e\");\n\n  function d3_scale_logp(x) {\n    return Math.log(x < 0 ? 0 : x) / Math.LN10;\n  }\n\n  function d3_scale_logn(x) {\n    return -Math.log(x > 0 ? 0 : -x) / Math.LN10;\n  }\n\n  d3_scale_logp.pow = function (x) {\n    return Math.pow(10, x);\n  };\n\n  d3_scale_logn.pow = function (x) {\n    return -Math.pow(10, -x);\n  };\n\n  d3.scale.pow = function () {\n    return d3_scale_pow(d3.scale.linear(), 1);\n  };\n\n  function d3_scale_pow(linear, exponent) {\n    var powp = d3_scale_powPow(exponent),\n        powb = d3_scale_powPow(1 / exponent);\n\n    function scale(x) {\n      return linear(powp(x));\n    }\n\n    scale.invert = function (x) {\n      return powb(linear.invert(x));\n    };\n\n    scale.domain = function (x) {\n      if (!arguments.length) return linear.domain().map(powb);\n      linear.domain(x.map(powp));\n      return scale;\n    };\n\n    scale.ticks = function (m) {\n      return d3_scale_linearTicks(scale.domain(), m);\n    };\n\n    scale.tickFormat = function (m) {\n      return d3_scale_linearTickFormat(scale.domain(), m);\n    };\n\n    scale.nice = function () {\n      return scale.domain(d3_scale_nice(scale.domain(), d3_scale_linearNice));\n    };\n\n    scale.exponent = function (x) {\n      if (!arguments.length) return exponent;\n      var domain = scale.domain();\n      powp = d3_scale_powPow(exponent = x);\n      powb = d3_scale_powPow(1 / exponent);\n      return scale.domain(domain);\n    };\n\n    scale.copy = function () {\n      return d3_scale_pow(linear.copy(), exponent);\n    };\n\n    return d3_scale_linearRebind(scale, linear);\n  }\n\n  function d3_scale_powPow(e) {\n    return function (x) {\n      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);\n    };\n  }\n\n  d3.scale.sqrt = function () {\n    return d3.scale.pow().exponent(.5);\n  };\n\n  d3.scale.ordinal = function () {\n    return d3_scale_ordinal([], {\n      t: \"range\",\n      a: [[]]\n    });\n  };\n\n  function d3_scale_ordinal(domain, ranger) {\n    var index, range, rangeBand;\n\n    function scale(x) {\n      return range[((index.get(x) || index.set(x, domain.push(x))) - 1) % range.length];\n    }\n\n    function steps(start, step) {\n      return d3.range(domain.length).map(function (i) {\n        return start + step * i;\n      });\n    }\n\n    scale.domain = function (x) {\n      if (!arguments.length) return domain;\n      domain = [];\n      index = new d3_Map();\n      var i = -1,\n          n = x.length,\n          xi;\n\n      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));\n\n      return scale[ranger.t].apply(scale, ranger.a);\n    };\n\n    scale.range = function (x) {\n      if (!arguments.length) return range;\n      range = x;\n      rangeBand = 0;\n      ranger = {\n        t: \"range\",\n        a: arguments\n      };\n      return scale;\n    };\n\n    scale.rangePoints = function (x, padding) {\n      if (arguments.length < 2) padding = 0;\n      var start = x[0],\n          stop = x[1],\n          step = (stop - start) / (Math.max(1, domain.length - 1) + padding);\n      range = steps(domain.length < 2 ? (start + stop) / 2 : start + step * padding / 2, step);\n      rangeBand = 0;\n      ranger = {\n        t: \"rangePoints\",\n        a: arguments\n      };\n      return scale;\n    };\n\n    scale.rangeBands = function (x, padding, outerPadding) {\n      if (arguments.length < 2) padding = 0;\n      if (arguments.length < 3) outerPadding = padding;\n      var reverse = x[1] < x[0],\n          start = x[reverse - 0],\n          stop = x[1 - reverse],\n          step = (stop - start) / (domain.length - padding + 2 * outerPadding);\n      range = steps(start + step * outerPadding, step);\n      if (reverse) range.reverse();\n      rangeBand = step * (1 - padding);\n      ranger = {\n        t: \"rangeBands\",\n        a: arguments\n      };\n      return scale;\n    };\n\n    scale.rangeRoundBands = function (x, padding, outerPadding) {\n      if (arguments.length < 2) padding = 0;\n      if (arguments.length < 3) outerPadding = padding;\n      var reverse = x[1] < x[0],\n          start = x[reverse - 0],\n          stop = x[1 - reverse],\n          step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding)),\n          error = stop - start - (domain.length - padding) * step;\n      range = steps(start + Math.round(error / 2), step);\n      if (reverse) range.reverse();\n      rangeBand = Math.round(step * (1 - padding));\n      ranger = {\n        t: \"rangeRoundBands\",\n        a: arguments\n      };\n      return scale;\n    };\n\n    scale.rangeBand = function () {\n      return rangeBand;\n    };\n\n    scale.rangeExtent = function () {\n      return d3_scaleExtent(ranger.a[0]);\n    };\n\n    scale.copy = function () {\n      return d3_scale_ordinal(domain, ranger);\n    };\n\n    return scale.domain(domain);\n  }\n\n  d3.scale.category10 = function () {\n    return d3.scale.ordinal().range(d3_category10);\n  };\n\n  d3.scale.category20 = function () {\n    return d3.scale.ordinal().range(d3_category20);\n  };\n\n  d3.scale.category20b = function () {\n    return d3.scale.ordinal().range(d3_category20b);\n  };\n\n  d3.scale.category20c = function () {\n    return d3.scale.ordinal().range(d3_category20c);\n  };\n\n  var d3_category10 = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\", \"#e377c2\", \"#7f7f7f\", \"#bcbd22\", \"#17becf\"];\n  var d3_category20 = [\"#1f77b4\", \"#aec7e8\", \"#ff7f0e\", \"#ffbb78\", \"#2ca02c\", \"#98df8a\", \"#d62728\", \"#ff9896\", \"#9467bd\", \"#c5b0d5\", \"#8c564b\", \"#c49c94\", \"#e377c2\", \"#f7b6d2\", \"#7f7f7f\", \"#c7c7c7\", \"#bcbd22\", \"#dbdb8d\", \"#17becf\", \"#9edae5\"];\n  var d3_category20b = [\"#393b79\", \"#5254a3\", \"#6b6ecf\", \"#9c9ede\", \"#637939\", \"#8ca252\", \"#b5cf6b\", \"#cedb9c\", \"#8c6d31\", \"#bd9e39\", \"#e7ba52\", \"#e7cb94\", \"#843c39\", \"#ad494a\", \"#d6616b\", \"#e7969c\", \"#7b4173\", \"#a55194\", \"#ce6dbd\", \"#de9ed6\"];\n  var d3_category20c = [\"#3182bd\", \"#6baed6\", \"#9ecae1\", \"#c6dbef\", \"#e6550d\", \"#fd8d3c\", \"#fdae6b\", \"#fdd0a2\", \"#31a354\", \"#74c476\", \"#a1d99b\", \"#c7e9c0\", \"#756bb1\", \"#9e9ac8\", \"#bcbddc\", \"#dadaeb\", \"#636363\", \"#969696\", \"#bdbdbd\", \"#d9d9d9\"];\n\n  d3.scale.quantile = function () {\n    return d3_scale_quantile([], []);\n  };\n\n  function d3_scale_quantile(domain, range) {\n    var thresholds;\n\n    function rescale() {\n      var k = 0,\n          q = range.length;\n      thresholds = [];\n\n      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);\n\n      return scale;\n    }\n\n    function scale(x) {\n      if (isNaN(x = +x)) return NaN;\n      return range[d3.bisect(thresholds, x)];\n    }\n\n    scale.domain = function (x) {\n      if (!arguments.length) return domain;\n      domain = x.filter(function (d) {\n        return !isNaN(d);\n      }).sort(d3.ascending);\n      return rescale();\n    };\n\n    scale.range = function (x) {\n      if (!arguments.length) return range;\n      range = x;\n      return rescale();\n    };\n\n    scale.quantiles = function () {\n      return thresholds;\n    };\n\n    scale.copy = function () {\n      return d3_scale_quantile(domain, range);\n    };\n\n    return rescale();\n  }\n\n  d3.scale.quantize = function () {\n    return d3_scale_quantize(0, 1, [0, 1]);\n  };\n\n  function d3_scale_quantize(x0, x1, range) {\n    var kx, i;\n\n    function scale(x) {\n      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];\n    }\n\n    function rescale() {\n      kx = range.length / (x1 - x0);\n      i = range.length - 1;\n      return scale;\n    }\n\n    scale.domain = function (x) {\n      if (!arguments.length) return [x0, x1];\n      x0 = +x[0];\n      x1 = +x[x.length - 1];\n      return rescale();\n    };\n\n    scale.range = function (x) {\n      if (!arguments.length) return range;\n      range = x;\n      return rescale();\n    };\n\n    scale.copy = function () {\n      return d3_scale_quantize(x0, x1, range);\n    };\n\n    return rescale();\n  }\n\n  d3.scale.threshold = function () {\n    return d3_scale_threshold([.5], [0, 1]);\n  };\n\n  function d3_scale_threshold(domain, range) {\n    function scale(x) {\n      return range[d3.bisect(domain, x)];\n    }\n\n    scale.domain = function (_) {\n      if (!arguments.length) return domain;\n      domain = _;\n      return scale;\n    };\n\n    scale.range = function (_) {\n      if (!arguments.length) return range;\n      range = _;\n      return scale;\n    };\n\n    scale.copy = function () {\n      return d3_scale_threshold(domain, range);\n    };\n\n    return scale;\n  }\n\n  d3.scale.identity = function () {\n    return d3_scale_identity([0, 1]);\n  };\n\n  function d3_scale_identity(domain) {\n    function identity(x) {\n      return +x;\n    }\n\n    identity.invert = identity;\n\n    identity.domain = identity.range = function (x) {\n      if (!arguments.length) return domain;\n      domain = x.map(identity);\n      return identity;\n    };\n\n    identity.ticks = function (m) {\n      return d3_scale_linearTicks(domain, m);\n    };\n\n    identity.tickFormat = function (m) {\n      return d3_scale_linearTickFormat(domain, m);\n    };\n\n    identity.copy = function () {\n      return d3_scale_identity(domain);\n    };\n\n    return identity;\n  }\n\n  d3.svg = {};\n\n  d3.svg.arc = function () {\n    var innerRadius = d3_svg_arcInnerRadius,\n        outerRadius = d3_svg_arcOuterRadius,\n        startAngle = d3_svg_arcStartAngle,\n        endAngle = d3_svg_arcEndAngle;\n\n    function arc() {\n      var r0 = innerRadius.apply(this, arguments),\n          r1 = outerRadius.apply(this, arguments),\n          a0 = startAngle.apply(this, arguments) + d3_svg_arcOffset,\n          a1 = endAngle.apply(this, arguments) + d3_svg_arcOffset,\n          da = (a1 < a0 && (da = a0, a0 = a1, a1 = da), a1 - a0),\n          df = da < π ? \"0\" : \"1\",\n          c0 = Math.cos(a0),\n          s0 = Math.sin(a0),\n          c1 = Math.cos(a1),\n          s1 = Math.sin(a1);\n      return da >= d3_svg_arcMax ? r0 ? \"M0,\" + r1 + \"A\" + r1 + \",\" + r1 + \" 0 1,1 0,\" + -r1 + \"A\" + r1 + \",\" + r1 + \" 0 1,1 0,\" + r1 + \"M0,\" + r0 + \"A\" + r0 + \",\" + r0 + \" 0 1,0 0,\" + -r0 + \"A\" + r0 + \",\" + r0 + \" 0 1,0 0,\" + r0 + \"Z\" : \"M0,\" + r1 + \"A\" + r1 + \",\" + r1 + \" 0 1,1 0,\" + -r1 + \"A\" + r1 + \",\" + r1 + \" 0 1,1 0,\" + r1 + \"Z\" : r0 ? \"M\" + r1 * c0 + \",\" + r1 * s0 + \"A\" + r1 + \",\" + r1 + \" 0 \" + df + \",1 \" + r1 * c1 + \",\" + r1 * s1 + \"L\" + r0 * c1 + \",\" + r0 * s1 + \"A\" + r0 + \",\" + r0 + \" 0 \" + df + \",0 \" + r0 * c0 + \",\" + r0 * s0 + \"Z\" : \"M\" + r1 * c0 + \",\" + r1 * s0 + \"A\" + r1 + \",\" + r1 + \" 0 \" + df + \",1 \" + r1 * c1 + \",\" + r1 * s1 + \"L0,0\" + \"Z\";\n    }\n\n    arc.innerRadius = function (v) {\n      if (!arguments.length) return innerRadius;\n      innerRadius = d3_functor(v);\n      return arc;\n    };\n\n    arc.outerRadius = function (v) {\n      if (!arguments.length) return outerRadius;\n      outerRadius = d3_functor(v);\n      return arc;\n    };\n\n    arc.startAngle = function (v) {\n      if (!arguments.length) return startAngle;\n      startAngle = d3_functor(v);\n      return arc;\n    };\n\n    arc.endAngle = function (v) {\n      if (!arguments.length) return endAngle;\n      endAngle = d3_functor(v);\n      return arc;\n    };\n\n    arc.centroid = function () {\n      var r = (innerRadius.apply(this, arguments) + outerRadius.apply(this, arguments)) / 2,\n          a = (startAngle.apply(this, arguments) + endAngle.apply(this, arguments)) / 2 + d3_svg_arcOffset;\n      return [Math.cos(a) * r, Math.sin(a) * r];\n    };\n\n    return arc;\n  };\n\n  var d3_svg_arcOffset = -π / 2,\n      d3_svg_arcMax = 2 * π - 1e-6;\n\n  function d3_svg_arcInnerRadius(d) {\n    return d.innerRadius;\n  }\n\n  function d3_svg_arcOuterRadius(d) {\n    return d.outerRadius;\n  }\n\n  function d3_svg_arcStartAngle(d) {\n    return d.startAngle;\n  }\n\n  function d3_svg_arcEndAngle(d) {\n    return d.endAngle;\n  }\n\n  function d3_svg_line(projection) {\n    var x = d3_svg_lineX,\n        y = d3_svg_lineY,\n        defined = d3_true,\n        interpolate = d3_svg_lineLinear,\n        interpolateKey = interpolate.key,\n        tension = .7;\n\n    function line(data) {\n      var segments = [],\n          points = [],\n          i = -1,\n          n = data.length,\n          d,\n          fx = d3_functor(x),\n          fy = d3_functor(y);\n\n      function segment() {\n        segments.push(\"M\", interpolate(projection(points), tension));\n      }\n\n      while (++i < n) {\n        if (defined.call(this, d = data[i], i)) {\n          points.push([+fx.call(this, d, i), +fy.call(this, d, i)]);\n        } else if (points.length) {\n          segment();\n          points = [];\n        }\n      }\n\n      if (points.length) segment();\n      return segments.length ? segments.join(\"\") : null;\n    }\n\n    line.x = function (_) {\n      if (!arguments.length) return x;\n      x = _;\n      return line;\n    };\n\n    line.y = function (_) {\n      if (!arguments.length) return y;\n      y = _;\n      return line;\n    };\n\n    line.defined = function (_) {\n      if (!arguments.length) return defined;\n      defined = _;\n      return line;\n    };\n\n    line.interpolate = function (_) {\n      if (!arguments.length) return interpolateKey;\n      if (typeof _ === \"function\") interpolateKey = interpolate = _;else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;\n      return line;\n    };\n\n    line.tension = function (_) {\n      if (!arguments.length) return tension;\n      tension = _;\n      return line;\n    };\n\n    return line;\n  }\n\n  d3.svg.line = function () {\n    return d3_svg_line(d3_identity);\n  };\n\n  function d3_svg_lineX(d) {\n    return d[0];\n  }\n\n  function d3_svg_lineY(d) {\n    return d[1];\n  }\n\n  var d3_svg_lineInterpolators = d3.map({\n    linear: d3_svg_lineLinear,\n    \"linear-closed\": d3_svg_lineLinearClosed,\n    \"step-before\": d3_svg_lineStepBefore,\n    \"step-after\": d3_svg_lineStepAfter,\n    basis: d3_svg_lineBasis,\n    \"basis-open\": d3_svg_lineBasisOpen,\n    \"basis-closed\": d3_svg_lineBasisClosed,\n    bundle: d3_svg_lineBundle,\n    cardinal: d3_svg_lineCardinal,\n    \"cardinal-open\": d3_svg_lineCardinalOpen,\n    \"cardinal-closed\": d3_svg_lineCardinalClosed,\n    monotone: d3_svg_lineMonotone\n  });\n  d3_svg_lineInterpolators.forEach(function (key, value) {\n    value.key = key;\n    value.closed = /-closed$/.test(key);\n  });\n\n  function d3_svg_lineLinear(points) {\n    return points.join(\"L\");\n  }\n\n  function d3_svg_lineLinearClosed(points) {\n    return d3_svg_lineLinear(points) + \"Z\";\n  }\n\n  function d3_svg_lineStepBefore(points) {\n    var i = 0,\n        n = points.length,\n        p = points[0],\n        path = [p[0], \",\", p[1]];\n\n    while (++i < n) path.push(\"V\", (p = points[i])[1], \"H\", p[0]);\n\n    return path.join(\"\");\n  }\n\n  function d3_svg_lineStepAfter(points) {\n    var i = 0,\n        n = points.length,\n        p = points[0],\n        path = [p[0], \",\", p[1]];\n\n    while (++i < n) path.push(\"H\", (p = points[i])[0], \"V\", p[1]);\n\n    return path.join(\"\");\n  }\n\n  function d3_svg_lineCardinalOpen(points, tension) {\n    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, points.length - 1), d3_svg_lineCardinalTangents(points, tension));\n  }\n\n  function d3_svg_lineCardinalClosed(points, tension) {\n    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), points), d3_svg_lineCardinalTangents([points[points.length - 2]].concat(points, [points[1]]), tension));\n  }\n\n  function d3_svg_lineCardinal(points, tension) {\n    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));\n  }\n\n  function d3_svg_lineHermite(points, tangents) {\n    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {\n      return d3_svg_lineLinear(points);\n    }\n\n    var quad = points.length != tangents.length,\n        path = \"\",\n        p0 = points[0],\n        p = points[1],\n        t0 = tangents[0],\n        t = t0,\n        pi = 1;\n\n    if (quad) {\n      path += \"Q\" + (p[0] - t0[0] * 2 / 3) + \",\" + (p[1] - t0[1] * 2 / 3) + \",\" + p[0] + \",\" + p[1];\n      p0 = points[1];\n      pi = 2;\n    }\n\n    if (tangents.length > 1) {\n      t = tangents[1];\n      p = points[pi];\n      pi++;\n      path += \"C\" + (p0[0] + t0[0]) + \",\" + (p0[1] + t0[1]) + \",\" + (p[0] - t[0]) + \",\" + (p[1] - t[1]) + \",\" + p[0] + \",\" + p[1];\n\n      for (var i = 2; i < tangents.length; i++, pi++) {\n        p = points[pi];\n        t = tangents[i];\n        path += \"S\" + (p[0] - t[0]) + \",\" + (p[1] - t[1]) + \",\" + p[0] + \",\" + p[1];\n      }\n    }\n\n    if (quad) {\n      var lp = points[pi];\n      path += \"Q\" + (p[0] + t[0] * 2 / 3) + \",\" + (p[1] + t[1] * 2 / 3) + \",\" + lp[0] + \",\" + lp[1];\n    }\n\n    return path;\n  }\n\n  function d3_svg_lineCardinalTangents(points, tension) {\n    var tangents = [],\n        a = (1 - tension) / 2,\n        p0,\n        p1 = points[0],\n        p2 = points[1],\n        i = 1,\n        n = points.length;\n\n    while (++i < n) {\n      p0 = p1;\n      p1 = p2;\n      p2 = points[i];\n      tangents.push([a * (p2[0] - p0[0]), a * (p2[1] - p0[1])]);\n    }\n\n    return tangents;\n  }\n\n  function d3_svg_lineBasis(points) {\n    if (points.length < 3) return d3_svg_lineLinear(points);\n    var i = 1,\n        n = points.length,\n        pi = points[0],\n        x0 = pi[0],\n        y0 = pi[1],\n        px = [x0, x0, x0, (pi = points[1])[0]],\n        py = [y0, y0, y0, pi[1]],\n        path = [x0, \",\", y0];\n    d3_svg_lineBasisBezier(path, px, py);\n\n    while (++i < n) {\n      pi = points[i];\n      px.shift();\n      px.push(pi[0]);\n      py.shift();\n      py.push(pi[1]);\n      d3_svg_lineBasisBezier(path, px, py);\n    }\n\n    i = -1;\n\n    while (++i < 2) {\n      px.shift();\n      px.push(pi[0]);\n      py.shift();\n      py.push(pi[1]);\n      d3_svg_lineBasisBezier(path, px, py);\n    }\n\n    return path.join(\"\");\n  }\n\n  function d3_svg_lineBasisOpen(points) {\n    if (points.length < 4) return d3_svg_lineLinear(points);\n    var path = [],\n        i = -1,\n        n = points.length,\n        pi,\n        px = [0],\n        py = [0];\n\n    while (++i < 3) {\n      pi = points[i];\n      px.push(pi[0]);\n      py.push(pi[1]);\n    }\n\n    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + \",\" + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));\n    --i;\n\n    while (++i < n) {\n      pi = points[i];\n      px.shift();\n      px.push(pi[0]);\n      py.shift();\n      py.push(pi[1]);\n      d3_svg_lineBasisBezier(path, px, py);\n    }\n\n    return path.join(\"\");\n  }\n\n  function d3_svg_lineBasisClosed(points) {\n    var path,\n        i = -1,\n        n = points.length,\n        m = n + 4,\n        pi,\n        px = [],\n        py = [];\n\n    while (++i < 4) {\n      pi = points[i % n];\n      px.push(pi[0]);\n      py.push(pi[1]);\n    }\n\n    path = [d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)];\n    --i;\n\n    while (++i < m) {\n      pi = points[i % n];\n      px.shift();\n      px.push(pi[0]);\n      py.shift();\n      py.push(pi[1]);\n      d3_svg_lineBasisBezier(path, px, py);\n    }\n\n    return path.join(\"\");\n  }\n\n  function d3_svg_lineBundle(points, tension) {\n    var n = points.length - 1;\n\n    if (n) {\n      var x0 = points[0][0],\n          y0 = points[0][1],\n          dx = points[n][0] - x0,\n          dy = points[n][1] - y0,\n          i = -1,\n          p,\n          t;\n\n      while (++i <= n) {\n        p = points[i];\n        t = i / n;\n        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);\n        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);\n      }\n    }\n\n    return d3_svg_lineBasis(points);\n  }\n\n  function d3_svg_lineDot4(a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n  }\n\n  var d3_svg_lineBasisBezier1 = [0, 2 / 3, 1 / 3, 0],\n      d3_svg_lineBasisBezier2 = [0, 1 / 3, 2 / 3, 0],\n      d3_svg_lineBasisBezier3 = [0, 1 / 6, 2 / 3, 1 / 6];\n\n  function d3_svg_lineBasisBezier(path, x, y) {\n    path.push(\"C\", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), \",\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));\n  }\n\n  function d3_svg_lineSlope(p0, p1) {\n    return (p1[1] - p0[1]) / (p1[0] - p0[0]);\n  }\n\n  function d3_svg_lineFiniteDifferences(points) {\n    var i = 0,\n        j = points.length - 1,\n        m = [],\n        p0 = points[0],\n        p1 = points[1],\n        d = m[0] = d3_svg_lineSlope(p0, p1);\n\n    while (++i < j) {\n      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;\n    }\n\n    m[i] = d;\n    return m;\n  }\n\n  function d3_svg_lineMonotoneTangents(points) {\n    var tangents = [],\n        d,\n        a,\n        b,\n        s,\n        m = d3_svg_lineFiniteDifferences(points),\n        i = -1,\n        j = points.length - 1;\n\n    while (++i < j) {\n      d = d3_svg_lineSlope(points[i], points[i + 1]);\n\n      if (Math.abs(d) < 1e-6) {\n        m[i] = m[i + 1] = 0;\n      } else {\n        a = m[i] / d;\n        b = m[i + 1] / d;\n        s = a * a + b * b;\n\n        if (s > 9) {\n          s = d * 3 / Math.sqrt(s);\n          m[i] = s * a;\n          m[i + 1] = s * b;\n        }\n      }\n    }\n\n    i = -1;\n\n    while (++i <= j) {\n      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));\n      tangents.push([s || 0, m[i] * s || 0]);\n    }\n\n    return tangents;\n  }\n\n  function d3_svg_lineMonotone(points) {\n    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));\n  }\n\n  d3.svg.line.radial = function () {\n    var line = d3_svg_line(d3_svg_lineRadial);\n    line.radius = line.x, delete line.x;\n    line.angle = line.y, delete line.y;\n    return line;\n  };\n\n  function d3_svg_lineRadial(points) {\n    var point,\n        i = -1,\n        n = points.length,\n        r,\n        a;\n\n    while (++i < n) {\n      point = points[i];\n      r = point[0];\n      a = point[1] + d3_svg_arcOffset;\n      point[0] = r * Math.cos(a);\n      point[1] = r * Math.sin(a);\n    }\n\n    return points;\n  }\n\n  function d3_svg_area(projection) {\n    var x0 = d3_svg_lineX,\n        x1 = d3_svg_lineX,\n        y0 = 0,\n        y1 = d3_svg_lineY,\n        defined = d3_true,\n        interpolate = d3_svg_lineLinear,\n        interpolateKey = interpolate.key,\n        interpolateReverse = interpolate,\n        L = \"L\",\n        tension = .7;\n\n    function area(data) {\n      var segments = [],\n          points0 = [],\n          points1 = [],\n          i = -1,\n          n = data.length,\n          d,\n          fx0 = d3_functor(x0),\n          fy0 = d3_functor(y0),\n          fx1 = x0 === x1 ? function () {\n        return x;\n      } : d3_functor(x1),\n          fy1 = y0 === y1 ? function () {\n        return y;\n      } : d3_functor(y1),\n          x,\n          y;\n\n      function segment() {\n        segments.push(\"M\", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), \"Z\");\n      }\n\n      while (++i < n) {\n        if (defined.call(this, d = data[i], i)) {\n          points0.push([x = +fx0.call(this, d, i), y = +fy0.call(this, d, i)]);\n          points1.push([+fx1.call(this, d, i), +fy1.call(this, d, i)]);\n        } else if (points0.length) {\n          segment();\n          points0 = [];\n          points1 = [];\n        }\n      }\n\n      if (points0.length) segment();\n      return segments.length ? segments.join(\"\") : null;\n    }\n\n    area.x = function (_) {\n      if (!arguments.length) return x1;\n      x0 = x1 = _;\n      return area;\n    };\n\n    area.x0 = function (_) {\n      if (!arguments.length) return x0;\n      x0 = _;\n      return area;\n    };\n\n    area.x1 = function (_) {\n      if (!arguments.length) return x1;\n      x1 = _;\n      return area;\n    };\n\n    area.y = function (_) {\n      if (!arguments.length) return y1;\n      y0 = y1 = _;\n      return area;\n    };\n\n    area.y0 = function (_) {\n      if (!arguments.length) return y0;\n      y0 = _;\n      return area;\n    };\n\n    area.y1 = function (_) {\n      if (!arguments.length) return y1;\n      y1 = _;\n      return area;\n    };\n\n    area.defined = function (_) {\n      if (!arguments.length) return defined;\n      defined = _;\n      return area;\n    };\n\n    area.interpolate = function (_) {\n      if (!arguments.length) return interpolateKey;\n      if (typeof _ === \"function\") interpolateKey = interpolate = _;else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;\n      interpolateReverse = interpolate.reverse || interpolate;\n      L = interpolate.closed ? \"M\" : \"L\";\n      return area;\n    };\n\n    area.tension = function (_) {\n      if (!arguments.length) return tension;\n      tension = _;\n      return area;\n    };\n\n    return area;\n  }\n\n  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;\n  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;\n\n  d3.svg.area = function () {\n    return d3_svg_area(d3_identity);\n  };\n\n  d3.svg.area.radial = function () {\n    var area = d3_svg_area(d3_svg_lineRadial);\n    area.radius = area.x, delete area.x;\n    area.innerRadius = area.x0, delete area.x0;\n    area.outerRadius = area.x1, delete area.x1;\n    area.angle = area.y, delete area.y;\n    area.startAngle = area.y0, delete area.y0;\n    area.endAngle = area.y1, delete area.y1;\n    return area;\n  };\n\n  d3.svg.chord = function () {\n    var source = d3_source,\n        target = d3_target,\n        radius = d3_svg_chordRadius,\n        startAngle = d3_svg_arcStartAngle,\n        endAngle = d3_svg_arcEndAngle;\n\n    function chord(d, i) {\n      var s = subgroup(this, source, d, i),\n          t = subgroup(this, target, d, i);\n      return \"M\" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + \"Z\";\n    }\n\n    function subgroup(self, f, d, i) {\n      var subgroup = f.call(self, d, i),\n          r = radius.call(self, subgroup, i),\n          a0 = startAngle.call(self, subgroup, i) + d3_svg_arcOffset,\n          a1 = endAngle.call(self, subgroup, i) + d3_svg_arcOffset;\n      return {\n        r: r,\n        a0: a0,\n        a1: a1,\n        p0: [r * Math.cos(a0), r * Math.sin(a0)],\n        p1: [r * Math.cos(a1), r * Math.sin(a1)]\n      };\n    }\n\n    function equals(a, b) {\n      return a.a0 == b.a0 && a.a1 == b.a1;\n    }\n\n    function arc(r, p, a) {\n      return \"A\" + r + \",\" + r + \" 0 \" + +(a > π) + \",1 \" + p;\n    }\n\n    function curve(r0, p0, r1, p1) {\n      return \"Q 0,0 \" + p1;\n    }\n\n    chord.radius = function (v) {\n      if (!arguments.length) return radius;\n      radius = d3_functor(v);\n      return chord;\n    };\n\n    chord.source = function (v) {\n      if (!arguments.length) return source;\n      source = d3_functor(v);\n      return chord;\n    };\n\n    chord.target = function (v) {\n      if (!arguments.length) return target;\n      target = d3_functor(v);\n      return chord;\n    };\n\n    chord.startAngle = function (v) {\n      if (!arguments.length) return startAngle;\n      startAngle = d3_functor(v);\n      return chord;\n    };\n\n    chord.endAngle = function (v) {\n      if (!arguments.length) return endAngle;\n      endAngle = d3_functor(v);\n      return chord;\n    };\n\n    return chord;\n  };\n\n  function d3_svg_chordRadius(d) {\n    return d.radius;\n  }\n\n  d3.svg.diagonal = function () {\n    var source = d3_source,\n        target = d3_target,\n        projection = d3_svg_diagonalProjection;\n\n    function diagonal(d, i) {\n      var p0 = source.call(this, d, i),\n          p3 = target.call(this, d, i),\n          m = (p0.y + p3.y) / 2,\n          p = [p0, {\n        x: p0.x,\n        y: m\n      }, {\n        x: p3.x,\n        y: m\n      }, p3];\n      p = p.map(projection);\n      return \"M\" + p[0] + \"C\" + p[1] + \" \" + p[2] + \" \" + p[3];\n    }\n\n    diagonal.source = function (x) {\n      if (!arguments.length) return source;\n      source = d3_functor(x);\n      return diagonal;\n    };\n\n    diagonal.target = function (x) {\n      if (!arguments.length) return target;\n      target = d3_functor(x);\n      return diagonal;\n    };\n\n    diagonal.projection = function (x) {\n      if (!arguments.length) return projection;\n      projection = x;\n      return diagonal;\n    };\n\n    return diagonal;\n  };\n\n  function d3_svg_diagonalProjection(d) {\n    return [d.x, d.y];\n  }\n\n  d3.svg.diagonal.radial = function () {\n    var diagonal = d3.svg.diagonal(),\n        projection = d3_svg_diagonalProjection,\n        projection_ = diagonal.projection;\n\n    diagonal.projection = function (x) {\n      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;\n    };\n\n    return diagonal;\n  };\n\n  function d3_svg_diagonalRadialProjection(projection) {\n    return function () {\n      var d = projection.apply(this, arguments),\n          r = d[0],\n          a = d[1] + d3_svg_arcOffset;\n      return [r * Math.cos(a), r * Math.sin(a)];\n    };\n  }\n\n  d3.svg.symbol = function () {\n    var type = d3_svg_symbolType,\n        size = d3_svg_symbolSize;\n\n    function symbol(d, i) {\n      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));\n    }\n\n    symbol.type = function (x) {\n      if (!arguments.length) return type;\n      type = d3_functor(x);\n      return symbol;\n    };\n\n    symbol.size = function (x) {\n      if (!arguments.length) return size;\n      size = d3_functor(x);\n      return symbol;\n    };\n\n    return symbol;\n  };\n\n  function d3_svg_symbolSize() {\n    return 64;\n  }\n\n  function d3_svg_symbolType() {\n    return \"circle\";\n  }\n\n  function d3_svg_symbolCircle(size) {\n    var r = Math.sqrt(size / π);\n    return \"M0,\" + r + \"A\" + r + \",\" + r + \" 0 1,1 0,\" + -r + \"A\" + r + \",\" + r + \" 0 1,1 0,\" + r + \"Z\";\n  }\n\n  var d3_svg_symbols = d3.map({\n    circle: d3_svg_symbolCircle,\n    cross: function (size) {\n      var r = Math.sqrt(size / 5) / 2;\n      return \"M\" + -3 * r + \",\" + -r + \"H\" + -r + \"V\" + -3 * r + \"H\" + r + \"V\" + -r + \"H\" + 3 * r + \"V\" + r + \"H\" + r + \"V\" + 3 * r + \"H\" + -r + \"V\" + r + \"H\" + -3 * r + \"Z\";\n    },\n    diamond: function (size) {\n      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)),\n          rx = ry * d3_svg_symbolTan30;\n      return \"M0,\" + -ry + \"L\" + rx + \",0\" + \" 0,\" + ry + \" \" + -rx + \",0\" + \"Z\";\n    },\n    square: function (size) {\n      var r = Math.sqrt(size) / 2;\n      return \"M\" + -r + \",\" + -r + \"L\" + r + \",\" + -r + \" \" + r + \",\" + r + \" \" + -r + \",\" + r + \"Z\";\n    },\n    \"triangle-down\": function (size) {\n      var rx = Math.sqrt(size / d3_svg_symbolSqrt3),\n          ry = rx * d3_svg_symbolSqrt3 / 2;\n      return \"M0,\" + ry + \"L\" + rx + \",\" + -ry + \" \" + -rx + \",\" + -ry + \"Z\";\n    },\n    \"triangle-up\": function (size) {\n      var rx = Math.sqrt(size / d3_svg_symbolSqrt3),\n          ry = rx * d3_svg_symbolSqrt3 / 2;\n      return \"M0,\" + -ry + \"L\" + rx + \",\" + ry + \" \" + -rx + \",\" + ry + \"Z\";\n    }\n  });\n  d3.svg.symbolTypes = d3_svg_symbols.keys();\n  var d3_svg_symbolSqrt3 = Math.sqrt(3),\n      d3_svg_symbolTan30 = Math.tan(30 * d3_radians);\n\n  d3.svg.axis = function () {\n    var scale = d3.scale.linear(),\n        orient = \"bottom\",\n        tickMajorSize = 6,\n        tickMinorSize = 6,\n        tickEndSize = 6,\n        tickPadding = 3,\n        tickArguments_ = [10],\n        tickValues = null,\n        tickFormat_,\n        tickSubdivide = 0;\n\n    function axis(g) {\n      g.each(function () {\n        var g = d3.select(this);\n        var ticks = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments_) : scale.domain() : tickValues,\n            tickFormat = tickFormat_ == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments_) : String : tickFormat_;\n        var subticks = d3_svg_axisSubdivide(scale, ticks, tickSubdivide),\n            subtick = g.selectAll(\".minor\").data(subticks, String),\n            subtickEnter = subtick.enter().insert(\"line\", \"g\").attr(\"class\", \"tick minor\").style(\"opacity\", 1e-6),\n            subtickExit = d3.transition(subtick.exit()).style(\"opacity\", 1e-6).remove(),\n            subtickUpdate = d3.transition(subtick).style(\"opacity\", 1);\n        var tick = g.selectAll(\"g\").data(ticks, String),\n            tickEnter = tick.enter().insert(\"g\", \"path\").style(\"opacity\", 1e-6),\n            tickExit = d3.transition(tick.exit()).style(\"opacity\", 1e-6).remove(),\n            tickUpdate = d3.transition(tick).style(\"opacity\", 1),\n            tickTransform;\n        var range = d3_scaleRange(scale),\n            path = g.selectAll(\".domain\").data([0]),\n            pathUpdate = d3.transition(path);\n        var scale1 = scale.copy(),\n            scale0 = this.__chart__ || scale1;\n        this.__chart__ = scale1;\n        path.enter().append(\"path\").attr(\"class\", \"domain\");\n        tickEnter.append(\"line\").attr(\"class\", \"tick\");\n        tickEnter.append(\"text\");\n        var lineEnter = tickEnter.select(\"line\"),\n            lineUpdate = tickUpdate.select(\"line\"),\n            text = tick.select(\"text\").text(tickFormat),\n            textEnter = tickEnter.select(\"text\"),\n            textUpdate = tickUpdate.select(\"text\");\n\n        switch (orient) {\n          case \"bottom\":\n            {\n              tickTransform = d3_svg_axisX;\n              subtickEnter.attr(\"y2\", tickMinorSize);\n              subtickUpdate.attr(\"x2\", 0).attr(\"y2\", tickMinorSize);\n              lineEnter.attr(\"y2\", tickMajorSize);\n              textEnter.attr(\"y\", Math.max(tickMajorSize, 0) + tickPadding);\n              lineUpdate.attr(\"x2\", 0).attr(\"y2\", tickMajorSize);\n              textUpdate.attr(\"x\", 0).attr(\"y\", Math.max(tickMajorSize, 0) + tickPadding);\n              text.attr(\"dy\", \".71em\").style(\"text-anchor\", \"middle\");\n              pathUpdate.attr(\"d\", \"M\" + range[0] + \",\" + tickEndSize + \"V0H\" + range[1] + \"V\" + tickEndSize);\n              break;\n            }\n\n          case \"top\":\n            {\n              tickTransform = d3_svg_axisX;\n              subtickEnter.attr(\"y2\", -tickMinorSize);\n              subtickUpdate.attr(\"x2\", 0).attr(\"y2\", -tickMinorSize);\n              lineEnter.attr(\"y2\", -tickMajorSize);\n              textEnter.attr(\"y\", -(Math.max(tickMajorSize, 0) + tickPadding));\n              lineUpdate.attr(\"x2\", 0).attr(\"y2\", -tickMajorSize);\n              textUpdate.attr(\"x\", 0).attr(\"y\", -(Math.max(tickMajorSize, 0) + tickPadding));\n              text.attr(\"dy\", \"0em\").style(\"text-anchor\", \"middle\");\n              pathUpdate.attr(\"d\", \"M\" + range[0] + \",\" + -tickEndSize + \"V0H\" + range[1] + \"V\" + -tickEndSize);\n              break;\n            }\n\n          case \"left\":\n            {\n              tickTransform = d3_svg_axisY;\n              subtickEnter.attr(\"x2\", -tickMinorSize);\n              subtickUpdate.attr(\"x2\", -tickMinorSize).attr(\"y2\", 0);\n              lineEnter.attr(\"x2\", -tickMajorSize);\n              textEnter.attr(\"x\", -(Math.max(tickMajorSize, 0) + tickPadding));\n              lineUpdate.attr(\"x2\", -tickMajorSize).attr(\"y2\", 0);\n              textUpdate.attr(\"x\", -(Math.max(tickMajorSize, 0) + tickPadding)).attr(\"y\", 0);\n              text.attr(\"dy\", \".32em\").style(\"text-anchor\", \"end\");\n              pathUpdate.attr(\"d\", \"M\" + -tickEndSize + \",\" + range[0] + \"H0V\" + range[1] + \"H\" + -tickEndSize);\n              break;\n            }\n\n          case \"right\":\n            {\n              tickTransform = d3_svg_axisY;\n              subtickEnter.attr(\"x2\", tickMinorSize);\n              subtickUpdate.attr(\"x2\", tickMinorSize).attr(\"y2\", 0);\n              lineEnter.attr(\"x2\", tickMajorSize);\n              textEnter.attr(\"x\", Math.max(tickMajorSize, 0) + tickPadding);\n              lineUpdate.attr(\"x2\", tickMajorSize).attr(\"y2\", 0);\n              textUpdate.attr(\"x\", Math.max(tickMajorSize, 0) + tickPadding).attr(\"y\", 0);\n              text.attr(\"dy\", \".32em\").style(\"text-anchor\", \"start\");\n              pathUpdate.attr(\"d\", \"M\" + tickEndSize + \",\" + range[0] + \"H0V\" + range[1] + \"H\" + tickEndSize);\n              break;\n            }\n        }\n\n        if (scale.ticks) {\n          tickEnter.call(tickTransform, scale0);\n          tickUpdate.call(tickTransform, scale1);\n          tickExit.call(tickTransform, scale1);\n          subtickEnter.call(tickTransform, scale0);\n          subtickUpdate.call(tickTransform, scale1);\n          subtickExit.call(tickTransform, scale1);\n        } else {\n          var dx = scale1.rangeBand() / 2,\n              x = function (d) {\n            return scale1(d) + dx;\n          };\n\n          tickEnter.call(tickTransform, x);\n          tickUpdate.call(tickTransform, x);\n        }\n      });\n    }\n\n    axis.scale = function (x) {\n      if (!arguments.length) return scale;\n      scale = x;\n      return axis;\n    };\n\n    axis.orient = function (x) {\n      if (!arguments.length) return orient;\n      orient = x;\n      return axis;\n    };\n\n    axis.ticks = function () {\n      if (!arguments.length) return tickArguments_;\n      tickArguments_ = arguments;\n      return axis;\n    };\n\n    axis.tickValues = function (x) {\n      if (!arguments.length) return tickValues;\n      tickValues = x;\n      return axis;\n    };\n\n    axis.tickFormat = function (x) {\n      if (!arguments.length) return tickFormat_;\n      tickFormat_ = x;\n      return axis;\n    };\n\n    axis.tickSize = function (x, y) {\n      if (!arguments.length) return tickMajorSize;\n      var n = arguments.length - 1;\n      tickMajorSize = +x;\n      tickMinorSize = n > 1 ? +y : tickMajorSize;\n      tickEndSize = n > 0 ? +arguments[n] : tickMajorSize;\n      return axis;\n    };\n\n    axis.tickPadding = function (x) {\n      if (!arguments.length) return tickPadding;\n      tickPadding = +x;\n      return axis;\n    };\n\n    axis.tickSubdivide = function (x) {\n      if (!arguments.length) return tickSubdivide;\n      tickSubdivide = +x;\n      return axis;\n    };\n\n    return axis;\n  };\n\n  function d3_svg_axisX(selection, x) {\n    selection.attr(\"transform\", function (d) {\n      return \"translate(\" + x(d) + \",0)\";\n    });\n  }\n\n  function d3_svg_axisY(selection, y) {\n    selection.attr(\"transform\", function (d) {\n      return \"translate(0,\" + y(d) + \")\";\n    });\n  }\n\n  function d3_svg_axisSubdivide(scale, ticks, m) {\n    subticks = [];\n\n    if (m && ticks.length > 1) {\n      var extent = d3_scaleExtent(scale.domain()),\n          subticks,\n          i = -1,\n          n = ticks.length,\n          d = (ticks[1] - ticks[0]) / ++m,\n          j,\n          v;\n\n      while (++i < n) {\n        for (j = m; --j > 0;) {\n          if ((v = +ticks[i] - j * d) >= extent[0]) {\n            subticks.push(v);\n          }\n        }\n      }\n\n      for (--i, j = 0; ++j < m && (v = +ticks[i] + j * d) < extent[1];) {\n        subticks.push(v);\n      }\n    }\n\n    return subticks;\n  }\n\n  d3.svg.brush = function () {\n    var event = d3_eventDispatch(brush, \"brushstart\", \"brush\", \"brushend\"),\n        x = null,\n        y = null,\n        resizes = d3_svg_brushResizes[0],\n        extent = [[0, 0], [0, 0]],\n        extentDomain;\n\n    function brush(g) {\n      g.each(function () {\n        var g = d3.select(this),\n            bg = g.selectAll(\".background\").data([0]),\n            fg = g.selectAll(\".extent\").data([0]),\n            tz = g.selectAll(\".resize\").data(resizes, String),\n            e;\n        g.style(\"pointer-events\", \"all\").on(\"mousedown.brush\", brushstart).on(\"touchstart.brush\", brushstart);\n        bg.enter().append(\"rect\").attr(\"class\", \"background\").style(\"visibility\", \"hidden\").style(\"cursor\", \"crosshair\");\n        fg.enter().append(\"rect\").attr(\"class\", \"extent\").style(\"cursor\", \"move\");\n        tz.enter().append(\"g\").attr(\"class\", function (d) {\n          return \"resize \" + d;\n        }).style(\"cursor\", function (d) {\n          return d3_svg_brushCursor[d];\n        }).append(\"rect\").attr(\"x\", function (d) {\n          return /[ew]$/.test(d) ? -3 : null;\n        }).attr(\"y\", function (d) {\n          return /^[ns]/.test(d) ? -3 : null;\n        }).attr(\"width\", 6).attr(\"height\", 6).style(\"visibility\", \"hidden\");\n        tz.style(\"display\", brush.empty() ? \"none\" : null);\n        tz.exit().remove();\n\n        if (x) {\n          e = d3_scaleRange(x);\n          bg.attr(\"x\", e[0]).attr(\"width\", e[1] - e[0]);\n          redrawX(g);\n        }\n\n        if (y) {\n          e = d3_scaleRange(y);\n          bg.attr(\"y\", e[0]).attr(\"height\", e[1] - e[0]);\n          redrawY(g);\n        }\n\n        redraw(g);\n      });\n    }\n\n    function redraw(g) {\n      g.selectAll(\".resize\").attr(\"transform\", function (d) {\n        return \"translate(\" + extent[+/e$/.test(d)][0] + \",\" + extent[+/^s/.test(d)][1] + \")\";\n      });\n    }\n\n    function redrawX(g) {\n      g.select(\".extent\").attr(\"x\", extent[0][0]);\n      g.selectAll(\".extent,.n>rect,.s>rect\").attr(\"width\", extent[1][0] - extent[0][0]);\n    }\n\n    function redrawY(g) {\n      g.select(\".extent\").attr(\"y\", extent[0][1]);\n      g.selectAll(\".extent,.e>rect,.w>rect\").attr(\"height\", extent[1][1] - extent[0][1]);\n    }\n\n    function brushstart() {\n      var target = this,\n          eventTarget = d3.select(d3.event.target),\n          event_ = event.of(target, arguments),\n          g = d3.select(target),\n          resizing = eventTarget.datum(),\n          resizingX = !/^(n|s)$/.test(resizing) && x,\n          resizingY = !/^(e|w)$/.test(resizing) && y,\n          dragging = eventTarget.classed(\"extent\"),\n          center,\n          origin = mouse(),\n          offset;\n      var w = d3.select(window).on(\"mousemove.brush\", brushmove).on(\"mouseup.brush\", brushend).on(\"touchmove.brush\", brushmove).on(\"touchend.brush\", brushend).on(\"keydown.brush\", keydown).on(\"keyup.brush\", keyup);\n\n      if (dragging) {\n        origin[0] = extent[0][0] - origin[0];\n        origin[1] = extent[0][1] - origin[1];\n      } else if (resizing) {\n        var ex = +/w$/.test(resizing),\n            ey = +/^n/.test(resizing);\n        offset = [extent[1 - ex][0] - origin[0], extent[1 - ey][1] - origin[1]];\n        origin[0] = extent[ex][0];\n        origin[1] = extent[ey][1];\n      } else if (d3.event.altKey) center = origin.slice();\n\n      g.style(\"pointer-events\", \"none\").selectAll(\".resize\").style(\"display\", null);\n      d3.select(\"body\").style(\"cursor\", eventTarget.style(\"cursor\"));\n      event_({\n        type: \"brushstart\"\n      });\n      brushmove();\n      d3_eventCancel();\n\n      function mouse() {\n        var touches = d3.event.changedTouches;\n        return touches ? d3.touches(target, touches)[0] : d3.mouse(target);\n      }\n\n      function keydown() {\n        if (d3.event.keyCode == 32) {\n          if (!dragging) {\n            center = null;\n            origin[0] -= extent[1][0];\n            origin[1] -= extent[1][1];\n            dragging = 2;\n          }\n\n          d3_eventCancel();\n        }\n      }\n\n      function keyup() {\n        if (d3.event.keyCode == 32 && dragging == 2) {\n          origin[0] += extent[1][0];\n          origin[1] += extent[1][1];\n          dragging = 0;\n          d3_eventCancel();\n        }\n      }\n\n      function brushmove() {\n        var point = mouse(),\n            moved = false;\n\n        if (offset) {\n          point[0] += offset[0];\n          point[1] += offset[1];\n        }\n\n        if (!dragging) {\n          if (d3.event.altKey) {\n            if (!center) center = [(extent[0][0] + extent[1][0]) / 2, (extent[0][1] + extent[1][1]) / 2];\n            origin[0] = extent[+(point[0] < center[0])][0];\n            origin[1] = extent[+(point[1] < center[1])][1];\n          } else center = null;\n        }\n\n        if (resizingX && move1(point, x, 0)) {\n          redrawX(g);\n          moved = true;\n        }\n\n        if (resizingY && move1(point, y, 1)) {\n          redrawY(g);\n          moved = true;\n        }\n\n        if (moved) {\n          redraw(g);\n          event_({\n            type: \"brush\",\n            mode: dragging ? \"move\" : \"resize\"\n          });\n        }\n      }\n\n      function move1(point, scale, i) {\n        var range = d3_scaleRange(scale),\n            r0 = range[0],\n            r1 = range[1],\n            position = origin[i],\n            size = extent[1][i] - extent[0][i],\n            min,\n            max;\n\n        if (dragging) {\n          r0 -= position;\n          r1 -= size + position;\n        }\n\n        min = Math.max(r0, Math.min(r1, point[i]));\n\n        if (dragging) {\n          max = (min += position) + size;\n        } else {\n          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));\n\n          if (position < min) {\n            max = min;\n            min = position;\n          } else {\n            max = position;\n          }\n        }\n\n        if (extent[0][i] !== min || extent[1][i] !== max) {\n          extentDomain = null;\n          extent[0][i] = min;\n          extent[1][i] = max;\n          return true;\n        }\n      }\n\n      function brushend() {\n        brushmove();\n        g.style(\"pointer-events\", \"all\").selectAll(\".resize\").style(\"display\", brush.empty() ? \"none\" : null);\n        d3.select(\"body\").style(\"cursor\", null);\n        w.on(\"mousemove.brush\", null).on(\"mouseup.brush\", null).on(\"touchmove.brush\", null).on(\"touchend.brush\", null).on(\"keydown.brush\", null).on(\"keyup.brush\", null);\n        event_({\n          type: \"brushend\"\n        });\n        d3_eventCancel();\n      }\n    }\n\n    brush.x = function (z) {\n      if (!arguments.length) return x;\n      x = z;\n      resizes = d3_svg_brushResizes[!x << 1 | !y];\n      return brush;\n    };\n\n    brush.y = function (z) {\n      if (!arguments.length) return y;\n      y = z;\n      resizes = d3_svg_brushResizes[!x << 1 | !y];\n      return brush;\n    };\n\n    brush.extent = function (z) {\n      var x0, x1, y0, y1, t;\n\n      if (!arguments.length) {\n        z = extentDomain || extent;\n\n        if (x) {\n          x0 = z[0][0], x1 = z[1][0];\n\n          if (!extentDomain) {\n            x0 = extent[0][0], x1 = extent[1][0];\n            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);\n            if (x1 < x0) t = x0, x0 = x1, x1 = t;\n          }\n        }\n\n        if (y) {\n          y0 = z[0][1], y1 = z[1][1];\n\n          if (!extentDomain) {\n            y0 = extent[0][1], y1 = extent[1][1];\n            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);\n            if (y1 < y0) t = y0, y0 = y1, y1 = t;\n          }\n        }\n\n        return x && y ? [[x0, y0], [x1, y1]] : x ? [x0, x1] : y && [y0, y1];\n      }\n\n      extentDomain = [[0, 0], [0, 0]];\n\n      if (x) {\n        x0 = z[0], x1 = z[1];\n        if (y) x0 = x0[0], x1 = x1[0];\n        extentDomain[0][0] = x0, extentDomain[1][0] = x1;\n        if (x.invert) x0 = x(x0), x1 = x(x1);\n        if (x1 < x0) t = x0, x0 = x1, x1 = t;\n        extent[0][0] = x0 | 0, extent[1][0] = x1 | 0;\n      }\n\n      if (y) {\n        y0 = z[0], y1 = z[1];\n        if (x) y0 = y0[1], y1 = y1[1];\n        extentDomain[0][1] = y0, extentDomain[1][1] = y1;\n        if (y.invert) y0 = y(y0), y1 = y(y1);\n        if (y1 < y0) t = y0, y0 = y1, y1 = t;\n        extent[0][1] = y0 | 0, extent[1][1] = y1 | 0;\n      }\n\n      return brush;\n    };\n\n    brush.clear = function () {\n      extentDomain = null;\n      extent[0][0] = extent[0][1] = extent[1][0] = extent[1][1] = 0;\n      return brush;\n    };\n\n    brush.empty = function () {\n      return x && extent[0][0] === extent[1][0] || y && extent[0][1] === extent[1][1];\n    };\n\n    return d3.rebind(brush, event, \"on\");\n  };\n\n  var d3_svg_brushCursor = {\n    n: \"ns-resize\",\n    e: \"ew-resize\",\n    s: \"ns-resize\",\n    w: \"ew-resize\",\n    nw: \"nwse-resize\",\n    ne: \"nesw-resize\",\n    se: \"nwse-resize\",\n    sw: \"nesw-resize\"\n  };\n  var d3_svg_brushResizes = [[\"n\", \"e\", \"s\", \"w\", \"nw\", \"ne\", \"se\", \"sw\"], [\"e\", \"w\"], [\"n\", \"s\"], []];\n  d3.behavior = {};\n\n  d3.behavior.drag = function () {\n    var event = d3_eventDispatch(drag, \"drag\", \"dragstart\", \"dragend\"),\n        origin = null;\n\n    function drag() {\n      this.on(\"mousedown.drag\", mousedown).on(\"touchstart.drag\", mousedown);\n    }\n\n    function mousedown() {\n      var target = this,\n          event_ = event.of(target, arguments),\n          eventTarget = d3.event.target,\n          touchId = d3.event.touches ? d3.event.changedTouches[0].identifier : null,\n          offset,\n          origin_ = point(),\n          moved = 0;\n      var w = d3.select(window).on(touchId != null ? \"touchmove.drag-\" + touchId : \"mousemove.drag\", dragmove).on(touchId != null ? \"touchend.drag-\" + touchId : \"mouseup.drag\", dragend, true);\n\n      if (origin) {\n        offset = origin.apply(target, arguments);\n        offset = [offset.x - origin_[0], offset.y - origin_[1]];\n      } else {\n        offset = [0, 0];\n      }\n\n      if (touchId == null) d3_eventCancel();\n      event_({\n        type: \"dragstart\"\n      });\n\n      function point() {\n        var p = target.parentNode;\n        return touchId != null ? d3.touches(p).filter(function (p) {\n          return p.identifier === touchId;\n        })[0] : d3.mouse(p);\n      }\n\n      function dragmove() {\n        if (!target.parentNode) return dragend();\n        var p = point(),\n            dx = p[0] - origin_[0],\n            dy = p[1] - origin_[1];\n        moved |= dx | dy;\n        origin_ = p;\n        d3_eventCancel();\n        event_({\n          type: \"drag\",\n          x: p[0] + offset[0],\n          y: p[1] + offset[1],\n          dx: dx,\n          dy: dy\n        });\n      }\n\n      function dragend() {\n        event_({\n          type: \"dragend\"\n        });\n\n        if (moved) {\n          d3_eventCancel();\n          if (d3.event.target === eventTarget) w.on(\"click.drag\", click, true);\n        }\n\n        w.on(touchId != null ? \"touchmove.drag-\" + touchId : \"mousemove.drag\", null).on(touchId != null ? \"touchend.drag-\" + touchId : \"mouseup.drag\", null);\n      }\n\n      function click() {\n        d3_eventCancel();\n        w.on(\"click.drag\", null);\n      }\n    }\n\n    drag.origin = function (x) {\n      if (!arguments.length) return origin;\n      origin = x;\n      return drag;\n    };\n\n    return d3.rebind(drag, event, \"on\");\n  };\n\n  d3.behavior.zoom = function () {\n    var translate = [0, 0],\n        translate0,\n        scale = 1,\n        scale0,\n        scaleExtent = d3_behavior_zoomInfinity,\n        event = d3_eventDispatch(zoom, \"zoom\"),\n        x0,\n        x1,\n        y0,\n        y1,\n        touchtime;\n\n    function zoom() {\n      this.on(\"mousedown.zoom\", mousedown).on(\"mousewheel.zoom\", mousewheel).on(\"mousemove.zoom\", mousemove).on(\"DOMMouseScroll.zoom\", mousewheel).on(\"dblclick.zoom\", dblclick).on(\"touchstart.zoom\", touchstart).on(\"touchmove.zoom\", touchmove).on(\"touchend.zoom\", touchstart);\n    }\n\n    zoom.translate = function (x) {\n      if (!arguments.length) return translate;\n      translate = x.map(Number);\n      rescale();\n      return zoom;\n    };\n\n    zoom.scale = function (x) {\n      if (!arguments.length) return scale;\n      scale = +x;\n      rescale();\n      return zoom;\n    };\n\n    zoom.scaleExtent = function (x) {\n      if (!arguments.length) return scaleExtent;\n      scaleExtent = x == null ? d3_behavior_zoomInfinity : x.map(Number);\n      return zoom;\n    };\n\n    zoom.x = function (z) {\n      if (!arguments.length) return x1;\n      x1 = z;\n      x0 = z.copy();\n      translate = [0, 0];\n      scale = 1;\n      return zoom;\n    };\n\n    zoom.y = function (z) {\n      if (!arguments.length) return y1;\n      y1 = z;\n      y0 = z.copy();\n      translate = [0, 0];\n      scale = 1;\n      return zoom;\n    };\n\n    function location(p) {\n      return [(p[0] - translate[0]) / scale, (p[1] - translate[1]) / scale];\n    }\n\n    function point(l) {\n      return [l[0] * scale + translate[0], l[1] * scale + translate[1]];\n    }\n\n    function scaleTo(s) {\n      scale = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));\n    }\n\n    function translateTo(p, l) {\n      l = point(l);\n      translate[0] += p[0] - l[0];\n      translate[1] += p[1] - l[1];\n    }\n\n    function rescale() {\n      if (x1) x1.domain(x0.range().map(function (x) {\n        return (x - translate[0]) / scale;\n      }).map(x0.invert));\n      if (y1) y1.domain(y0.range().map(function (y) {\n        return (y - translate[1]) / scale;\n      }).map(y0.invert));\n    }\n\n    function dispatch(event) {\n      rescale();\n      d3.event.preventDefault();\n      event({\n        type: \"zoom\",\n        scale: scale,\n        translate: translate\n      });\n    }\n\n    function mousedown() {\n      var target = this,\n          event_ = event.of(target, arguments),\n          eventTarget = d3.event.target,\n          moved = 0,\n          w = d3.select(window).on(\"mousemove.zoom\", mousemove).on(\"mouseup.zoom\", mouseup),\n          l = location(d3.mouse(target));\n      window.focus();\n      d3_eventCancel();\n\n      function mousemove() {\n        moved = 1;\n        translateTo(d3.mouse(target), l);\n        dispatch(event_);\n      }\n\n      function mouseup() {\n        if (moved) d3_eventCancel();\n        w.on(\"mousemove.zoom\", null).on(\"mouseup.zoom\", null);\n        if (moved && d3.event.target === eventTarget) w.on(\"click.zoom\", click, true);\n      }\n\n      function click() {\n        d3_eventCancel();\n        w.on(\"click.zoom\", null);\n      }\n    }\n\n    function mousewheel() {\n      if (!translate0) translate0 = location(d3.mouse(this));\n      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * scale);\n      translateTo(d3.mouse(this), translate0);\n      dispatch(event.of(this, arguments));\n    }\n\n    function mousemove() {\n      translate0 = null;\n    }\n\n    function dblclick() {\n      var p = d3.mouse(this),\n          l = location(p),\n          k = Math.log(scale) / Math.LN2;\n      scaleTo(Math.pow(2, d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1));\n      translateTo(p, l);\n      dispatch(event.of(this, arguments));\n    }\n\n    function touchstart() {\n      var touches = d3.touches(this),\n          now = Date.now();\n      scale0 = scale;\n      translate0 = {};\n      touches.forEach(function (t) {\n        translate0[t.identifier] = location(t);\n      });\n      d3_eventCancel();\n\n      if (touches.length === 1) {\n        if (now - touchtime < 500) {\n          var p = touches[0],\n              l = location(touches[0]);\n          scaleTo(scale * 2);\n          translateTo(p, l);\n          dispatch(event.of(this, arguments));\n        }\n\n        touchtime = now;\n      }\n    }\n\n    function touchmove() {\n      var touches = d3.touches(this),\n          p0 = touches[0],\n          l0 = translate0[p0.identifier];\n\n      if (p1 = touches[1]) {\n        var p1,\n            l1 = translate0[p1.identifier];\n        p0 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];\n        l0 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];\n        scaleTo(d3.event.scale * scale0);\n      }\n\n      translateTo(p0, l0);\n      touchtime = null;\n      dispatch(event.of(this, arguments));\n    }\n\n    return d3.rebind(zoom, event, \"on\");\n  };\n\n  var d3_behavior_zoomDiv,\n      d3_behavior_zoomInfinity = [0, Infinity];\n\n  function d3_behavior_zoomDelta() {\n    if (!d3_behavior_zoomDiv) {\n      d3_behavior_zoomDiv = d3.select(\"body\").append(\"div\").style(\"visibility\", \"hidden\").style(\"top\", 0).style(\"height\", 0).style(\"width\", 0).style(\"overflow-y\", \"scroll\").append(\"div\").style(\"height\", \"2000px\").node().parentNode;\n    }\n\n    var e = d3.event,\n        delta;\n\n    try {\n      d3_behavior_zoomDiv.scrollTop = 1e3;\n      d3_behavior_zoomDiv.dispatchEvent(e);\n      delta = 1e3 - d3_behavior_zoomDiv.scrollTop;\n    } catch (error) {\n      delta = e.wheelDelta || -e.detail * 5;\n    }\n\n    return delta;\n  }\n\n  d3.layout = {};\n\n  d3.layout.bundle = function () {\n    return function (links) {\n      var paths = [],\n          i = -1,\n          n = links.length;\n\n      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));\n\n      return paths;\n    };\n  };\n\n  function d3_layout_bundlePath(link) {\n    var start = link.source,\n        end = link.target,\n        lca = d3_layout_bundleLeastCommonAncestor(start, end),\n        points = [start];\n\n    while (start !== lca) {\n      start = start.parent;\n      points.push(start);\n    }\n\n    var k = points.length;\n\n    while (end !== lca) {\n      points.splice(k, 0, end);\n      end = end.parent;\n    }\n\n    return points;\n  }\n\n  function d3_layout_bundleAncestors(node) {\n    var ancestors = [],\n        parent = node.parent;\n\n    while (parent != null) {\n      ancestors.push(node);\n      node = parent;\n      parent = parent.parent;\n    }\n\n    ancestors.push(node);\n    return ancestors;\n  }\n\n  function d3_layout_bundleLeastCommonAncestor(a, b) {\n    if (a === b) return a;\n    var aNodes = d3_layout_bundleAncestors(a),\n        bNodes = d3_layout_bundleAncestors(b),\n        aNode = aNodes.pop(),\n        bNode = bNodes.pop(),\n        sharedNode = null;\n\n    while (aNode === bNode) {\n      sharedNode = aNode;\n      aNode = aNodes.pop();\n      bNode = bNodes.pop();\n    }\n\n    return sharedNode;\n  }\n\n  d3.layout.chord = function () {\n    var chord = {},\n        chords,\n        groups,\n        matrix,\n        n,\n        padding = 0,\n        sortGroups,\n        sortSubgroups,\n        sortChords;\n\n    function relayout() {\n      var subgroups = {},\n          groupSums = [],\n          groupIndex = d3.range(n),\n          subgroupIndex = [],\n          k,\n          x,\n          x0,\n          i,\n          j;\n      chords = [];\n      groups = [];\n      k = 0, i = -1;\n\n      while (++i < n) {\n        x = 0, j = -1;\n\n        while (++j < n) {\n          x += matrix[i][j];\n        }\n\n        groupSums.push(x);\n        subgroupIndex.push(d3.range(n));\n        k += x;\n      }\n\n      if (sortGroups) {\n        groupIndex.sort(function (a, b) {\n          return sortGroups(groupSums[a], groupSums[b]);\n        });\n      }\n\n      if (sortSubgroups) {\n        subgroupIndex.forEach(function (d, i) {\n          d.sort(function (a, b) {\n            return sortSubgroups(matrix[i][a], matrix[i][b]);\n          });\n        });\n      }\n\n      k = (2 * π - padding * n) / k;\n      x = 0, i = -1;\n\n      while (++i < n) {\n        x0 = x, j = -1;\n\n        while (++j < n) {\n          var di = groupIndex[i],\n              dj = subgroupIndex[di][j],\n              v = matrix[di][dj],\n              a0 = x,\n              a1 = x += v * k;\n          subgroups[di + \"-\" + dj] = {\n            index: di,\n            subindex: dj,\n            startAngle: a0,\n            endAngle: a1,\n            value: v\n          };\n        }\n\n        groups[di] = {\n          index: di,\n          startAngle: x0,\n          endAngle: x,\n          value: (x - x0) / k\n        };\n        x += padding;\n      }\n\n      i = -1;\n\n      while (++i < n) {\n        j = i - 1;\n\n        while (++j < n) {\n          var source = subgroups[i + \"-\" + j],\n              target = subgroups[j + \"-\" + i];\n\n          if (source.value || target.value) {\n            chords.push(source.value < target.value ? {\n              source: target,\n              target: source\n            } : {\n              source: source,\n              target: target\n            });\n          }\n        }\n      }\n\n      if (sortChords) resort();\n    }\n\n    function resort() {\n      chords.sort(function (a, b) {\n        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);\n      });\n    }\n\n    chord.matrix = function (x) {\n      if (!arguments.length) return matrix;\n      n = (matrix = x) && matrix.length;\n      chords = groups = null;\n      return chord;\n    };\n\n    chord.padding = function (x) {\n      if (!arguments.length) return padding;\n      padding = x;\n      chords = groups = null;\n      return chord;\n    };\n\n    chord.sortGroups = function (x) {\n      if (!arguments.length) return sortGroups;\n      sortGroups = x;\n      chords = groups = null;\n      return chord;\n    };\n\n    chord.sortSubgroups = function (x) {\n      if (!arguments.length) return sortSubgroups;\n      sortSubgroups = x;\n      chords = null;\n      return chord;\n    };\n\n    chord.sortChords = function (x) {\n      if (!arguments.length) return sortChords;\n      sortChords = x;\n      if (chords) resort();\n      return chord;\n    };\n\n    chord.chords = function () {\n      if (!chords) relayout();\n      return chords;\n    };\n\n    chord.groups = function () {\n      if (!groups) relayout();\n      return groups;\n    };\n\n    return chord;\n  };\n\n  d3.layout.force = function () {\n    var force = {},\n        event = d3.dispatch(\"start\", \"tick\", \"end\"),\n        size = [1, 1],\n        drag,\n        alpha,\n        friction = .9,\n        linkDistance = d3_layout_forceLinkDistance,\n        linkStrength = d3_layout_forceLinkStrength,\n        charge = -30,\n        gravity = .1,\n        theta = .8,\n        nodes = [],\n        links = [],\n        distances,\n        strengths,\n        charges;\n\n    function repulse(node) {\n      return function (quad, x1, _, x2) {\n        if (quad.point !== node) {\n          var dx = quad.cx - node.x,\n              dy = quad.cy - node.y,\n              dn = 1 / Math.sqrt(dx * dx + dy * dy);\n\n          if ((x2 - x1) * dn < theta) {\n            var k = quad.charge * dn * dn;\n            node.px -= dx * k;\n            node.py -= dy * k;\n            return true;\n          }\n\n          if (quad.point && isFinite(dn)) {\n            var k = quad.pointCharge * dn * dn;\n            node.px -= dx * k;\n            node.py -= dy * k;\n          }\n        }\n\n        return !quad.charge;\n      };\n    }\n\n    force.tick = function () {\n      if ((alpha *= .99) < .005) {\n        event.end({\n          type: \"end\",\n          alpha: alpha = 0\n        });\n        return true;\n      }\n\n      var n = nodes.length,\n          m = links.length,\n          q,\n          i,\n          o,\n          s,\n          t,\n          l,\n          k,\n          x,\n          y;\n\n      for (i = 0; i < m; ++i) {\n        o = links[i];\n        s = o.source;\n        t = o.target;\n        x = t.x - s.x;\n        y = t.y - s.y;\n\n        if (l = x * x + y * y) {\n          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;\n          x *= l;\n          y *= l;\n          t.x -= x * (k = s.weight / (t.weight + s.weight));\n          t.y -= y * k;\n          s.x += x * (k = 1 - k);\n          s.y += y * k;\n        }\n      }\n\n      if (k = alpha * gravity) {\n        x = size[0] / 2;\n        y = size[1] / 2;\n        i = -1;\n        if (k) while (++i < n) {\n          o = nodes[i];\n          o.x += (x - o.x) * k;\n          o.y += (y - o.y) * k;\n        }\n      }\n\n      if (charge) {\n        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);\n        i = -1;\n\n        while (++i < n) {\n          if (!(o = nodes[i]).fixed) {\n            q.visit(repulse(o));\n          }\n        }\n      }\n\n      i = -1;\n\n      while (++i < n) {\n        o = nodes[i];\n\n        if (o.fixed) {\n          o.x = o.px;\n          o.y = o.py;\n        } else {\n          o.x -= (o.px - (o.px = o.x)) * friction;\n          o.y -= (o.py - (o.py = o.y)) * friction;\n        }\n      }\n\n      event.tick({\n        type: \"tick\",\n        alpha: alpha\n      });\n    };\n\n    force.nodes = function (x) {\n      if (!arguments.length) return nodes;\n      nodes = x;\n      return force;\n    };\n\n    force.links = function (x) {\n      if (!arguments.length) return links;\n      links = x;\n      return force;\n    };\n\n    force.size = function (x) {\n      if (!arguments.length) return size;\n      size = x;\n      return force;\n    };\n\n    force.linkDistance = function (x) {\n      if (!arguments.length) return linkDistance;\n      linkDistance = d3_functor(x);\n      return force;\n    };\n\n    force.distance = force.linkDistance;\n\n    force.linkStrength = function (x) {\n      if (!arguments.length) return linkStrength;\n      linkStrength = d3_functor(x);\n      return force;\n    };\n\n    force.friction = function (x) {\n      if (!arguments.length) return friction;\n      friction = x;\n      return force;\n    };\n\n    force.charge = function (x) {\n      if (!arguments.length) return charge;\n      charge = typeof x === \"function\" ? x : +x;\n      return force;\n    };\n\n    force.gravity = function (x) {\n      if (!arguments.length) return gravity;\n      gravity = x;\n      return force;\n    };\n\n    force.theta = function (x) {\n      if (!arguments.length) return theta;\n      theta = x;\n      return force;\n    };\n\n    force.alpha = function (x) {\n      if (!arguments.length) return alpha;\n\n      if (alpha) {\n        if (x > 0) alpha = x;else alpha = 0;\n      } else if (x > 0) {\n        event.start({\n          type: \"start\",\n          alpha: alpha = x\n        });\n        d3.timer(force.tick);\n      }\n\n      return force;\n    };\n\n    force.start = function () {\n      var i,\n          j,\n          n = nodes.length,\n          m = links.length,\n          w = size[0],\n          h = size[1],\n          neighbors,\n          o;\n\n      for (i = 0; i < n; ++i) {\n        (o = nodes[i]).index = i;\n        o.weight = 0;\n      }\n\n      distances = [];\n      strengths = [];\n\n      for (i = 0; i < m; ++i) {\n        o = links[i];\n        if (typeof o.source == \"number\") o.source = nodes[o.source];\n        if (typeof o.target == \"number\") o.target = nodes[o.target];\n        distances[i] = linkDistance.call(this, o, i);\n        strengths[i] = linkStrength.call(this, o, i);\n        ++o.source.weight;\n        ++o.target.weight;\n      }\n\n      for (i = 0; i < n; ++i) {\n        o = nodes[i];\n        if (isNaN(o.x)) o.x = position(\"x\", w);\n        if (isNaN(o.y)) o.y = position(\"y\", h);\n        if (isNaN(o.px)) o.px = o.x;\n        if (isNaN(o.py)) o.py = o.y;\n      }\n\n      charges = [];\n\n      if (typeof charge === \"function\") {\n        for (i = 0; i < n; ++i) {\n          charges[i] = +charge.call(this, nodes[i], i);\n        }\n      } else {\n        for (i = 0; i < n; ++i) {\n          charges[i] = charge;\n        }\n      }\n\n      function position(dimension, size) {\n        var neighbors = neighbor(i),\n            j = -1,\n            m = neighbors.length,\n            x;\n\n        while (++j < m) if (!isNaN(x = neighbors[j][dimension])) return x;\n\n        return Math.random() * size;\n      }\n\n      function neighbor() {\n        if (!neighbors) {\n          neighbors = [];\n\n          for (j = 0; j < n; ++j) {\n            neighbors[j] = [];\n          }\n\n          for (j = 0; j < m; ++j) {\n            var o = links[j];\n            neighbors[o.source.index].push(o.target);\n            neighbors[o.target.index].push(o.source);\n          }\n        }\n\n        return neighbors[i];\n      }\n\n      return force.resume();\n    };\n\n    force.resume = function () {\n      return force.alpha(.1);\n    };\n\n    force.stop = function () {\n      return force.alpha(0);\n    };\n\n    force.drag = function () {\n      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on(\"dragstart\", d3_layout_forceDragstart).on(\"drag\", dragmove).on(\"dragend\", d3_layout_forceDragend);\n      this.on(\"mouseover.force\", d3_layout_forceMouseover).on(\"mouseout.force\", d3_layout_forceMouseout).call(drag);\n    };\n\n    function dragmove(d) {\n      d.px = d3.event.x, d.py = d3.event.y;\n      force.resume();\n    }\n\n    return d3.rebind(force, event, \"on\");\n  };\n\n  function d3_layout_forceDragstart(d) {\n    d.fixed |= 2;\n  }\n\n  function d3_layout_forceDragend(d) {\n    d.fixed &= 1;\n  }\n\n  function d3_layout_forceMouseover(d) {\n    d.fixed |= 4;\n    d.px = d.x, d.py = d.y;\n  }\n\n  function d3_layout_forceMouseout(d) {\n    d.fixed &= 3;\n  }\n\n  function d3_layout_forceAccumulate(quad, alpha, charges) {\n    var cx = 0,\n        cy = 0;\n    quad.charge = 0;\n\n    if (!quad.leaf) {\n      var nodes = quad.nodes,\n          n = nodes.length,\n          i = -1,\n          c;\n\n      while (++i < n) {\n        c = nodes[i];\n        if (c == null) continue;\n        d3_layout_forceAccumulate(c, alpha, charges);\n        quad.charge += c.charge;\n        cx += c.charge * c.cx;\n        cy += c.charge * c.cy;\n      }\n    }\n\n    if (quad.point) {\n      if (!quad.leaf) {\n        quad.point.x += Math.random() - .5;\n        quad.point.y += Math.random() - .5;\n      }\n\n      var k = alpha * charges[quad.point.index];\n      quad.charge += quad.pointCharge = k;\n      cx += k * quad.point.x;\n      cy += k * quad.point.y;\n    }\n\n    quad.cx = cx / quad.charge;\n    quad.cy = cy / quad.charge;\n  }\n\n  function d3_layout_forceLinkDistance() {\n    return 20;\n  }\n\n  function d3_layout_forceLinkStrength() {\n    return 1;\n  }\n\n  d3.layout.partition = function () {\n    var hierarchy = d3.layout.hierarchy(),\n        size = [1, 1];\n\n    function position(node, x, dx, dy) {\n      var children = node.children;\n      node.x = x;\n      node.y = node.depth * dy;\n      node.dx = dx;\n      node.dy = dy;\n\n      if (children && (n = children.length)) {\n        var i = -1,\n            n,\n            c,\n            d;\n        dx = node.value ? dx / node.value : 0;\n\n        while (++i < n) {\n          position(c = children[i], x, d = c.value * dx, dy);\n          x += d;\n        }\n      }\n    }\n\n    function depth(node) {\n      var children = node.children,\n          d = 0;\n\n      if (children && (n = children.length)) {\n        var i = -1,\n            n;\n\n        while (++i < n) d = Math.max(d, depth(children[i]));\n      }\n\n      return 1 + d;\n    }\n\n    function partition(d, i) {\n      var nodes = hierarchy.call(this, d, i);\n      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));\n      return nodes;\n    }\n\n    partition.size = function (x) {\n      if (!arguments.length) return size;\n      size = x;\n      return partition;\n    };\n\n    return d3_layout_hierarchyRebind(partition, hierarchy);\n  };\n\n  d3.layout.pie = function () {\n    var value = Number,\n        sort = d3_layout_pieSortByValue,\n        startAngle = 0,\n        endAngle = 2 * π;\n\n    function pie(data) {\n      var values = data.map(function (d, i) {\n        return +value.call(pie, d, i);\n      });\n      var a = +(typeof startAngle === \"function\" ? startAngle.apply(this, arguments) : startAngle);\n      var k = ((typeof endAngle === \"function\" ? endAngle.apply(this, arguments) : endAngle) - startAngle) / d3.sum(values);\n      var index = d3.range(data.length);\n      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function (i, j) {\n        return values[j] - values[i];\n      } : function (i, j) {\n        return sort(data[i], data[j]);\n      });\n      var arcs = [];\n      index.forEach(function (i) {\n        var d;\n        arcs[i] = {\n          data: data[i],\n          value: d = values[i],\n          startAngle: a,\n          endAngle: a += d * k\n        };\n      });\n      return arcs;\n    }\n\n    pie.value = function (x) {\n      if (!arguments.length) return value;\n      value = x;\n      return pie;\n    };\n\n    pie.sort = function (x) {\n      if (!arguments.length) return sort;\n      sort = x;\n      return pie;\n    };\n\n    pie.startAngle = function (x) {\n      if (!arguments.length) return startAngle;\n      startAngle = x;\n      return pie;\n    };\n\n    pie.endAngle = function (x) {\n      if (!arguments.length) return endAngle;\n      endAngle = x;\n      return pie;\n    };\n\n    return pie;\n  };\n\n  var d3_layout_pieSortByValue = {};\n\n  d3.layout.stack = function () {\n    var values = d3_identity,\n        order = d3_layout_stackOrderDefault,\n        offset = d3_layout_stackOffsetZero,\n        out = d3_layout_stackOut,\n        x = d3_layout_stackX,\n        y = d3_layout_stackY;\n\n    function stack(data, index) {\n      var series = data.map(function (d, i) {\n        return values.call(stack, d, i);\n      });\n      var points = series.map(function (d) {\n        return d.map(function (v, i) {\n          return [x.call(stack, v, i), y.call(stack, v, i)];\n        });\n      });\n      var orders = order.call(stack, points, index);\n      series = d3.permute(series, orders);\n      points = d3.permute(points, orders);\n      var offsets = offset.call(stack, points, index);\n      var n = series.length,\n          m = series[0].length,\n          i,\n          j,\n          o;\n\n      for (j = 0; j < m; ++j) {\n        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);\n\n        for (i = 1; i < n; ++i) {\n          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);\n        }\n      }\n\n      return data;\n    }\n\n    stack.values = function (x) {\n      if (!arguments.length) return values;\n      values = x;\n      return stack;\n    };\n\n    stack.order = function (x) {\n      if (!arguments.length) return order;\n      order = typeof x === \"function\" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;\n      return stack;\n    };\n\n    stack.offset = function (x) {\n      if (!arguments.length) return offset;\n      offset = typeof x === \"function\" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;\n      return stack;\n    };\n\n    stack.x = function (z) {\n      if (!arguments.length) return x;\n      x = z;\n      return stack;\n    };\n\n    stack.y = function (z) {\n      if (!arguments.length) return y;\n      y = z;\n      return stack;\n    };\n\n    stack.out = function (z) {\n      if (!arguments.length) return out;\n      out = z;\n      return stack;\n    };\n\n    return stack;\n  };\n\n  function d3_layout_stackX(d) {\n    return d.x;\n  }\n\n  function d3_layout_stackY(d) {\n    return d.y;\n  }\n\n  function d3_layout_stackOut(d, y0, y) {\n    d.y0 = y0;\n    d.y = y;\n  }\n\n  var d3_layout_stackOrders = d3.map({\n    \"inside-out\": function (data) {\n      var n = data.length,\n          i,\n          j,\n          max = data.map(d3_layout_stackMaxIndex),\n          sums = data.map(d3_layout_stackReduceSum),\n          index = d3.range(n).sort(function (a, b) {\n        return max[a] - max[b];\n      }),\n          top = 0,\n          bottom = 0,\n          tops = [],\n          bottoms = [];\n\n      for (i = 0; i < n; ++i) {\n        j = index[i];\n\n        if (top < bottom) {\n          top += sums[j];\n          tops.push(j);\n        } else {\n          bottom += sums[j];\n          bottoms.push(j);\n        }\n      }\n\n      return bottoms.reverse().concat(tops);\n    },\n    reverse: function (data) {\n      return d3.range(data.length).reverse();\n    },\n    \"default\": d3_layout_stackOrderDefault\n  });\n  var d3_layout_stackOffsets = d3.map({\n    silhouette: function (data) {\n      var n = data.length,\n          m = data[0].length,\n          sums = [],\n          max = 0,\n          i,\n          j,\n          o,\n          y0 = [];\n\n      for (j = 0; j < m; ++j) {\n        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];\n\n        if (o > max) max = o;\n        sums.push(o);\n      }\n\n      for (j = 0; j < m; ++j) {\n        y0[j] = (max - sums[j]) / 2;\n      }\n\n      return y0;\n    },\n    wiggle: function (data) {\n      var n = data.length,\n          x = data[0],\n          m = x.length,\n          i,\n          j,\n          k,\n          s1,\n          s2,\n          s3,\n          dx,\n          o,\n          o0,\n          y0 = [];\n      y0[0] = o = o0 = 0;\n\n      for (j = 1; j < m; ++j) {\n        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];\n\n        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {\n          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {\n            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;\n          }\n\n          s2 += s3 * data[i][j][1];\n        }\n\n        y0[j] = o -= s1 ? s2 / s1 * dx : 0;\n        if (o < o0) o0 = o;\n      }\n\n      for (j = 0; j < m; ++j) y0[j] -= o0;\n\n      return y0;\n    },\n    expand: function (data) {\n      var n = data.length,\n          m = data[0].length,\n          k = 1 / n,\n          i,\n          j,\n          o,\n          y0 = [];\n\n      for (j = 0; j < m; ++j) {\n        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];\n\n        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o;else for (i = 0; i < n; i++) data[i][j][1] = k;\n      }\n\n      for (j = 0; j < m; ++j) y0[j] = 0;\n\n      return y0;\n    },\n    zero: d3_layout_stackOffsetZero\n  });\n\n  function d3_layout_stackOrderDefault(data) {\n    return d3.range(data.length);\n  }\n\n  function d3_layout_stackOffsetZero(data) {\n    var j = -1,\n        m = data[0].length,\n        y0 = [];\n\n    while (++j < m) y0[j] = 0;\n\n    return y0;\n  }\n\n  function d3_layout_stackMaxIndex(array) {\n    var i = 1,\n        j = 0,\n        v = array[0][1],\n        k,\n        n = array.length;\n\n    for (; i < n; ++i) {\n      if ((k = array[i][1]) > v) {\n        j = i;\n        v = k;\n      }\n    }\n\n    return j;\n  }\n\n  function d3_layout_stackReduceSum(d) {\n    return d.reduce(d3_layout_stackSum, 0);\n  }\n\n  function d3_layout_stackSum(p, d) {\n    return p + d[1];\n  }\n\n  d3.layout.histogram = function () {\n    var frequency = true,\n        valuer = Number,\n        ranger = d3_layout_histogramRange,\n        binner = d3_layout_histogramBinSturges;\n\n    function histogram(data, i) {\n      var bins = [],\n          values = data.map(valuer, this),\n          range = ranger.call(this, values, i),\n          thresholds = binner.call(this, range, values, i),\n          bin,\n          i = -1,\n          n = values.length,\n          m = thresholds.length - 1,\n          k = frequency ? 1 : 1 / n,\n          x;\n\n      while (++i < m) {\n        bin = bins[i] = [];\n        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);\n        bin.y = 0;\n      }\n\n      if (m > 0) {\n        i = -1;\n\n        while (++i < n) {\n          x = values[i];\n\n          if (x >= range[0] && x <= range[1]) {\n            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];\n            bin.y += k;\n            bin.push(data[i]);\n          }\n        }\n      }\n\n      return bins;\n    }\n\n    histogram.value = function (x) {\n      if (!arguments.length) return valuer;\n      valuer = x;\n      return histogram;\n    };\n\n    histogram.range = function (x) {\n      if (!arguments.length) return ranger;\n      ranger = d3_functor(x);\n      return histogram;\n    };\n\n    histogram.bins = function (x) {\n      if (!arguments.length) return binner;\n      binner = typeof x === \"number\" ? function (range) {\n        return d3_layout_histogramBinFixed(range, x);\n      } : d3_functor(x);\n      return histogram;\n    };\n\n    histogram.frequency = function (x) {\n      if (!arguments.length) return frequency;\n      frequency = !!x;\n      return histogram;\n    };\n\n    return histogram;\n  };\n\n  function d3_layout_histogramBinSturges(range, values) {\n    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));\n  }\n\n  function d3_layout_histogramBinFixed(range, n) {\n    var x = -1,\n        b = +range[0],\n        m = (range[1] - b) / n,\n        f = [];\n\n    while (++x <= n) f[x] = m * x + b;\n\n    return f;\n  }\n\n  function d3_layout_histogramRange(values) {\n    return [d3.min(values), d3.max(values)];\n  }\n\n  d3.layout.hierarchy = function () {\n    var sort = d3_layout_hierarchySort,\n        children = d3_layout_hierarchyChildren,\n        value = d3_layout_hierarchyValue;\n\n    function recurse(node, depth, nodes) {\n      var childs = children.call(hierarchy, node, depth);\n      node.depth = depth;\n      nodes.push(node);\n\n      if (childs && (n = childs.length)) {\n        var i = -1,\n            n,\n            c = node.children = [],\n            v = 0,\n            j = depth + 1,\n            d;\n\n        while (++i < n) {\n          d = recurse(childs[i], j, nodes);\n          d.parent = node;\n          c.push(d);\n          v += d.value;\n        }\n\n        if (sort) c.sort(sort);\n        if (value) node.value = v;\n      } else if (value) {\n        node.value = +value.call(hierarchy, node, depth) || 0;\n      }\n\n      return node;\n    }\n\n    function revalue(node, depth) {\n      var children = node.children,\n          v = 0;\n\n      if (children && (n = children.length)) {\n        var i = -1,\n            n,\n            j = depth + 1;\n\n        while (++i < n) v += revalue(children[i], j);\n      } else if (value) {\n        v = +value.call(hierarchy, node, depth) || 0;\n      }\n\n      if (value) node.value = v;\n      return v;\n    }\n\n    function hierarchy(d) {\n      var nodes = [];\n      recurse(d, 0, nodes);\n      return nodes;\n    }\n\n    hierarchy.sort = function (x) {\n      if (!arguments.length) return sort;\n      sort = x;\n      return hierarchy;\n    };\n\n    hierarchy.children = function (x) {\n      if (!arguments.length) return children;\n      children = x;\n      return hierarchy;\n    };\n\n    hierarchy.value = function (x) {\n      if (!arguments.length) return value;\n      value = x;\n      return hierarchy;\n    };\n\n    hierarchy.revalue = function (root) {\n      revalue(root, 0);\n      return root;\n    };\n\n    return hierarchy;\n  };\n\n  function d3_layout_hierarchyRebind(object, hierarchy) {\n    d3.rebind(object, hierarchy, \"sort\", \"children\", \"value\");\n    object.nodes = object;\n    object.links = d3_layout_hierarchyLinks;\n    return object;\n  }\n\n  function d3_layout_hierarchyChildren(d) {\n    return d.children;\n  }\n\n  function d3_layout_hierarchyValue(d) {\n    return d.value;\n  }\n\n  function d3_layout_hierarchySort(a, b) {\n    return b.value - a.value;\n  }\n\n  function d3_layout_hierarchyLinks(nodes) {\n    return d3.merge(nodes.map(function (parent) {\n      return (parent.children || []).map(function (child) {\n        return {\n          source: parent,\n          target: child\n        };\n      });\n    }));\n  }\n\n  d3.layout.pack = function () {\n    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort),\n        padding = 0,\n        size = [1, 1];\n\n    function pack(d, i) {\n      var nodes = hierarchy.call(this, d, i),\n          root = nodes[0];\n      root.x = 0;\n      root.y = 0;\n      d3_layout_treeVisitAfter(root, function (d) {\n        d.r = Math.sqrt(d.value);\n      });\n      d3_layout_treeVisitAfter(root, d3_layout_packSiblings);\n      var w = size[0],\n          h = size[1],\n          k = Math.max(2 * root.r / w, 2 * root.r / h);\n\n      if (padding > 0) {\n        var dr = padding * k / 2;\n        d3_layout_treeVisitAfter(root, function (d) {\n          d.r += dr;\n        });\n        d3_layout_treeVisitAfter(root, d3_layout_packSiblings);\n        d3_layout_treeVisitAfter(root, function (d) {\n          d.r -= dr;\n        });\n        k = Math.max(2 * root.r / w, 2 * root.r / h);\n      }\n\n      d3_layout_packTransform(root, w / 2, h / 2, 1 / k);\n      return nodes;\n    }\n\n    pack.size = function (x) {\n      if (!arguments.length) return size;\n      size = x;\n      return pack;\n    };\n\n    pack.padding = function (_) {\n      if (!arguments.length) return padding;\n      padding = +_;\n      return pack;\n    };\n\n    return d3_layout_hierarchyRebind(pack, hierarchy);\n  };\n\n  function d3_layout_packSort(a, b) {\n    return a.value - b.value;\n  }\n\n  function d3_layout_packInsert(a, b) {\n    var c = a._pack_next;\n    a._pack_next = b;\n    b._pack_prev = a;\n    b._pack_next = c;\n    c._pack_prev = b;\n  }\n\n  function d3_layout_packSplice(a, b) {\n    a._pack_next = b;\n    b._pack_prev = a;\n  }\n\n  function d3_layout_packIntersects(a, b) {\n    var dx = b.x - a.x,\n        dy = b.y - a.y,\n        dr = a.r + b.r;\n    return dr * dr - dx * dx - dy * dy > .001;\n  }\n\n  function d3_layout_packSiblings(node) {\n    if (!(nodes = node.children) || !(n = nodes.length)) return;\n    var nodes,\n        xMin = Infinity,\n        xMax = -Infinity,\n        yMin = Infinity,\n        yMax = -Infinity,\n        a,\n        b,\n        c,\n        i,\n        j,\n        k,\n        n;\n\n    function bound(node) {\n      xMin = Math.min(node.x - node.r, xMin);\n      xMax = Math.max(node.x + node.r, xMax);\n      yMin = Math.min(node.y - node.r, yMin);\n      yMax = Math.max(node.y + node.r, yMax);\n    }\n\n    nodes.forEach(d3_layout_packLink);\n    a = nodes[0];\n    a.x = -a.r;\n    a.y = 0;\n    bound(a);\n\n    if (n > 1) {\n      b = nodes[1];\n      b.x = b.r;\n      b.y = 0;\n      bound(b);\n\n      if (n > 2) {\n        c = nodes[2];\n        d3_layout_packPlace(a, b, c);\n        bound(c);\n        d3_layout_packInsert(a, c);\n        a._pack_prev = c;\n        d3_layout_packInsert(c, b);\n        b = a._pack_next;\n\n        for (i = 3; i < n; i++) {\n          d3_layout_packPlace(a, b, c = nodes[i]);\n          var isect = 0,\n              s1 = 1,\n              s2 = 1;\n\n          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {\n            if (d3_layout_packIntersects(j, c)) {\n              isect = 1;\n              break;\n            }\n          }\n\n          if (isect == 1) {\n            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {\n              if (d3_layout_packIntersects(k, c)) {\n                break;\n              }\n            }\n          }\n\n          if (isect) {\n            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j);else d3_layout_packSplice(a = k, b);\n            i--;\n          } else {\n            d3_layout_packInsert(a, c);\n            b = c;\n            bound(c);\n          }\n        }\n      }\n    }\n\n    var cx = (xMin + xMax) / 2,\n        cy = (yMin + yMax) / 2,\n        cr = 0;\n\n    for (i = 0; i < n; i++) {\n      c = nodes[i];\n      c.x -= cx;\n      c.y -= cy;\n      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));\n    }\n\n    node.r = cr;\n    nodes.forEach(d3_layout_packUnlink);\n  }\n\n  function d3_layout_packLink(node) {\n    node._pack_next = node._pack_prev = node;\n  }\n\n  function d3_layout_packUnlink(node) {\n    delete node._pack_next;\n    delete node._pack_prev;\n  }\n\n  function d3_layout_packTransform(node, x, y, k) {\n    var children = node.children;\n    node.x = x += k * node.x;\n    node.y = y += k * node.y;\n    node.r *= k;\n\n    if (children) {\n      var i = -1,\n          n = children.length;\n\n      while (++i < n) d3_layout_packTransform(children[i], x, y, k);\n    }\n  }\n\n  function d3_layout_packPlace(a, b, c) {\n    var db = a.r + c.r,\n        dx = b.x - a.x,\n        dy = b.y - a.y;\n\n    if (db && (dx || dy)) {\n      var da = b.r + c.r,\n          dc = dx * dx + dy * dy;\n      da *= da;\n      db *= db;\n      var x = .5 + (db - da) / (2 * dc),\n          y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);\n      c.x = a.x + x * dx + y * dy;\n      c.y = a.y + x * dy - y * dx;\n    } else {\n      c.x = a.x + db;\n      c.y = a.y;\n    }\n  }\n\n  d3.layout.cluster = function () {\n    var hierarchy = d3.layout.hierarchy().sort(null).value(null),\n        separation = d3_layout_treeSeparation,\n        size = [1, 1];\n\n    function cluster(d, i) {\n      var nodes = hierarchy.call(this, d, i),\n          root = nodes[0],\n          previousNode,\n          x = 0;\n      d3_layout_treeVisitAfter(root, function (node) {\n        var children = node.children;\n\n        if (children && children.length) {\n          node.x = d3_layout_clusterX(children);\n          node.y = d3_layout_clusterY(children);\n        } else {\n          node.x = previousNode ? x += separation(node, previousNode) : 0;\n          node.y = 0;\n          previousNode = node;\n        }\n      });\n      var left = d3_layout_clusterLeft(root),\n          right = d3_layout_clusterRight(root),\n          x0 = left.x - separation(left, right) / 2,\n          x1 = right.x + separation(right, left) / 2;\n      d3_layout_treeVisitAfter(root, function (node) {\n        node.x = (node.x - x0) / (x1 - x0) * size[0];\n        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];\n      });\n      return nodes;\n    }\n\n    cluster.separation = function (x) {\n      if (!arguments.length) return separation;\n      separation = x;\n      return cluster;\n    };\n\n    cluster.size = function (x) {\n      if (!arguments.length) return size;\n      size = x;\n      return cluster;\n    };\n\n    return d3_layout_hierarchyRebind(cluster, hierarchy);\n  };\n\n  function d3_layout_clusterY(children) {\n    return 1 + d3.max(children, function (child) {\n      return child.y;\n    });\n  }\n\n  function d3_layout_clusterX(children) {\n    return children.reduce(function (x, child) {\n      return x + child.x;\n    }, 0) / children.length;\n  }\n\n  function d3_layout_clusterLeft(node) {\n    var children = node.children;\n    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;\n  }\n\n  function d3_layout_clusterRight(node) {\n    var children = node.children,\n        n;\n    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;\n  }\n\n  d3.layout.tree = function () {\n    var hierarchy = d3.layout.hierarchy().sort(null).value(null),\n        separation = d3_layout_treeSeparation,\n        size = [1, 1];\n\n    function tree(d, i) {\n      var nodes = hierarchy.call(this, d, i),\n          root = nodes[0];\n\n      function firstWalk(node, previousSibling) {\n        var children = node.children,\n            layout = node._tree;\n\n        if (children && (n = children.length)) {\n          var n,\n              firstChild = children[0],\n              previousChild,\n              ancestor = firstChild,\n              child,\n              i = -1;\n\n          while (++i < n) {\n            child = children[i];\n            firstWalk(child, previousChild);\n            ancestor = apportion(child, previousChild, ancestor);\n            previousChild = child;\n          }\n\n          d3_layout_treeShift(node);\n          var midpoint = .5 * (firstChild._tree.prelim + child._tree.prelim);\n\n          if (previousSibling) {\n            layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);\n            layout.mod = layout.prelim - midpoint;\n          } else {\n            layout.prelim = midpoint;\n          }\n        } else {\n          if (previousSibling) {\n            layout.prelim = previousSibling._tree.prelim + separation(node, previousSibling);\n          }\n        }\n      }\n\n      function secondWalk(node, x) {\n        node.x = node._tree.prelim + x;\n        var children = node.children;\n\n        if (children && (n = children.length)) {\n          var i = -1,\n              n;\n          x += node._tree.mod;\n\n          while (++i < n) {\n            secondWalk(children[i], x);\n          }\n        }\n      }\n\n      function apportion(node, previousSibling, ancestor) {\n        if (previousSibling) {\n          var vip = node,\n              vop = node,\n              vim = previousSibling,\n              vom = node.parent.children[0],\n              sip = vip._tree.mod,\n              sop = vop._tree.mod,\n              sim = vim._tree.mod,\n              som = vom._tree.mod,\n              shift;\n\n          while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {\n            vom = d3_layout_treeLeft(vom);\n            vop = d3_layout_treeRight(vop);\n            vop._tree.ancestor = node;\n            shift = vim._tree.prelim + sim - vip._tree.prelim - sip + separation(vim, vip);\n\n            if (shift > 0) {\n              d3_layout_treeMove(d3_layout_treeAncestor(vim, node, ancestor), node, shift);\n              sip += shift;\n              sop += shift;\n            }\n\n            sim += vim._tree.mod;\n            sip += vip._tree.mod;\n            som += vom._tree.mod;\n            sop += vop._tree.mod;\n          }\n\n          if (vim && !d3_layout_treeRight(vop)) {\n            vop._tree.thread = vim;\n            vop._tree.mod += sim - sop;\n          }\n\n          if (vip && !d3_layout_treeLeft(vom)) {\n            vom._tree.thread = vip;\n            vom._tree.mod += sip - som;\n            ancestor = node;\n          }\n        }\n\n        return ancestor;\n      }\n\n      d3_layout_treeVisitAfter(root, function (node, previousSibling) {\n        node._tree = {\n          ancestor: node,\n          prelim: 0,\n          mod: 0,\n          change: 0,\n          shift: 0,\n          number: previousSibling ? previousSibling._tree.number + 1 : 0\n        };\n      });\n      firstWalk(root);\n      secondWalk(root, -root._tree.prelim);\n      var left = d3_layout_treeSearch(root, d3_layout_treeLeftmost),\n          right = d3_layout_treeSearch(root, d3_layout_treeRightmost),\n          deep = d3_layout_treeSearch(root, d3_layout_treeDeepest),\n          x0 = left.x - separation(left, right) / 2,\n          x1 = right.x + separation(right, left) / 2,\n          y1 = deep.depth || 1;\n      d3_layout_treeVisitAfter(root, function (node) {\n        node.x = (node.x - x0) / (x1 - x0) * size[0];\n        node.y = node.depth / y1 * size[1];\n        delete node._tree;\n      });\n      return nodes;\n    }\n\n    tree.separation = function (x) {\n      if (!arguments.length) return separation;\n      separation = x;\n      return tree;\n    };\n\n    tree.size = function (x) {\n      if (!arguments.length) return size;\n      size = x;\n      return tree;\n    };\n\n    return d3_layout_hierarchyRebind(tree, hierarchy);\n  };\n\n  function d3_layout_treeSeparation(a, b) {\n    return a.parent == b.parent ? 1 : 2;\n  }\n\n  function d3_layout_treeLeft(node) {\n    var children = node.children;\n    return children && children.length ? children[0] : node._tree.thread;\n  }\n\n  function d3_layout_treeRight(node) {\n    var children = node.children,\n        n;\n    return children && (n = children.length) ? children[n - 1] : node._tree.thread;\n  }\n\n  function d3_layout_treeSearch(node, compare) {\n    var children = node.children;\n\n    if (children && (n = children.length)) {\n      var child,\n          n,\n          i = -1;\n\n      while (++i < n) {\n        if (compare(child = d3_layout_treeSearch(children[i], compare), node) > 0) {\n          node = child;\n        }\n      }\n    }\n\n    return node;\n  }\n\n  function d3_layout_treeRightmost(a, b) {\n    return a.x - b.x;\n  }\n\n  function d3_layout_treeLeftmost(a, b) {\n    return b.x - a.x;\n  }\n\n  function d3_layout_treeDeepest(a, b) {\n    return a.depth - b.depth;\n  }\n\n  function d3_layout_treeVisitAfter(node, callback) {\n    function visit(node, previousSibling) {\n      var children = node.children;\n\n      if (children && (n = children.length)) {\n        var child,\n            previousChild = null,\n            i = -1,\n            n;\n\n        while (++i < n) {\n          child = children[i];\n          visit(child, previousChild);\n          previousChild = child;\n        }\n      }\n\n      callback(node, previousSibling);\n    }\n\n    visit(node, null);\n  }\n\n  function d3_layout_treeShift(node) {\n    var shift = 0,\n        change = 0,\n        children = node.children,\n        i = children.length,\n        child;\n\n    while (--i >= 0) {\n      child = children[i]._tree;\n      child.prelim += shift;\n      child.mod += shift;\n      shift += child.shift + (change += child.change);\n    }\n  }\n\n  function d3_layout_treeMove(ancestor, node, shift) {\n    ancestor = ancestor._tree;\n    node = node._tree;\n    var change = shift / (node.number - ancestor.number);\n    ancestor.change += change;\n    node.change -= change;\n    node.shift += shift;\n    node.prelim += shift;\n    node.mod += shift;\n  }\n\n  function d3_layout_treeAncestor(vim, node, ancestor) {\n    return vim._tree.ancestor.parent == node.parent ? vim._tree.ancestor : ancestor;\n  }\n\n  d3.layout.treemap = function () {\n    var hierarchy = d3.layout.hierarchy(),\n        round = Math.round,\n        size = [1, 1],\n        padding = null,\n        pad = d3_layout_treemapPadNull,\n        sticky = false,\n        stickies,\n        mode = \"squarify\",\n        ratio = .5 * (1 + Math.sqrt(5));\n\n    function scale(children, k) {\n      var i = -1,\n          n = children.length,\n          child,\n          area;\n\n      while (++i < n) {\n        area = (child = children[i]).value * (k < 0 ? 0 : k);\n        child.area = isNaN(area) || area <= 0 ? 0 : area;\n      }\n    }\n\n    function squarify(node) {\n      var children = node.children;\n\n      if (children && children.length) {\n        var rect = pad(node),\n            row = [],\n            remaining = children.slice(),\n            child,\n            best = Infinity,\n            score,\n            u = mode === \"slice\" ? rect.dx : mode === \"dice\" || mode === \"slice-dice\" && node.depth & 1 ? rect.dy : Math.min(rect.dx, rect.dy),\n            n;\n        scale(remaining, rect.dx * rect.dy / node.value);\n        row.area = 0;\n\n        while ((n = remaining.length) > 0) {\n          row.push(child = remaining[n - 1]);\n          row.area += child.area;\n\n          if (mode !== \"squarify\" || (score = worst(row, u)) <= best) {\n            remaining.pop();\n            best = score;\n          } else {\n            row.area -= row.pop().area;\n            position(row, u, rect, false);\n            u = Math.min(rect.dx, rect.dy);\n            row.length = row.area = 0;\n            best = Infinity;\n          }\n        }\n\n        if (row.length) {\n          position(row, u, rect, true);\n          row.length = row.area = 0;\n        }\n\n        children.forEach(squarify);\n      }\n    }\n\n    function stickify(node) {\n      var children = node.children;\n\n      if (children && children.length) {\n        var rect = pad(node),\n            remaining = children.slice(),\n            child,\n            row = [];\n        scale(remaining, rect.dx * rect.dy / node.value);\n        row.area = 0;\n\n        while (child = remaining.pop()) {\n          row.push(child);\n          row.area += child.area;\n\n          if (child.z != null) {\n            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);\n            row.length = row.area = 0;\n          }\n        }\n\n        children.forEach(stickify);\n      }\n    }\n\n    function worst(row, u) {\n      var s = row.area,\n          r,\n          rmax = 0,\n          rmin = Infinity,\n          i = -1,\n          n = row.length;\n\n      while (++i < n) {\n        if (!(r = row[i].area)) continue;\n        if (r < rmin) rmin = r;\n        if (r > rmax) rmax = r;\n      }\n\n      s *= s;\n      u *= u;\n      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;\n    }\n\n    function position(row, u, rect, flush) {\n      var i = -1,\n          n = row.length,\n          x = rect.x,\n          y = rect.y,\n          v = u ? round(row.area / u) : 0,\n          o;\n\n      if (u == rect.dx) {\n        if (flush || v > rect.dy) v = rect.dy;\n\n        while (++i < n) {\n          o = row[i];\n          o.x = x;\n          o.y = y;\n          o.dy = v;\n          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);\n        }\n\n        o.z = true;\n        o.dx += rect.x + rect.dx - x;\n        rect.y += v;\n        rect.dy -= v;\n      } else {\n        if (flush || v > rect.dx) v = rect.dx;\n\n        while (++i < n) {\n          o = row[i];\n          o.x = x;\n          o.y = y;\n          o.dx = v;\n          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);\n        }\n\n        o.z = false;\n        o.dy += rect.y + rect.dy - y;\n        rect.x += v;\n        rect.dx -= v;\n      }\n    }\n\n    function treemap(d) {\n      var nodes = stickies || hierarchy(d),\n          root = nodes[0];\n      root.x = 0;\n      root.y = 0;\n      root.dx = size[0];\n      root.dy = size[1];\n      if (stickies) hierarchy.revalue(root);\n      scale([root], root.dx * root.dy / root.value);\n      (stickies ? stickify : squarify)(root);\n      if (sticky) stickies = nodes;\n      return nodes;\n    }\n\n    treemap.size = function (x) {\n      if (!arguments.length) return size;\n      size = x;\n      return treemap;\n    };\n\n    treemap.padding = function (x) {\n      if (!arguments.length) return padding;\n\n      function padFunction(node) {\n        var p = x.call(treemap, node, node.depth);\n        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === \"number\" ? [p, p, p, p] : p);\n      }\n\n      function padConstant(node) {\n        return d3_layout_treemapPad(node, x);\n      }\n\n      var type;\n      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === \"function\" ? padFunction : type === \"number\" ? (x = [x, x, x, x], padConstant) : padConstant;\n      return treemap;\n    };\n\n    treemap.round = function (x) {\n      if (!arguments.length) return round != Number;\n      round = x ? Math.round : Number;\n      return treemap;\n    };\n\n    treemap.sticky = function (x) {\n      if (!arguments.length) return sticky;\n      sticky = x;\n      stickies = null;\n      return treemap;\n    };\n\n    treemap.ratio = function (x) {\n      if (!arguments.length) return ratio;\n      ratio = x;\n      return treemap;\n    };\n\n    treemap.mode = function (x) {\n      if (!arguments.length) return mode;\n      mode = x + \"\";\n      return treemap;\n    };\n\n    return d3_layout_hierarchyRebind(treemap, hierarchy);\n  };\n\n  function d3_layout_treemapPadNull(node) {\n    return {\n      x: node.x,\n      y: node.y,\n      dx: node.dx,\n      dy: node.dy\n    };\n  }\n\n  function d3_layout_treemapPad(node, padding) {\n    var x = node.x + padding[3],\n        y = node.y + padding[0],\n        dx = node.dx - padding[1] - padding[3],\n        dy = node.dy - padding[0] - padding[2];\n\n    if (dx < 0) {\n      x += dx / 2;\n      dx = 0;\n    }\n\n    if (dy < 0) {\n      y += dy / 2;\n      dy = 0;\n    }\n\n    return {\n      x: x,\n      y: y,\n      dx: dx,\n      dy: dy\n    };\n  }\n\n  function d3_dsv(delimiter, mimeType) {\n    var reFormat = new RegExp('[\"' + delimiter + \"\\n]\"),\n        delimiterCode = delimiter.charCodeAt(0);\n\n    function dsv(url, callback) {\n      return d3.xhr(url, mimeType, callback).response(response);\n    }\n\n    function response(request) {\n      return dsv.parse(request.responseText);\n    }\n\n    dsv.parse = function (text) {\n      var o;\n      return dsv.parseRows(text, function (row) {\n        if (o) return o(row);\n        o = new Function(\"d\", \"return {\" + row.map(function (name, i) {\n          return JSON.stringify(name) + \": d[\" + i + \"]\";\n        }).join(\",\") + \"}\");\n      });\n    };\n\n    dsv.parseRows = function (text, f) {\n      var EOL = {},\n          EOF = {},\n          rows = [],\n          N = text.length,\n          I = 0,\n          n = 0,\n          t,\n          eol;\n\n      function token() {\n        if (I >= N) return EOF;\n        if (eol) return eol = false, EOL;\n        var j = I;\n\n        if (text.charCodeAt(j) === 34) {\n          var i = j;\n\n          while (i++ < N) {\n            if (text.charCodeAt(i) === 34) {\n              if (text.charCodeAt(i + 1) !== 34) break;\n              ++i;\n            }\n          }\n\n          I = i + 2;\n          var c = text.charCodeAt(i + 1);\n\n          if (c === 13) {\n            eol = true;\n            if (text.charCodeAt(i + 2) === 10) ++I;\n          } else if (c === 10) {\n            eol = true;\n          }\n\n          return text.substring(j + 1, i).replace(/\"\"/g, '\"');\n        }\n\n        while (I < N) {\n          var c = text.charCodeAt(I++),\n              k = 1;\n          if (c === 10) eol = true;else if (c === 13) {\n            eol = true;\n            if (text.charCodeAt(I) === 10) ++I, ++k;\n          } else if (c !== delimiterCode) continue;\n          return text.substring(j, I - k);\n        }\n\n        return text.substring(j);\n      }\n\n      while ((t = token()) !== EOF) {\n        var a = [];\n\n        while (t !== EOL && t !== EOF) {\n          a.push(t);\n          t = token();\n        }\n\n        if (f && !(a = f(a, n++))) continue;\n        rows.push(a);\n      }\n\n      return rows;\n    };\n\n    dsv.format = function (rows) {\n      return rows.map(formatRow).join(\"\\n\");\n    };\n\n    function formatRow(row) {\n      return row.map(formatValue).join(delimiter);\n    }\n\n    function formatValue(text) {\n      return reFormat.test(text) ? '\"' + text.replace(/\\\"/g, '\"\"') + '\"' : text;\n    }\n\n    return dsv;\n  }\n\n  d3.csv = d3_dsv(\",\", \"text/csv\");\n  d3.tsv = d3_dsv(\"\t\", \"text/tab-separated-values\");\n  d3.geo = {};\n\n  d3.geo.stream = function (object, listener) {\n    if (d3_geo_streamObjectType.hasOwnProperty(object.type)) {\n      d3_geo_streamObjectType[object.type](object, listener);\n    } else {\n      d3_geo_streamGeometry(object, listener);\n    }\n  };\n\n  function d3_geo_streamGeometry(geometry, listener) {\n    if (d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {\n      d3_geo_streamGeometryType[geometry.type](geometry, listener);\n    }\n  }\n\n  var d3_geo_streamObjectType = {\n    Feature: function (feature, listener) {\n      d3_geo_streamGeometry(feature.geometry, listener);\n    },\n    FeatureCollection: function (object, listener) {\n      var features = object.features,\n          i = -1,\n          n = features.length;\n\n      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);\n    },\n    GeometryCollection: function (object, listener) {\n      var geometries = object.geometries,\n          i = -1,\n          n = geometries.length;\n\n      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);\n    }\n  };\n  var d3_geo_streamGeometryType = {\n    Sphere: function (object, listener) {\n      listener.sphere();\n    },\n    Point: function (object, listener) {\n      var coordinate = object.coordinates;\n      listener.point(coordinate[0], coordinate[1]);\n    },\n    MultiPoint: function (object, listener) {\n      var coordinates = object.coordinates,\n          i = -1,\n          n = coordinates.length,\n          coordinate;\n\n      while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1]);\n    },\n    LineString: function (object, listener) {\n      d3_geo_streamLine(object.coordinates, listener, 0);\n    },\n    MultiLineString: function (object, listener) {\n      var coordinates = object.coordinates,\n          i = -1,\n          n = coordinates.length;\n\n      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);\n    },\n    Polygon: function (object, listener) {\n      d3_geo_streamPolygon(object.coordinates, listener);\n    },\n    MultiPolygon: function (object, listener) {\n      var coordinates = object.coordinates,\n          i = -1,\n          n = coordinates.length;\n\n      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);\n    }\n  };\n\n  function d3_geo_streamLine(coordinates, listener, closed) {\n    var i = -1,\n        n = coordinates.length - closed,\n        coordinate;\n    listener.lineStart();\n\n    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1]);\n\n    listener.lineEnd();\n  }\n\n  function d3_geo_streamPolygon(coordinates, listener) {\n    var i = -1,\n        n = coordinates.length;\n    listener.polygonStart();\n\n    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);\n\n    listener.polygonEnd();\n  }\n\n  function d3_geo_spherical(cartesian) {\n    return [Math.atan2(cartesian[1], cartesian[0]), Math.asin(Math.max(-1, Math.min(1, cartesian[2])))];\n  }\n\n  function d3_geo_sphericalEqual(a, b) {\n    return Math.abs(a[0] - b[0]) < ε && Math.abs(a[1] - b[1]) < ε;\n  }\n\n  function d3_geo_cartesian(spherical) {\n    var λ = spherical[0],\n        φ = spherical[1],\n        cosφ = Math.cos(φ);\n    return [cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ)];\n  }\n\n  function d3_geo_cartesianDot(a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n  }\n\n  function d3_geo_cartesianCross(a, b) {\n    return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];\n  }\n\n  function d3_geo_cartesianAdd(a, b) {\n    a[0] += b[0];\n    a[1] += b[1];\n    a[2] += b[2];\n  }\n\n  function d3_geo_cartesianScale(vector, k) {\n    return [vector[0] * k, vector[1] * k, vector[2] * k];\n  }\n\n  function d3_geo_cartesianNormalize(d) {\n    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\n    d[0] /= l;\n    d[1] /= l;\n    d[2] /= l;\n  }\n\n  function d3_geo_resample(project) {\n    var δ2 = .5,\n        maxDepth = 16;\n\n    function resample(stream) {\n      var λ0, x0, y0, a0, b0, c0;\n      var resample = {\n        point: point,\n        lineStart: lineStart,\n        lineEnd: lineEnd,\n        polygonStart: function () {\n          stream.polygonStart();\n          resample.lineStart = polygonLineStart;\n        },\n        polygonEnd: function () {\n          stream.polygonEnd();\n          resample.lineStart = lineStart;\n        }\n      };\n\n      function point(x, y) {\n        x = project(x, y);\n        stream.point(x[0], x[1]);\n      }\n\n      function lineStart() {\n        x0 = NaN;\n        resample.point = linePoint;\n        stream.lineStart();\n      }\n\n      function linePoint(λ, φ) {\n        var c = d3_geo_cartesian([λ, φ]),\n            p = project(λ, φ);\n        resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);\n        stream.point(x0, y0);\n      }\n\n      function lineEnd() {\n        resample.point = point;\n        stream.lineEnd();\n      }\n\n      function polygonLineStart() {\n        var λ00, φ00, x00, y00, a00, b00, c00;\n        lineStart();\n\n        resample.point = function (λ, φ) {\n          linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;\n          resample.point = linePoint;\n        };\n\n        resample.lineEnd = function () {\n          resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);\n          resample.lineEnd = lineEnd;\n          lineEnd();\n        };\n      }\n\n      return resample;\n    }\n\n    function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {\n      var dx = x1 - x0,\n          dy = y1 - y0,\n          d2 = dx * dx + dy * dy;\n\n      if (d2 > 4 * δ2 && depth--) {\n        var a = a0 + a1,\n            b = b0 + b1,\n            c = c0 + c1,\n            m = Math.sqrt(a * a + b * b + c * c),\n            φ2 = Math.asin(c /= m),\n            λ2 = Math.abs(Math.abs(c) - 1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a),\n            p = project(λ2, φ2),\n            x2 = p[0],\n            y2 = p[1],\n            dx2 = x2 - x0,\n            dy2 = y2 - y0,\n            dz = dy * dx2 - dx * dy2;\n\n        if (dz * dz / d2 > δ2 || Math.abs((dx * dx2 + dy * dy2) / d2 - .5) > .3) {\n          resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);\n          stream.point(x2, y2);\n          resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);\n        }\n      }\n    }\n\n    resample.precision = function (_) {\n      if (!arguments.length) return Math.sqrt(δ2);\n      maxDepth = (δ2 = _ * _) > 0 && 16;\n      return resample;\n    };\n\n    return resample;\n  }\n\n  d3.geo.albersUsa = function () {\n    var lower48 = d3.geo.albers();\n    var alaska = d3.geo.albers().rotate([160, 0]).center([0, 60]).parallels([55, 65]);\n    var hawaii = d3.geo.albers().rotate([160, 0]).center([0, 20]).parallels([8, 18]);\n    var puertoRico = d3.geo.albers().rotate([60, 0]).center([0, 10]).parallels([8, 18]);\n\n    function albersUsa(coordinates) {\n      return projection(coordinates)(coordinates);\n    }\n\n    function projection(point) {\n      var lon = point[0],\n          lat = point[1];\n      return lat > 50 ? alaska : lon < -140 ? hawaii : lat < 21 ? puertoRico : lower48;\n    }\n\n    albersUsa.scale = function (x) {\n      if (!arguments.length) return lower48.scale();\n      lower48.scale(x);\n      alaska.scale(x * .6);\n      hawaii.scale(x);\n      puertoRico.scale(x * 1.5);\n      return albersUsa.translate(lower48.translate());\n    };\n\n    albersUsa.translate = function (x) {\n      if (!arguments.length) return lower48.translate();\n      var dz = lower48.scale(),\n          dx = x[0],\n          dy = x[1];\n      lower48.translate(x);\n      alaska.translate([dx - .4 * dz, dy + .17 * dz]);\n      hawaii.translate([dx - .19 * dz, dy + .2 * dz]);\n      puertoRico.translate([dx + .58 * dz, dy + .43 * dz]);\n      return albersUsa;\n    };\n\n    return albersUsa.scale(lower48.scale());\n  };\n\n  function d3_geo_albers(φ0, φ1) {\n    var sinφ0 = Math.sin(φ0),\n        n = (sinφ0 + Math.sin(φ1)) / 2,\n        C = 1 + sinφ0 * (2 * n - sinφ0),\n        ρ0 = Math.sqrt(C) / n;\n\n    function albers(λ, φ) {\n      var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;\n      return [ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ)];\n    }\n\n    albers.invert = function (x, y) {\n      var ρ0_y = ρ0 - y;\n      return [Math.atan2(x, ρ0_y) / n, Math.asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n))];\n    };\n\n    return albers;\n  }\n\n  (d3.geo.albers = function () {\n    var φ0 = 29.5 * d3_radians,\n        φ1 = 45.5 * d3_radians,\n        m = d3_geo_projectionMutator(d3_geo_albers),\n        p = m(φ0, φ1);\n\n    p.parallels = function (_) {\n      if (!arguments.length) return [φ0 * d3_degrees, φ1 * d3_degrees];\n      return m(φ0 = _[0] * d3_radians, φ1 = _[1] * d3_radians);\n    };\n\n    return p.rotate([98, 0]).center([0, 38]).scale(1e3);\n  }).raw = d3_geo_albers;\n  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function (cosλcosφ) {\n    return Math.sqrt(2 / (1 + cosλcosφ));\n  }, function (ρ) {\n    return 2 * Math.asin(ρ / 2);\n  });\n  (d3.geo.azimuthalEqualArea = function () {\n    return d3_geo_projection(d3_geo_azimuthalEqualArea);\n  }).raw = d3_geo_azimuthalEqualArea;\n  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function (cosλcosφ) {\n    var c = Math.acos(cosλcosφ);\n    return c && c / Math.sin(c);\n  }, d3_identity);\n  (d3.geo.azimuthalEquidistant = function () {\n    return d3_geo_projection(d3_geo_azimuthalEquidistant);\n  }).raw = d3_geo_azimuthalEquidistant;\n  d3.geo.bounds = d3_geo_bounds();\n\n  function d3_geo_bounds(projection) {\n    var x0, y0, x1, y1;\n    var bound = {\n      point: boundPoint,\n      lineStart: d3_noop,\n      lineEnd: d3_noop,\n      polygonStart: function () {\n        bound.lineEnd = boundPolygonLineEnd;\n      },\n      polygonEnd: function () {\n        bound.point = boundPoint;\n      }\n    };\n    var projectBound = projection ? projection.stream(bound) : bound;\n\n    function boundPoint(x, y) {\n      if (x < x0) x0 = x;\n      if (x > x1) x1 = x;\n      if (y < y0) y0 = y;\n      if (y > y1) y1 = y;\n    }\n\n    function boundPolygonLineEnd() {\n      bound.point = bound.lineEnd = d3_noop;\n    }\n\n    return function (feature) {\n      y1 = x1 = -(x0 = y0 = Infinity);\n      d3.geo.stream(feature, projectBound);\n      return [[x0, y0], [x1, y1]];\n    };\n  }\n\n  d3.geo.centroid = function (object) {\n    d3_geo_centroidDimension = d3_geo_centroidW = d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;\n    d3.geo.stream(object, d3_geo_centroid);\n    var m;\n\n    if (d3_geo_centroidW && Math.abs(m = Math.sqrt(d3_geo_centroidX * d3_geo_centroidX + d3_geo_centroidY * d3_geo_centroidY + d3_geo_centroidZ * d3_geo_centroidZ)) > ε) {\n      return [Math.atan2(d3_geo_centroidY, d3_geo_centroidX) * d3_degrees, Math.asin(Math.max(-1, Math.min(1, d3_geo_centroidZ / m))) * d3_degrees];\n    }\n  };\n\n  var d3_geo_centroidDimension, d3_geo_centroidW, d3_geo_centroidX, d3_geo_centroidY, d3_geo_centroidZ;\n  var d3_geo_centroid = {\n    sphere: d3_noop,\n    point: d3_geo_centroidPoint,\n    lineStart: d3_geo_centroidLineStart,\n    lineEnd: d3_geo_centroidLineEnd,\n    polygonStart: function () {\n      d3_geo_centroidDimension = 2;\n      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;\n    },\n    polygonEnd: function () {\n      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;\n    }\n  };\n\n  function d3_geo_centroidPoint(λ, φ) {\n    if (d3_geo_centroidDimension) return;\n    ++d3_geo_centroidW;\n    λ *= d3_radians;\n    var cosφ = Math.cos(φ *= d3_radians);\n    d3_geo_centroidX += (cosφ * Math.cos(λ) - d3_geo_centroidX) / d3_geo_centroidW;\n    d3_geo_centroidY += (cosφ * Math.sin(λ) - d3_geo_centroidY) / d3_geo_centroidW;\n    d3_geo_centroidZ += (Math.sin(φ) - d3_geo_centroidZ) / d3_geo_centroidW;\n  }\n\n  function d3_geo_centroidRingStart() {\n    var λ00, φ00;\n\n    if (d3_geo_centroidDimension < 2) {\n      d3_geo_centroidDimension = 2;\n      d3_geo_centroidW = d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;\n    }\n\n    d3_geo_centroidDimension = 1;\n    d3_geo_centroidLineStart();\n    d3_geo_centroidDimension = 2;\n    var linePoint = d3_geo_centroid.point;\n\n    d3_geo_centroid.point = function (λ, φ) {\n      linePoint(λ00 = λ, φ00 = φ);\n    };\n\n    d3_geo_centroid.lineEnd = function () {\n      d3_geo_centroid.point(λ00, φ00);\n      d3_geo_centroidLineEnd();\n      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;\n    };\n  }\n\n  function d3_geo_centroidLineStart() {\n    var x0, y0, z0;\n\n    if (d3_geo_centroidDimension !== 1) {\n      if (d3_geo_centroidDimension < 1) {\n        d3_geo_centroidDimension = 1;\n        d3_geo_centroidW = d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;\n      } else return;\n    }\n\n    d3_geo_centroid.point = function (λ, φ) {\n      λ *= d3_radians;\n      var cosφ = Math.cos(φ *= d3_radians);\n      x0 = cosφ * Math.cos(λ);\n      y0 = cosφ * Math.sin(λ);\n      z0 = Math.sin(φ);\n      d3_geo_centroid.point = nextPoint;\n    };\n\n    function nextPoint(λ, φ) {\n      λ *= d3_radians;\n      var cosφ = Math.cos(φ *= d3_radians),\n          x = cosφ * Math.cos(λ),\n          y = cosφ * Math.sin(λ),\n          z = Math.sin(φ),\n          w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);\n      d3_geo_centroidW += w;\n      d3_geo_centroidX += w * (x0 + (x0 = x));\n      d3_geo_centroidY += w * (y0 + (y0 = y));\n      d3_geo_centroidZ += w * (z0 + (z0 = z));\n    }\n  }\n\n  function d3_geo_centroidLineEnd() {\n    d3_geo_centroid.point = d3_geo_centroidPoint;\n  }\n\n  d3.geo.circle = function () {\n    var origin = [0, 0],\n        angle,\n        precision = 6,\n        interpolate;\n\n    function circle() {\n      var center = typeof origin === \"function\" ? origin.apply(this, arguments) : origin,\n          rotate = d3_geo_rotation(center[0] * d3_radians, center[1] * d3_radians, 0),\n          ring = [];\n      interpolate(null, null, 1, {\n        point: function (x, y) {\n          ring.push(x = rotate(x, y));\n          x[0] *= d3_degrees, x[1] *= d3_degrees;\n        }\n      });\n      return {\n        type: \"Polygon\",\n        coordinates: [ring]\n      };\n    }\n\n    circle.origin = function (x) {\n      if (!arguments.length) return origin;\n      origin = x;\n      return circle;\n    };\n\n    circle.angle = function (x) {\n      if (!arguments.length) return angle;\n      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);\n      return circle;\n    };\n\n    circle.precision = function (_) {\n      if (!arguments.length) return precision;\n      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);\n      return circle;\n    };\n\n    return circle.angle(90);\n  };\n\n  function d3_geo_circleInterpolate(radians, precision) {\n    var cr = Math.cos(radians),\n        sr = Math.sin(radians);\n    return function (from, to, direction, listener) {\n      if (from != null) {\n        from = d3_geo_circleAngle(cr, from);\n        to = d3_geo_circleAngle(cr, to);\n        if (direction > 0 ? from < to : from > to) from += direction * 2 * π;\n      } else {\n        from = radians + direction * 2 * π;\n        to = radians;\n      }\n\n      var point;\n\n      for (var step = direction * precision, t = from; direction > 0 ? t > to : t < to; t -= step) {\n        listener.point((point = d3_geo_spherical([cr, -sr * Math.cos(t), -sr * Math.sin(t)]))[0], point[1]);\n      }\n    };\n  }\n\n  function d3_geo_circleAngle(cr, point) {\n    var a = d3_geo_cartesian(point);\n    a[0] -= cr;\n    d3_geo_cartesianNormalize(a);\n    var angle = Math.acos(Math.max(-1, Math.min(1, -a[1])));\n    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);\n  }\n\n  function d3_geo_clip(pointVisible, clipLine, interpolate) {\n    return function (listener) {\n      var line = clipLine(listener);\n      var clip = {\n        point: point,\n        lineStart: lineStart,\n        lineEnd: lineEnd,\n        polygonStart: function () {\n          clip.point = pointRing;\n          clip.lineStart = ringStart;\n          clip.lineEnd = ringEnd;\n          invisible = false;\n          invisibleArea = visibleArea = 0;\n          segments = [];\n          listener.polygonStart();\n        },\n        polygonEnd: function () {\n          clip.point = point;\n          clip.lineStart = lineStart;\n          clip.lineEnd = lineEnd;\n          segments = d3.merge(segments);\n\n          if (segments.length) {\n            d3_geo_clipPolygon(segments, interpolate, listener);\n          } else if (visibleArea < -ε || invisible && invisibleArea < -ε) {\n            listener.lineStart();\n            interpolate(null, null, 1, listener);\n            listener.lineEnd();\n          }\n\n          listener.polygonEnd();\n          segments = null;\n        },\n        sphere: function () {\n          listener.polygonStart();\n          listener.lineStart();\n          interpolate(null, null, 1, listener);\n          listener.lineEnd();\n          listener.polygonEnd();\n        }\n      };\n\n      function point(λ, φ) {\n        if (pointVisible(λ, φ)) listener.point(λ, φ);\n      }\n\n      function pointLine(λ, φ) {\n        line.point(λ, φ);\n      }\n\n      function lineStart() {\n        clip.point = pointLine;\n        line.lineStart();\n      }\n\n      function lineEnd() {\n        clip.point = point;\n        line.lineEnd();\n      }\n\n      var segments, visibleArea, invisibleArea, invisible;\n      var buffer = d3_geo_clipBufferListener(),\n          ringListener = clipLine(buffer),\n          ring;\n\n      function pointRing(λ, φ) {\n        ringListener.point(λ, φ);\n        ring.push([λ, φ]);\n      }\n\n      function ringStart() {\n        ringListener.lineStart();\n        ring = [];\n      }\n\n      function ringEnd() {\n        pointRing(ring[0][0], ring[0][1]);\n        ringListener.lineEnd();\n        var clean = ringListener.clean(),\n            ringSegments = buffer.buffer(),\n            segment,\n            n = ringSegments.length;\n\n        if (!n) {\n          invisible = true;\n          invisibleArea += d3_geo_clipAreaRing(ring, -1);\n          ring = null;\n          return;\n        }\n\n        ring = null;\n\n        if (clean & 1) {\n          segment = ringSegments[0];\n          visibleArea += d3_geo_clipAreaRing(segment, 1);\n          var n = segment.length - 1,\n              i = -1,\n              point;\n          listener.lineStart();\n\n          while (++i < n) listener.point((point = segment[i])[0], point[1]);\n\n          listener.lineEnd();\n          return;\n        }\n\n        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));\n      }\n\n      return clip;\n    };\n  }\n\n  function d3_geo_clipPolygon(segments, interpolate, listener) {\n    var subject = [],\n        clip = [];\n    segments.forEach(function (segment) {\n      var n = segment.length;\n      if (n <= 1) return;\n      var p0 = segment[0],\n          p1 = segment[n - 1],\n          a = {\n        point: p0,\n        points: segment,\n        other: null,\n        visited: false,\n        entry: true,\n        subject: true\n      },\n          b = {\n        point: p0,\n        points: [p0],\n        other: a,\n        visited: false,\n        entry: false,\n        subject: false\n      };\n      a.other = b;\n      subject.push(a);\n      clip.push(b);\n      a = {\n        point: p1,\n        points: [p1],\n        other: null,\n        visited: false,\n        entry: false,\n        subject: true\n      };\n      b = {\n        point: p1,\n        points: [p1],\n        other: a,\n        visited: false,\n        entry: true,\n        subject: false\n      };\n      a.other = b;\n      subject.push(a);\n      clip.push(b);\n    });\n    clip.sort(d3_geo_clipSort);\n    d3_geo_clipLinkCircular(subject);\n    d3_geo_clipLinkCircular(clip);\n    if (!subject.length) return;\n    var start = subject[0],\n        current,\n        points,\n        point;\n\n    while (1) {\n      current = start;\n\n      while (current.visited) if ((current = current.next) === start) return;\n\n      points = current.points;\n      listener.lineStart();\n\n      do {\n        current.visited = current.other.visited = true;\n\n        if (current.entry) {\n          if (current.subject) {\n            for (var i = 0; i < points.length; i++) listener.point((point = points[i])[0], point[1]);\n          } else {\n            interpolate(current.point, current.next.point, 1, listener);\n          }\n\n          current = current.next;\n        } else {\n          if (current.subject) {\n            points = current.prev.points;\n\n            for (var i = points.length; --i >= 0;) listener.point((point = points[i])[0], point[1]);\n          } else {\n            interpolate(current.point, current.prev.point, -1, listener);\n          }\n\n          current = current.prev;\n        }\n\n        current = current.other;\n        points = current.points;\n      } while (!current.visited);\n\n      listener.lineEnd();\n    }\n  }\n\n  function d3_geo_clipLinkCircular(array) {\n    if (!(n = array.length)) return;\n    var n,\n        i = 0,\n        a = array[0],\n        b;\n\n    while (++i < n) {\n      a.next = b = array[i];\n      b.prev = a;\n      a = b;\n    }\n\n    a.next = b = array[0];\n    b.prev = a;\n  }\n\n  function d3_geo_clipSort(a, b) {\n    return ((a = a.point)[0] < 0 ? a[1] - π / 2 - ε : π / 2 - a[1]) - ((b = b.point)[0] < 0 ? b[1] - π / 2 - ε : π / 2 - b[1]);\n  }\n\n  function d3_geo_clipSegmentLength1(segment) {\n    return segment.length > 1;\n  }\n\n  function d3_geo_clipBufferListener() {\n    var lines = [],\n        line;\n    return {\n      lineStart: function () {\n        lines.push(line = []);\n      },\n      point: function (λ, φ) {\n        line.push([λ, φ]);\n      },\n      lineEnd: d3_noop,\n      buffer: function () {\n        var buffer = lines;\n        lines = [];\n        line = null;\n        return buffer;\n      }\n    };\n  }\n\n  function d3_geo_clipAreaRing(ring, invisible) {\n    if (!(n = ring.length)) return 0;\n    var n,\n        i = 0,\n        area = 0,\n        p = ring[0],\n        λ = p[0],\n        φ = p[1],\n        cosφ = Math.cos(φ),\n        x0 = Math.atan2(invisible * Math.sin(λ) * cosφ, Math.sin(φ)),\n        y0 = 1 - invisible * Math.cos(λ) * cosφ,\n        x1 = x0,\n        x,\n        y;\n\n    while (++i < n) {\n      p = ring[i];\n      cosφ = Math.cos(φ = p[1]);\n      x = Math.atan2(invisible * Math.sin(λ = p[0]) * cosφ, Math.sin(φ));\n      y = 1 - invisible * Math.cos(λ) * cosφ;\n      if (Math.abs(y0 - 2) < ε && Math.abs(y - 2) < ε) continue;\n\n      if (Math.abs(y) < ε || Math.abs(y0) < ε) {} else if (Math.abs(Math.abs(x - x0) - π) < ε) {\n        if (y + y0 > 2) area += 4 * (x - x0);\n      } else if (Math.abs(y0 - 2) < ε) area += 4 * (x - x1);else area += ((3 * π + x - x0) % (2 * π) - π) * (y0 + y);\n\n      x1 = x0, x0 = x, y0 = y;\n    }\n\n    return area;\n  }\n\n  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate);\n\n  function d3_geo_clipAntimeridianLine(listener) {\n    var λ0 = NaN,\n        φ0 = NaN,\n        sλ0 = NaN,\n        clean;\n    return {\n      lineStart: function () {\n        listener.lineStart();\n        clean = 1;\n      },\n      point: function (λ1, φ1) {\n        var sλ1 = λ1 > 0 ? π : -π,\n            dλ = Math.abs(λ1 - λ0);\n\n        if (Math.abs(dλ - π) < ε) {\n          listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? π / 2 : -π / 2);\n          listener.point(sλ0, φ0);\n          listener.lineEnd();\n          listener.lineStart();\n          listener.point(sλ1, φ0);\n          listener.point(λ1, φ0);\n          clean = 0;\n        } else if (sλ0 !== sλ1 && dλ >= π) {\n          if (Math.abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;\n          if (Math.abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;\n          φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);\n          listener.point(sλ0, φ0);\n          listener.lineEnd();\n          listener.lineStart();\n          listener.point(sλ1, φ0);\n          clean = 0;\n        }\n\n        listener.point(λ0 = λ1, φ0 = φ1);\n        sλ0 = sλ1;\n      },\n      lineEnd: function () {\n        listener.lineEnd();\n        λ0 = φ0 = NaN;\n      },\n      clean: function () {\n        return 2 - clean;\n      }\n    };\n  }\n\n  function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {\n    var cosφ0,\n        cosφ1,\n        sinλ0_λ1 = Math.sin(λ0 - λ1);\n    return Math.abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;\n  }\n\n  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {\n    var φ;\n\n    if (from == null) {\n      φ = direction * π / 2;\n      listener.point(-π, φ);\n      listener.point(0, φ);\n      listener.point(π, φ);\n      listener.point(π, 0);\n      listener.point(π, -φ);\n      listener.point(0, -φ);\n      listener.point(-π, -φ);\n      listener.point(-π, 0);\n      listener.point(-π, φ);\n    } else if (Math.abs(from[0] - to[0]) > ε) {\n      var s = (from[0] < to[0] ? 1 : -1) * π;\n      φ = direction * s / 2;\n      listener.point(-s, φ);\n      listener.point(0, φ);\n      listener.point(s, φ);\n    } else {\n      listener.point(to[0], to[1]);\n    }\n  }\n\n  function d3_geo_clipCircle(degrees) {\n    var radians = degrees * d3_radians,\n        cr = Math.cos(radians),\n        interpolate = d3_geo_circleInterpolate(radians, 6 * d3_radians);\n    return d3_geo_clip(visible, clipLine, interpolate);\n\n    function visible(λ, φ) {\n      return Math.cos(λ) * Math.cos(φ) > cr;\n    }\n\n    function clipLine(listener) {\n      var point0, v0, v00, clean;\n      return {\n        lineStart: function () {\n          v00 = v0 = false;\n          clean = 1;\n        },\n        point: function (λ, φ) {\n          var point1 = [λ, φ],\n              point2,\n              v = visible(λ, φ);\n          if (!point0 && (v00 = v0 = v)) listener.lineStart();\n\n          if (v !== v0) {\n            point2 = intersect(point0, point1);\n\n            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {\n              point1[0] += ε;\n              point1[1] += ε;\n              v = visible(point1[0], point1[1]);\n            }\n          }\n\n          if (v !== v0) {\n            clean = 0;\n\n            if (v0 = v) {\n              listener.lineStart();\n              point2 = intersect(point1, point0);\n              listener.point(point2[0], point2[1]);\n            } else {\n              point2 = intersect(point0, point1);\n              listener.point(point2[0], point2[1]);\n              listener.lineEnd();\n            }\n\n            point0 = point2;\n          }\n\n          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) listener.point(point1[0], point1[1]);\n          point0 = point1;\n        },\n        lineEnd: function () {\n          if (v0) listener.lineEnd();\n          point0 = null;\n        },\n        clean: function () {\n          return clean | (v00 && v0) << 1;\n        }\n      };\n    }\n\n    function intersect(a, b) {\n      var pa = d3_geo_cartesian(a, 0),\n          pb = d3_geo_cartesian(b, 0);\n      var n1 = [1, 0, 0],\n          n2 = d3_geo_cartesianCross(pa, pb),\n          n2n2 = d3_geo_cartesianDot(n2, n2),\n          n1n2 = n2[0],\n          determinant = n2n2 - n1n2 * n1n2;\n      if (!determinant) return a;\n      var c1 = cr * n2n2 / determinant,\n          c2 = -cr * n1n2 / determinant,\n          n1xn2 = d3_geo_cartesianCross(n1, n2),\n          A = d3_geo_cartesianScale(n1, c1),\n          B = d3_geo_cartesianScale(n2, c2);\n      d3_geo_cartesianAdd(A, B);\n      var u = n1xn2,\n          w = d3_geo_cartesianDot(A, u),\n          uu = d3_geo_cartesianDot(u, u),\n          t = Math.sqrt(w * w - uu * (d3_geo_cartesianDot(A, A) - 1)),\n          q = d3_geo_cartesianScale(u, (-w - t) / uu);\n      d3_geo_cartesianAdd(q, A);\n      return d3_geo_spherical(q);\n    }\n  }\n\n  function d3_geo_compose(a, b) {\n    function compose(x, y) {\n      return x = a(x, y), b(x[0], x[1]);\n    }\n\n    if (a.invert && b.invert) compose.invert = function (x, y) {\n      return x = b.invert(x, y), a.invert(x[0], x[1]);\n    };\n    return compose;\n  }\n\n  function d3_geo_equirectangular(λ, φ) {\n    return [λ, φ];\n  }\n\n  (d3.geo.equirectangular = function () {\n    return d3_geo_projection(d3_geo_equirectangular).scale(250 / π);\n  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;\n  var d3_geo_gnomonic = d3_geo_azimuthal(function (cosλcosφ) {\n    return 1 / cosλcosφ;\n  }, Math.atan);\n  (d3.geo.gnomonic = function () {\n    return d3_geo_projection(d3_geo_gnomonic);\n  }).raw = d3_geo_gnomonic;\n\n  d3.geo.graticule = function () {\n    var x1,\n        x0,\n        y1,\n        y0,\n        dx = 22.5,\n        dy = dx,\n        x,\n        y,\n        precision = 2.5;\n\n    function graticule() {\n      return {\n        type: \"MultiLineString\",\n        coordinates: lines()\n      };\n    }\n\n    function lines() {\n      return d3.range(Math.ceil(x0 / dx) * dx, x1, dx).map(x).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).map(y));\n    }\n\n    graticule.lines = function () {\n      return lines().map(function (coordinates) {\n        return {\n          type: \"LineString\",\n          coordinates: coordinates\n        };\n      });\n    };\n\n    graticule.outline = function () {\n      return {\n        type: \"Polygon\",\n        coordinates: [x(x0).concat(y(y1).slice(1), x(x1).reverse().slice(1), y(y0).reverse().slice(1))]\n      };\n    };\n\n    graticule.extent = function (_) {\n      if (!arguments.length) return [[x0, y0], [x1, y1]];\n      x0 = +_[0][0], x1 = +_[1][0];\n      y0 = +_[0][1], y1 = +_[1][1];\n      if (x0 > x1) _ = x0, x0 = x1, x1 = _;\n      if (y0 > y1) _ = y0, y0 = y1, y1 = _;\n      return graticule.precision(precision);\n    };\n\n    graticule.step = function (_) {\n      if (!arguments.length) return [dx, dy];\n      dx = +_[0], dy = +_[1];\n      return graticule;\n    };\n\n    graticule.precision = function (_) {\n      if (!arguments.length) return precision;\n      precision = +_;\n      x = d3_geo_graticuleX(y0, y1, precision);\n      y = d3_geo_graticuleY(x0, x1, precision);\n      return graticule;\n    };\n\n    return graticule.extent([[-180 + ε, -90 + ε], [180 - ε, 90 - ε]]);\n  };\n\n  function d3_geo_graticuleX(y0, y1, dy) {\n    var y = d3.range(y0, y1 - ε, dy).concat(y1);\n    return function (x) {\n      return y.map(function (y) {\n        return [x, y];\n      });\n    };\n  }\n\n  function d3_geo_graticuleY(x0, x1, dx) {\n    var x = d3.range(x0, x1 - ε, dx).concat(x1);\n    return function (y) {\n      return x.map(function (x) {\n        return [x, y];\n      });\n    };\n  }\n\n  d3.geo.interpolate = function (source, target) {\n    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);\n  };\n\n  function d3_geo_interpolate(x0, y0, x1, y1) {\n    var cy0 = Math.cos(y0),\n        sy0 = Math.sin(y0),\n        cy1 = Math.cos(y1),\n        sy1 = Math.sin(y1),\n        kx0 = cy0 * Math.cos(x0),\n        ky0 = cy0 * Math.sin(x0),\n        kx1 = cy1 * Math.cos(x1),\n        ky1 = cy1 * Math.sin(x1),\n        d = Math.acos(Math.max(-1, Math.min(1, sy0 * sy1 + cy0 * cy1 * Math.cos(x1 - x0)))),\n        k = 1 / Math.sin(d);\n\n    function interpolate(t) {\n      var B = Math.sin(t *= d) * k,\n          A = Math.sin(d - t) * k,\n          x = A * kx0 + B * kx1,\n          y = A * ky0 + B * ky1,\n          z = A * sy0 + B * sy1;\n      return [Math.atan2(y, x) / d3_radians, Math.atan2(z, Math.sqrt(x * x + y * y)) / d3_radians];\n    }\n\n    interpolate.distance = d;\n    return interpolate;\n  }\n\n  d3.geo.greatArc = function () {\n    var source = d3_source,\n        s,\n        target = d3_target,\n        t,\n        precision = 6 * d3_radians,\n        interpolate;\n\n    function greatArc() {\n      var p0 = s || source.apply(this, arguments),\n          p1 = t || target.apply(this, arguments),\n          i = interpolate || d3.geo.interpolate(p0, p1),\n          t = 0,\n          dt = precision / i.distance,\n          coordinates = [p0];\n\n      while ((t += dt) < 1) coordinates.push(i(t));\n\n      coordinates.push(p1);\n      return {\n        type: \"LineString\",\n        coordinates: coordinates\n      };\n    }\n\n    greatArc.distance = function () {\n      return (interpolate || d3.geo.interpolate(s || source.apply(this, arguments), t || target.apply(this, arguments))).distance;\n    };\n\n    greatArc.source = function (_) {\n      if (!arguments.length) return source;\n      source = _, s = typeof _ === \"function\" ? null : _;\n      interpolate = s && t ? d3.geo.interpolate(s, t) : null;\n      return greatArc;\n    };\n\n    greatArc.target = function (_) {\n      if (!arguments.length) return target;\n      target = _, t = typeof _ === \"function\" ? null : _;\n      interpolate = s && t ? d3.geo.interpolate(s, t) : null;\n      return greatArc;\n    };\n\n    greatArc.precision = function (_) {\n      if (!arguments.length) return precision / d3_radians;\n      precision = _ * d3_radians;\n      return greatArc;\n    };\n\n    return greatArc;\n  };\n\n  function d3_geo_mercator(λ, φ) {\n    return [λ / (2 * π), Math.max(-.5, Math.min(+.5, Math.log(Math.tan(π / 4 + φ / 2)) / (2 * π)))];\n  }\n\n  d3_geo_mercator.invert = function (x, y) {\n    return [2 * π * x, 2 * Math.atan(Math.exp(2 * π * y)) - π / 2];\n  };\n\n  (d3.geo.mercator = function () {\n    return d3_geo_projection(d3_geo_mercator).scale(500);\n  }).raw = d3_geo_mercator;\n  var d3_geo_orthographic = d3_geo_azimuthal(function () {\n    return 1;\n  }, Math.asin);\n  (d3.geo.orthographic = function () {\n    return d3_geo_projection(d3_geo_orthographic);\n  }).raw = d3_geo_orthographic;\n\n  d3.geo.path = function () {\n    var pointRadius = 4.5,\n        projection,\n        context,\n        projectStream,\n        contextStream;\n\n    function path(object) {\n      if (object) d3.geo.stream(object, projectStream(contextStream.pointRadius(typeof pointRadius === \"function\" ? +pointRadius.apply(this, arguments) : pointRadius)));\n      return contextStream.result();\n    }\n\n    path.area = function (object) {\n      d3_geo_pathAreaSum = 0;\n      d3.geo.stream(object, projectStream(d3_geo_pathArea));\n      return d3_geo_pathAreaSum;\n    };\n\n    path.centroid = function (object) {\n      d3_geo_centroidDimension = d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;\n      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));\n      return d3_geo_centroidZ ? [d3_geo_centroidX / d3_geo_centroidZ, d3_geo_centroidY / d3_geo_centroidZ] : undefined;\n    };\n\n    path.bounds = function (object) {\n      return d3_geo_bounds(projection)(object);\n    };\n\n    path.projection = function (_) {\n      if (!arguments.length) return projection;\n      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;\n      return path;\n    };\n\n    path.context = function (_) {\n      if (!arguments.length) return context;\n      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);\n      return path;\n    };\n\n    path.pointRadius = function (_) {\n      if (!arguments.length) return pointRadius;\n      pointRadius = typeof _ === \"function\" ? _ : +_;\n      return path;\n    };\n\n    return path.projection(d3.geo.albersUsa()).context(null);\n  };\n\n  function d3_geo_pathCircle(radius) {\n    return \"m0,\" + radius + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + -2 * radius + \"a\" + radius + \",\" + radius + \" 0 1,1 0,\" + +2 * radius + \"z\";\n  }\n\n  function d3_geo_pathProjectStream(project) {\n    var resample = d3_geo_resample(function (λ, φ) {\n      return project([λ * d3_degrees, φ * d3_degrees]);\n    });\n    return function (stream) {\n      stream = resample(stream);\n      return {\n        point: function (λ, φ) {\n          stream.point(λ * d3_radians, φ * d3_radians);\n        },\n        sphere: function () {\n          stream.sphere();\n        },\n        lineStart: function () {\n          stream.lineStart();\n        },\n        lineEnd: function () {\n          stream.lineEnd();\n        },\n        polygonStart: function () {\n          stream.polygonStart();\n        },\n        polygonEnd: function () {\n          stream.polygonEnd();\n        }\n      };\n    };\n  }\n\n  function d3_geo_pathBuffer() {\n    var pointCircle = d3_geo_pathCircle(4.5),\n        buffer = [];\n    var stream = {\n      point: point,\n      lineStart: function () {\n        stream.point = pointLineStart;\n      },\n      lineEnd: lineEnd,\n      polygonStart: function () {\n        stream.lineEnd = lineEndPolygon;\n      },\n      polygonEnd: function () {\n        stream.lineEnd = lineEnd;\n        stream.point = point;\n      },\n      pointRadius: function (_) {\n        pointCircle = d3_geo_pathCircle(_);\n        return stream;\n      },\n      result: function () {\n        if (buffer.length) {\n          var result = buffer.join(\"\");\n          buffer = [];\n          return result;\n        }\n      }\n    };\n\n    function point(x, y) {\n      buffer.push(\"M\", x, \",\", y, pointCircle);\n    }\n\n    function pointLineStart(x, y) {\n      buffer.push(\"M\", x, \",\", y);\n      stream.point = pointLine;\n    }\n\n    function pointLine(x, y) {\n      buffer.push(\"L\", x, \",\", y);\n    }\n\n    function lineEnd() {\n      stream.point = point;\n    }\n\n    function lineEndPolygon() {\n      buffer.push(\"Z\");\n    }\n\n    return stream;\n  }\n\n  function d3_geo_pathContext(context) {\n    var pointRadius = 4.5;\n    var stream = {\n      point: point,\n      lineStart: function () {\n        stream.point = pointLineStart;\n      },\n      lineEnd: lineEnd,\n      polygonStart: function () {\n        stream.lineEnd = lineEndPolygon;\n      },\n      polygonEnd: function () {\n        stream.lineEnd = lineEnd;\n        stream.point = point;\n      },\n      pointRadius: function (_) {\n        pointRadius = _;\n        return stream;\n      },\n      result: d3_noop\n    };\n\n    function point(x, y) {\n      context.moveTo(x, y);\n      context.arc(x, y, pointRadius, 0, 2 * π);\n    }\n\n    function pointLineStart(x, y) {\n      context.moveTo(x, y);\n      stream.point = pointLine;\n    }\n\n    function pointLine(x, y) {\n      context.lineTo(x, y);\n    }\n\n    function lineEnd() {\n      stream.point = point;\n    }\n\n    function lineEndPolygon() {\n      context.closePath();\n    }\n\n    return stream;\n  }\n\n  var d3_geo_pathAreaSum,\n      d3_geo_pathAreaPolygon,\n      d3_geo_pathArea = {\n    point: d3_noop,\n    lineStart: d3_noop,\n    lineEnd: d3_noop,\n    polygonStart: function () {\n      d3_geo_pathAreaPolygon = 0;\n      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;\n    },\n    polygonEnd: function () {\n      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;\n      d3_geo_pathAreaSum += Math.abs(d3_geo_pathAreaPolygon / 2);\n    }\n  };\n\n  function d3_geo_pathAreaRingStart() {\n    var x00, y00, x0, y0;\n\n    d3_geo_pathArea.point = function (x, y) {\n      d3_geo_pathArea.point = nextPoint;\n      x00 = x0 = x, y00 = y0 = y;\n    };\n\n    function nextPoint(x, y) {\n      d3_geo_pathAreaPolygon += y0 * x - x0 * y;\n      x0 = x, y0 = y;\n    }\n\n    d3_geo_pathArea.lineEnd = function () {\n      nextPoint(x00, y00);\n    };\n  }\n\n  var d3_geo_pathCentroid = {\n    point: d3_geo_pathCentroidPoint,\n    lineStart: d3_geo_pathCentroidLineStart,\n    lineEnd: d3_geo_pathCentroidLineEnd,\n    polygonStart: function () {\n      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;\n    },\n    polygonEnd: function () {\n      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;\n      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;\n      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;\n    }\n  };\n\n  function d3_geo_pathCentroidPoint(x, y) {\n    if (d3_geo_centroidDimension) return;\n    d3_geo_centroidX += x;\n    d3_geo_centroidY += y;\n    ++d3_geo_centroidZ;\n  }\n\n  function d3_geo_pathCentroidLineStart() {\n    var x0, y0;\n\n    if (d3_geo_centroidDimension !== 1) {\n      if (d3_geo_centroidDimension < 1) {\n        d3_geo_centroidDimension = 1;\n        d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;\n      } else return;\n    }\n\n    d3_geo_pathCentroid.point = function (x, y) {\n      d3_geo_pathCentroid.point = nextPoint;\n      x0 = x, y0 = y;\n    };\n\n    function nextPoint(x, y) {\n      var dx = x - x0,\n          dy = y - y0,\n          z = Math.sqrt(dx * dx + dy * dy);\n      d3_geo_centroidX += z * (x0 + x) / 2;\n      d3_geo_centroidY += z * (y0 + y) / 2;\n      d3_geo_centroidZ += z;\n      x0 = x, y0 = y;\n    }\n  }\n\n  function d3_geo_pathCentroidLineEnd() {\n    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;\n  }\n\n  function d3_geo_pathCentroidRingStart() {\n    var x00, y00, x0, y0;\n\n    if (d3_geo_centroidDimension < 2) {\n      d3_geo_centroidDimension = 2;\n      d3_geo_centroidX = d3_geo_centroidY = d3_geo_centroidZ = 0;\n    }\n\n    d3_geo_pathCentroid.point = function (x, y) {\n      d3_geo_pathCentroid.point = nextPoint;\n      x00 = x0 = x, y00 = y0 = y;\n    };\n\n    function nextPoint(x, y) {\n      var z = y0 * x - x0 * y;\n      d3_geo_centroidX += z * (x0 + x);\n      d3_geo_centroidY += z * (y0 + y);\n      d3_geo_centroidZ += z * 3;\n      x0 = x, y0 = y;\n    }\n\n    d3_geo_pathCentroid.lineEnd = function () {\n      nextPoint(x00, y00);\n    };\n  }\n\n  d3.geo.area = function (object) {\n    d3_geo_areaSum = 0;\n    d3.geo.stream(object, d3_geo_area);\n    return d3_geo_areaSum;\n  };\n\n  var d3_geo_areaSum, d3_geo_areaRing;\n  var d3_geo_area = {\n    sphere: function () {\n      d3_geo_areaSum += 4 * π;\n    },\n    point: d3_noop,\n    lineStart: d3_noop,\n    lineEnd: d3_noop,\n    polygonStart: function () {\n      d3_geo_areaRing = 0;\n      d3_geo_area.lineStart = d3_geo_areaRingStart;\n    },\n    polygonEnd: function () {\n      d3_geo_areaSum += d3_geo_areaRing < 0 ? 4 * π + d3_geo_areaRing : d3_geo_areaRing;\n      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;\n    }\n  };\n\n  function d3_geo_areaRingStart() {\n    var λ00, φ00, λ1, λ0, φ0, cosφ0, sinφ0;\n\n    d3_geo_area.point = function (λ, φ) {\n      d3_geo_area.point = nextPoint;\n      λ1 = λ0 = (λ00 = λ) * d3_radians, φ0 = (φ00 = φ) * d3_radians, cosφ0 = Math.cos(φ0), sinφ0 = Math.sin(φ0);\n    };\n\n    function nextPoint(λ, φ) {\n      λ *= d3_radians, φ *= d3_radians;\n      if (Math.abs(Math.abs(φ0) - π / 2) < ε && Math.abs(Math.abs(φ) - π / 2) < ε) return;\n      var cosφ = Math.cos(φ),\n          sinφ = Math.sin(φ);\n      if (Math.abs(φ0 - π / 2) < ε) d3_geo_areaRing += (λ - λ1) * 2;else {\n        var dλ = λ - λ0,\n            cosdλ = Math.cos(dλ),\n            d = Math.atan2(Math.sqrt((d = cosφ * Math.sin(dλ)) * d + (d = cosφ0 * sinφ - sinφ0 * cosφ * cosdλ) * d), sinφ0 * sinφ + cosφ0 * cosφ * cosdλ),\n            s = (d + π + φ0 + φ) / 4;\n        d3_geo_areaRing += (dλ < 0 && dλ > -π || dλ > π ? -4 : 4) * Math.atan(Math.sqrt(Math.abs(Math.tan(s) * Math.tan(s - d / 2) * Math.tan(s - π / 4 - φ0 / 2) * Math.tan(s - π / 4 - φ / 2))));\n      }\n      λ1 = λ0, λ0 = λ, φ0 = φ, cosφ0 = cosφ, sinφ0 = sinφ;\n    }\n\n    d3_geo_area.lineEnd = function () {\n      nextPoint(λ00, φ00);\n    };\n  }\n\n  d3.geo.projection = d3_geo_projection;\n  d3.geo.projectionMutator = d3_geo_projectionMutator;\n\n  function d3_geo_projection(project) {\n    return d3_geo_projectionMutator(function () {\n      return project;\n    })();\n  }\n\n  function d3_geo_projectionMutator(projectAt) {\n    var project,\n        rotate,\n        projectRotate,\n        projectResample = d3_geo_resample(function (x, y) {\n      x = project(x, y);\n      return [x[0] * k + δx, δy - x[1] * k];\n    }),\n        k = 150,\n        x = 480,\n        y = 250,\n        λ = 0,\n        φ = 0,\n        δλ = 0,\n        δφ = 0,\n        δγ = 0,\n        δx,\n        δy,\n        clip = d3_geo_clipAntimeridian,\n        clipAngle = null;\n\n    function projection(point) {\n      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);\n      return [point[0] * k + δx, δy - point[1] * k];\n    }\n\n    function invert(point) {\n      point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);\n      return [point[0] * d3_degrees, point[1] * d3_degrees];\n    }\n\n    projection.stream = function (stream) {\n      return d3_geo_projectionRadiansRotate(rotate, clip(projectResample(stream)));\n    };\n\n    projection.clipAngle = function (_) {\n      if (!arguments.length) return clipAngle;\n      clip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle(clipAngle = +_);\n      return projection;\n    };\n\n    projection.scale = function (_) {\n      if (!arguments.length) return k;\n      k = +_;\n      return reset();\n    };\n\n    projection.translate = function (_) {\n      if (!arguments.length) return [x, y];\n      x = +_[0];\n      y = +_[1];\n      return reset();\n    };\n\n    projection.center = function (_) {\n      if (!arguments.length) return [λ * d3_degrees, φ * d3_degrees];\n      λ = _[0] % 360 * d3_radians;\n      φ = _[1] % 360 * d3_radians;\n      return reset();\n    };\n\n    projection.rotate = function (_) {\n      if (!arguments.length) return [δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees];\n      δλ = _[0] % 360 * d3_radians;\n      δφ = _[1] % 360 * d3_radians;\n      δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;\n      return reset();\n    };\n\n    d3.rebind(projection, projectResample, \"precision\");\n\n    function reset() {\n      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);\n      var center = project(λ, φ);\n      δx = x - center[0] * k;\n      δy = y + center[1] * k;\n      return projection;\n    }\n\n    return function () {\n      project = projectAt.apply(this, arguments);\n      projection.invert = project.invert && invert;\n      return reset();\n    };\n  }\n\n  function d3_geo_projectionRadiansRotate(rotate, stream) {\n    return {\n      point: function (x, y) {\n        y = rotate(x * d3_radians, y * d3_radians), x = y[0];\n        stream.point(x > π ? x - 2 * π : x < -π ? x + 2 * π : x, y[1]);\n      },\n      sphere: function () {\n        stream.sphere();\n      },\n      lineStart: function () {\n        stream.lineStart();\n      },\n      lineEnd: function () {\n        stream.lineEnd();\n      },\n      polygonStart: function () {\n        stream.polygonStart();\n      },\n      polygonEnd: function () {\n        stream.polygonEnd();\n      }\n    };\n  }\n\n  function d3_geo_rotation(δλ, δφ, δγ) {\n    return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_equirectangular;\n  }\n\n  function d3_geo_forwardRotationλ(δλ) {\n    return function (λ, φ) {\n      return λ += δλ, [λ > π ? λ - 2 * π : λ < -π ? λ + 2 * π : λ, φ];\n    };\n  }\n\n  function d3_geo_rotationλ(δλ) {\n    var rotation = d3_geo_forwardRotationλ(δλ);\n    rotation.invert = d3_geo_forwardRotationλ(-δλ);\n    return rotation;\n  }\n\n  function d3_geo_rotationφγ(δφ, δγ) {\n    var cosδφ = Math.cos(δφ),\n        sinδφ = Math.sin(δφ),\n        cosδγ = Math.cos(δγ),\n        sinδγ = Math.sin(δγ);\n\n    function rotation(λ, φ) {\n      var cosφ = Math.cos(φ),\n          x = Math.cos(λ) * cosφ,\n          y = Math.sin(λ) * cosφ,\n          z = Math.sin(φ),\n          k = z * cosδφ + x * sinδφ;\n      return [Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), Math.asin(Math.max(-1, Math.min(1, k * cosδγ + y * sinδγ)))];\n    }\n\n    rotation.invert = function (λ, φ) {\n      var cosφ = Math.cos(φ),\n          x = Math.cos(λ) * cosφ,\n          y = Math.sin(λ) * cosφ,\n          z = Math.sin(φ),\n          k = z * cosδγ - y * sinδγ;\n      return [Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), Math.asin(Math.max(-1, Math.min(1, k * cosδφ - x * sinδφ)))];\n    };\n\n    return rotation;\n  }\n\n  var d3_geo_stereographic = d3_geo_azimuthal(function (cosλcosφ) {\n    return 1 / (1 + cosλcosφ);\n  }, function (ρ) {\n    return 2 * Math.atan(ρ);\n  });\n  (d3.geo.stereographic = function () {\n    return d3_geo_projection(d3_geo_stereographic);\n  }).raw = d3_geo_stereographic;\n\n  function d3_geo_azimuthal(scale, angle) {\n    function azimuthal(λ, φ) {\n      var cosλ = Math.cos(λ),\n          cosφ = Math.cos(φ),\n          k = scale(cosλ * cosφ);\n      return [k * cosφ * Math.sin(λ), k * Math.sin(φ)];\n    }\n\n    azimuthal.invert = function (x, y) {\n      var ρ = Math.sqrt(x * x + y * y),\n          c = angle(ρ),\n          sinc = Math.sin(c),\n          cosc = Math.cos(c);\n      return [Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ)];\n    };\n\n    return azimuthal;\n  }\n\n  d3.geom = {};\n\n  d3.geom.hull = function (vertices) {\n    if (vertices.length < 3) return [];\n    var len = vertices.length,\n        plen = len - 1,\n        points = [],\n        stack = [],\n        i,\n        j,\n        h = 0,\n        x1,\n        y1,\n        x2,\n        y2,\n        u,\n        v,\n        a,\n        sp;\n\n    for (i = 1; i < len; ++i) {\n      if (vertices[i][1] < vertices[h][1]) {\n        h = i;\n      } else if (vertices[i][1] == vertices[h][1]) {\n        h = vertices[i][0] < vertices[h][0] ? i : h;\n      }\n    }\n\n    for (i = 0; i < len; ++i) {\n      if (i === h) continue;\n      y1 = vertices[i][1] - vertices[h][1];\n      x1 = vertices[i][0] - vertices[h][0];\n      points.push({\n        angle: Math.atan2(y1, x1),\n        index: i\n      });\n    }\n\n    points.sort(function (a, b) {\n      return a.angle - b.angle;\n    });\n    a = points[0].angle;\n    v = points[0].index;\n    u = 0;\n\n    for (i = 1; i < plen; ++i) {\n      j = points[i].index;\n\n      if (a == points[i].angle) {\n        x1 = vertices[v][0] - vertices[h][0];\n        y1 = vertices[v][1] - vertices[h][1];\n        x2 = vertices[j][0] - vertices[h][0];\n        y2 = vertices[j][1] - vertices[h][1];\n\n        if (x1 * x1 + y1 * y1 >= x2 * x2 + y2 * y2) {\n          points[i].index = -1;\n        } else {\n          points[u].index = -1;\n          a = points[i].angle;\n          u = i;\n          v = j;\n        }\n      } else {\n        a = points[i].angle;\n        u = i;\n        v = j;\n      }\n    }\n\n    stack.push(h);\n\n    for (i = 0, j = 0; i < 2; ++j) {\n      if (points[j].index !== -1) {\n        stack.push(points[j].index);\n        i++;\n      }\n    }\n\n    sp = stack.length;\n\n    for (; j < plen; ++j) {\n      if (points[j].index === -1) continue;\n\n      while (!d3_geom_hullCCW(stack[sp - 2], stack[sp - 1], points[j].index, vertices)) {\n        --sp;\n      }\n\n      stack[sp++] = points[j].index;\n    }\n\n    var poly = [];\n\n    for (i = 0; i < sp; ++i) {\n      poly.push(vertices[stack[i]]);\n    }\n\n    return poly;\n  };\n\n  function d3_geom_hullCCW(i1, i2, i3, v) {\n    var t, a, b, c, d, e, f;\n    t = v[i1];\n    a = t[0];\n    b = t[1];\n    t = v[i2];\n    c = t[0];\n    d = t[1];\n    t = v[i3];\n    e = t[0];\n    f = t[1];\n    return (f - b) * (c - a) - (d - b) * (e - a) > 0;\n  }\n\n  d3.geom.polygon = function (coordinates) {\n    coordinates.area = function () {\n      var i = 0,\n          n = coordinates.length,\n          area = coordinates[n - 1][1] * coordinates[0][0] - coordinates[n - 1][0] * coordinates[0][1];\n\n      while (++i < n) {\n        area += coordinates[i - 1][1] * coordinates[i][0] - coordinates[i - 1][0] * coordinates[i][1];\n      }\n\n      return area * .5;\n    };\n\n    coordinates.centroid = function (k) {\n      var i = -1,\n          n = coordinates.length,\n          x = 0,\n          y = 0,\n          a,\n          b = coordinates[n - 1],\n          c;\n      if (!arguments.length) k = -1 / (6 * coordinates.area());\n\n      while (++i < n) {\n        a = b;\n        b = coordinates[i];\n        c = a[0] * b[1] - b[0] * a[1];\n        x += (a[0] + b[0]) * c;\n        y += (a[1] + b[1]) * c;\n      }\n\n      return [x * k, y * k];\n    };\n\n    coordinates.clip = function (subject) {\n      var input,\n          i = -1,\n          n = coordinates.length,\n          j,\n          m,\n          a = coordinates[n - 1],\n          b,\n          c,\n          d;\n\n      while (++i < n) {\n        input = subject.slice();\n        subject.length = 0;\n        b = coordinates[i];\n        c = input[(m = input.length) - 1];\n        j = -1;\n\n        while (++j < m) {\n          d = input[j];\n\n          if (d3_geom_polygonInside(d, a, b)) {\n            if (!d3_geom_polygonInside(c, a, b)) {\n              subject.push(d3_geom_polygonIntersect(c, d, a, b));\n            }\n\n            subject.push(d);\n          } else if (d3_geom_polygonInside(c, a, b)) {\n            subject.push(d3_geom_polygonIntersect(c, d, a, b));\n          }\n\n          c = d;\n        }\n\n        a = b;\n      }\n\n      return subject;\n    };\n\n    return coordinates;\n  };\n\n  function d3_geom_polygonInside(p, a, b) {\n    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);\n  }\n\n  function d3_geom_polygonIntersect(c, d, a, b) {\n    var x1 = c[0],\n        x3 = a[0],\n        x21 = d[0] - x1,\n        x43 = b[0] - x3,\n        y1 = c[1],\n        y3 = a[1],\n        y21 = d[1] - y1,\n        y43 = b[1] - y3,\n        ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);\n    return [x1 + ua * x21, y1 + ua * y21];\n  }\n\n  d3.geom.voronoi = function (vertices) {\n    var polygons = vertices.map(function () {\n      return [];\n    }),\n        Z = 1e6;\n    d3_voronoi_tessellate(vertices, function (e) {\n      var s1, s2, x1, x2, y1, y2;\n\n      if (e.a === 1 && e.b >= 0) {\n        s1 = e.ep.r;\n        s2 = e.ep.l;\n      } else {\n        s1 = e.ep.l;\n        s2 = e.ep.r;\n      }\n\n      if (e.a === 1) {\n        y1 = s1 ? s1.y : -Z;\n        x1 = e.c - e.b * y1;\n        y2 = s2 ? s2.y : Z;\n        x2 = e.c - e.b * y2;\n      } else {\n        x1 = s1 ? s1.x : -Z;\n        y1 = e.c - e.a * x1;\n        x2 = s2 ? s2.x : Z;\n        y2 = e.c - e.a * x2;\n      }\n\n      var v1 = [x1, y1],\n          v2 = [x2, y2];\n      polygons[e.region.l.index].push(v1, v2);\n      polygons[e.region.r.index].push(v1, v2);\n    });\n    polygons = polygons.map(function (polygon, i) {\n      var cx = vertices[i][0],\n          cy = vertices[i][1],\n          angle = polygon.map(function (v) {\n        return Math.atan2(v[0] - cx, v[1] - cy);\n      });\n      return d3.range(polygon.length).sort(function (a, b) {\n        return angle[a] - angle[b];\n      }).filter(function (d, i, order) {\n        return !i || angle[d] - angle[order[i - 1]] > ε;\n      }).map(function (d) {\n        return polygon[d];\n      });\n    });\n    polygons.forEach(function (polygon, i) {\n      var n = polygon.length;\n      if (!n) return polygon.push([-Z, -Z], [-Z, Z], [Z, Z], [Z, -Z]);\n      if (n > 2) return;\n      var p0 = vertices[i],\n          p1 = polygon[0],\n          p2 = polygon[1],\n          x0 = p0[0],\n          y0 = p0[1],\n          x1 = p1[0],\n          y1 = p1[1],\n          x2 = p2[0],\n          y2 = p2[1],\n          dx = Math.abs(x2 - x1),\n          dy = y2 - y1;\n\n      if (Math.abs(dy) < ε) {\n        var y = y0 < y1 ? -Z : Z;\n        polygon.push([-Z, y], [Z, y]);\n      } else if (dx < ε) {\n        var x = x0 < x1 ? -Z : Z;\n        polygon.push([x, -Z], [x, Z]);\n      } else {\n        var y = (x2 - x1) * (y1 - y0) < (x1 - x0) * (y2 - y1) ? Z : -Z,\n            z = Math.abs(dy) - dx;\n\n        if (Math.abs(z) < ε) {\n          polygon.push([dy < 0 ? y : -y, y]);\n        } else {\n          if (z > 0) y *= -1;\n          polygon.push([-Z, y], [Z, y]);\n        }\n      }\n    });\n    return polygons;\n  };\n\n  var d3_voronoi_opposite = {\n    l: \"r\",\n    r: \"l\"\n  };\n\n  function d3_voronoi_tessellate(vertices, callback) {\n    var Sites = {\n      list: vertices.map(function (v, i) {\n        return {\n          index: i,\n          x: v[0],\n          y: v[1]\n        };\n      }).sort(function (a, b) {\n        return a.y < b.y ? -1 : a.y > b.y ? 1 : a.x < b.x ? -1 : a.x > b.x ? 1 : 0;\n      }),\n      bottomSite: null\n    };\n    var EdgeList = {\n      list: [],\n      leftEnd: null,\n      rightEnd: null,\n      init: function () {\n        EdgeList.leftEnd = EdgeList.createHalfEdge(null, \"l\");\n        EdgeList.rightEnd = EdgeList.createHalfEdge(null, \"l\");\n        EdgeList.leftEnd.r = EdgeList.rightEnd;\n        EdgeList.rightEnd.l = EdgeList.leftEnd;\n        EdgeList.list.unshift(EdgeList.leftEnd, EdgeList.rightEnd);\n      },\n      createHalfEdge: function (edge, side) {\n        return {\n          edge: edge,\n          side: side,\n          vertex: null,\n          l: null,\n          r: null\n        };\n      },\n      insert: function (lb, he) {\n        he.l = lb;\n        he.r = lb.r;\n        lb.r.l = he;\n        lb.r = he;\n      },\n      leftBound: function (p) {\n        var he = EdgeList.leftEnd;\n\n        do {\n          he = he.r;\n        } while (he != EdgeList.rightEnd && Geom.rightOf(he, p));\n\n        he = he.l;\n        return he;\n      },\n      del: function (he) {\n        he.l.r = he.r;\n        he.r.l = he.l;\n        he.edge = null;\n      },\n      right: function (he) {\n        return he.r;\n      },\n      left: function (he) {\n        return he.l;\n      },\n      leftRegion: function (he) {\n        return he.edge == null ? Sites.bottomSite : he.edge.region[he.side];\n      },\n      rightRegion: function (he) {\n        return he.edge == null ? Sites.bottomSite : he.edge.region[d3_voronoi_opposite[he.side]];\n      }\n    };\n    var Geom = {\n      bisect: function (s1, s2) {\n        var newEdge = {\n          region: {\n            l: s1,\n            r: s2\n          },\n          ep: {\n            l: null,\n            r: null\n          }\n        };\n        var dx = s2.x - s1.x,\n            dy = s2.y - s1.y,\n            adx = dx > 0 ? dx : -dx,\n            ady = dy > 0 ? dy : -dy;\n        newEdge.c = s1.x * dx + s1.y * dy + (dx * dx + dy * dy) * .5;\n\n        if (adx > ady) {\n          newEdge.a = 1;\n          newEdge.b = dy / dx;\n          newEdge.c /= dx;\n        } else {\n          newEdge.b = 1;\n          newEdge.a = dx / dy;\n          newEdge.c /= dy;\n        }\n\n        return newEdge;\n      },\n      intersect: function (el1, el2) {\n        var e1 = el1.edge,\n            e2 = el2.edge;\n\n        if (!e1 || !e2 || e1.region.r == e2.region.r) {\n          return null;\n        }\n\n        var d = e1.a * e2.b - e1.b * e2.a;\n\n        if (Math.abs(d) < 1e-10) {\n          return null;\n        }\n\n        var xint = (e1.c * e2.b - e2.c * e1.b) / d,\n            yint = (e2.c * e1.a - e1.c * e2.a) / d,\n            e1r = e1.region.r,\n            e2r = e2.region.r,\n            el,\n            e;\n\n        if (e1r.y < e2r.y || e1r.y == e2r.y && e1r.x < e2r.x) {\n          el = el1;\n          e = e1;\n        } else {\n          el = el2;\n          e = e2;\n        }\n\n        var rightOfSite = xint >= e.region.r.x;\n\n        if (rightOfSite && el.side === \"l\" || !rightOfSite && el.side === \"r\") {\n          return null;\n        }\n\n        return {\n          x: xint,\n          y: yint\n        };\n      },\n      rightOf: function (he, p) {\n        var e = he.edge,\n            topsite = e.region.r,\n            rightOfSite = p.x > topsite.x;\n\n        if (rightOfSite && he.side === \"l\") {\n          return 1;\n        }\n\n        if (!rightOfSite && he.side === \"r\") {\n          return 0;\n        }\n\n        if (e.a === 1) {\n          var dyp = p.y - topsite.y,\n              dxp = p.x - topsite.x,\n              fast = 0,\n              above = 0;\n\n          if (!rightOfSite && e.b < 0 || rightOfSite && e.b >= 0) {\n            above = fast = dyp >= e.b * dxp;\n          } else {\n            above = p.x + p.y * e.b > e.c;\n\n            if (e.b < 0) {\n              above = !above;\n            }\n\n            if (!above) {\n              fast = 1;\n            }\n          }\n\n          if (!fast) {\n            var dxs = topsite.x - e.region.l.x;\n            above = e.b * (dxp * dxp - dyp * dyp) < dxs * dyp * (1 + 2 * dxp / dxs + e.b * e.b);\n\n            if (e.b < 0) {\n              above = !above;\n            }\n          }\n        } else {\n          var yl = e.c - e.a * p.x,\n              t1 = p.y - yl,\n              t2 = p.x - topsite.x,\n              t3 = yl - topsite.y;\n          above = t1 * t1 > t2 * t2 + t3 * t3;\n        }\n\n        return he.side === \"l\" ? above : !above;\n      },\n      endPoint: function (edge, side, site) {\n        edge.ep[side] = site;\n        if (!edge.ep[d3_voronoi_opposite[side]]) return;\n        callback(edge);\n      },\n      distance: function (s, t) {\n        var dx = s.x - t.x,\n            dy = s.y - t.y;\n        return Math.sqrt(dx * dx + dy * dy);\n      }\n    };\n    var EventQueue = {\n      list: [],\n      insert: function (he, site, offset) {\n        he.vertex = site;\n        he.ystar = site.y + offset;\n\n        for (var i = 0, list = EventQueue.list, l = list.length; i < l; i++) {\n          var next = list[i];\n\n          if (he.ystar > next.ystar || he.ystar == next.ystar && site.x > next.vertex.x) {\n            continue;\n          } else {\n            break;\n          }\n        }\n\n        list.splice(i, 0, he);\n      },\n      del: function (he) {\n        for (var i = 0, ls = EventQueue.list, l = ls.length; i < l && ls[i] != he; ++i) {}\n\n        ls.splice(i, 1);\n      },\n      empty: function () {\n        return EventQueue.list.length === 0;\n      },\n      nextEvent: function (he) {\n        for (var i = 0, ls = EventQueue.list, l = ls.length; i < l; ++i) {\n          if (ls[i] == he) return ls[i + 1];\n        }\n\n        return null;\n      },\n      min: function () {\n        var elem = EventQueue.list[0];\n        return {\n          x: elem.vertex.x,\n          y: elem.ystar\n        };\n      },\n      extractMin: function () {\n        return EventQueue.list.shift();\n      }\n    };\n    EdgeList.init();\n    Sites.bottomSite = Sites.list.shift();\n    var newSite = Sites.list.shift(),\n        newIntStar;\n    var lbnd, rbnd, llbnd, rrbnd, bisector;\n    var bot, top, temp, p, v;\n    var e, pm;\n\n    while (true) {\n      if (!EventQueue.empty()) {\n        newIntStar = EventQueue.min();\n      }\n\n      if (newSite && (EventQueue.empty() || newSite.y < newIntStar.y || newSite.y == newIntStar.y && newSite.x < newIntStar.x)) {\n        lbnd = EdgeList.leftBound(newSite);\n        rbnd = EdgeList.right(lbnd);\n        bot = EdgeList.rightRegion(lbnd);\n        e = Geom.bisect(bot, newSite);\n        bisector = EdgeList.createHalfEdge(e, \"l\");\n        EdgeList.insert(lbnd, bisector);\n        p = Geom.intersect(lbnd, bisector);\n\n        if (p) {\n          EventQueue.del(lbnd);\n          EventQueue.insert(lbnd, p, Geom.distance(p, newSite));\n        }\n\n        lbnd = bisector;\n        bisector = EdgeList.createHalfEdge(e, \"r\");\n        EdgeList.insert(lbnd, bisector);\n        p = Geom.intersect(bisector, rbnd);\n\n        if (p) {\n          EventQueue.insert(bisector, p, Geom.distance(p, newSite));\n        }\n\n        newSite = Sites.list.shift();\n      } else if (!EventQueue.empty()) {\n        lbnd = EventQueue.extractMin();\n        llbnd = EdgeList.left(lbnd);\n        rbnd = EdgeList.right(lbnd);\n        rrbnd = EdgeList.right(rbnd);\n        bot = EdgeList.leftRegion(lbnd);\n        top = EdgeList.rightRegion(rbnd);\n        v = lbnd.vertex;\n        Geom.endPoint(lbnd.edge, lbnd.side, v);\n        Geom.endPoint(rbnd.edge, rbnd.side, v);\n        EdgeList.del(lbnd);\n        EventQueue.del(rbnd);\n        EdgeList.del(rbnd);\n        pm = \"l\";\n\n        if (bot.y > top.y) {\n          temp = bot;\n          bot = top;\n          top = temp;\n          pm = \"r\";\n        }\n\n        e = Geom.bisect(bot, top);\n        bisector = EdgeList.createHalfEdge(e, pm);\n        EdgeList.insert(llbnd, bisector);\n        Geom.endPoint(e, d3_voronoi_opposite[pm], v);\n        p = Geom.intersect(llbnd, bisector);\n\n        if (p) {\n          EventQueue.del(llbnd);\n          EventQueue.insert(llbnd, p, Geom.distance(p, bot));\n        }\n\n        p = Geom.intersect(bisector, rrbnd);\n\n        if (p) {\n          EventQueue.insert(bisector, p, Geom.distance(p, bot));\n        }\n      } else {\n        break;\n      }\n    }\n\n    for (lbnd = EdgeList.right(EdgeList.leftEnd); lbnd != EdgeList.rightEnd; lbnd = EdgeList.right(lbnd)) {\n      callback(lbnd.edge);\n    }\n  }\n\n  d3.geom.delaunay = function (vertices) {\n    var edges = vertices.map(function () {\n      return [];\n    }),\n        triangles = [];\n    d3_voronoi_tessellate(vertices, function (e) {\n      edges[e.region.l.index].push(vertices[e.region.r.index]);\n    });\n    edges.forEach(function (edge, i) {\n      var v = vertices[i],\n          cx = v[0],\n          cy = v[1];\n      edge.forEach(function (v) {\n        v.angle = Math.atan2(v[0] - cx, v[1] - cy);\n      });\n      edge.sort(function (a, b) {\n        return a.angle - b.angle;\n      });\n\n      for (var j = 0, m = edge.length - 1; j < m; j++) {\n        triangles.push([v, edge[j], edge[j + 1]]);\n      }\n    });\n    return triangles;\n  };\n\n  d3.geom.quadtree = function (points, x1, y1, x2, y2) {\n    var p,\n        i = -1,\n        n = points.length;\n\n    if (arguments.length < 5) {\n      if (arguments.length === 3) {\n        y2 = y1;\n        x2 = x1;\n        y1 = x1 = 0;\n      } else {\n        x1 = y1 = Infinity;\n        x2 = y2 = -Infinity;\n\n        while (++i < n) {\n          p = points[i];\n          if (p.x < x1) x1 = p.x;\n          if (p.y < y1) y1 = p.y;\n          if (p.x > x2) x2 = p.x;\n          if (p.y > y2) y2 = p.y;\n        }\n      }\n    }\n\n    var dx = x2 - x1,\n        dy = y2 - y1;\n    if (dx > dy) y2 = y1 + dx;else x2 = x1 + dy;\n\n    function insert(n, p, x1, y1, x2, y2) {\n      if (isNaN(p.x) || isNaN(p.y)) return;\n\n      if (n.leaf) {\n        var v = n.point;\n\n        if (v) {\n          if (Math.abs(v.x - p.x) + Math.abs(v.y - p.y) < .01) {\n            insertChild(n, p, x1, y1, x2, y2);\n          } else {\n            n.point = null;\n            insertChild(n, v, x1, y1, x2, y2);\n            insertChild(n, p, x1, y1, x2, y2);\n          }\n        } else {\n          n.point = p;\n        }\n      } else {\n        insertChild(n, p, x1, y1, x2, y2);\n      }\n    }\n\n    function insertChild(n, p, x1, y1, x2, y2) {\n      var sx = (x1 + x2) * .5,\n          sy = (y1 + y2) * .5,\n          right = p.x >= sx,\n          bottom = p.y >= sy,\n          i = (bottom << 1) + right;\n      n.leaf = false;\n      n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());\n      if (right) x1 = sx;else x2 = sx;\n      if (bottom) y1 = sy;else y2 = sy;\n      insert(n, p, x1, y1, x2, y2);\n    }\n\n    var root = d3_geom_quadtreeNode();\n\n    root.add = function (p) {\n      insert(root, p, x1, y1, x2, y2);\n    };\n\n    root.visit = function (f) {\n      d3_geom_quadtreeVisit(f, root, x1, y1, x2, y2);\n    };\n\n    points.forEach(root.add);\n    return root;\n  };\n\n  function d3_geom_quadtreeNode() {\n    return {\n      leaf: true,\n      nodes: [],\n      point: null\n    };\n  }\n\n  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {\n    if (!f(node, x1, y1, x2, y2)) {\n      var sx = (x1 + x2) * .5,\n          sy = (y1 + y2) * .5,\n          children = node.nodes;\n      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);\n      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);\n      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);\n      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);\n    }\n  }\n\n  d3.time = {};\n  var d3_time = Date,\n      d3_time_daySymbols = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\n\n  function d3_time_utc() {\n    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);\n  }\n\n  d3_time_utc.prototype = {\n    getDate: function () {\n      return this._.getUTCDate();\n    },\n    getDay: function () {\n      return this._.getUTCDay();\n    },\n    getFullYear: function () {\n      return this._.getUTCFullYear();\n    },\n    getHours: function () {\n      return this._.getUTCHours();\n    },\n    getMilliseconds: function () {\n      return this._.getUTCMilliseconds();\n    },\n    getMinutes: function () {\n      return this._.getUTCMinutes();\n    },\n    getMonth: function () {\n      return this._.getUTCMonth();\n    },\n    getSeconds: function () {\n      return this._.getUTCSeconds();\n    },\n    getTime: function () {\n      return this._.getTime();\n    },\n    getTimezoneOffset: function () {\n      return 0;\n    },\n    valueOf: function () {\n      return this._.valueOf();\n    },\n    setDate: function () {\n      d3_time_prototype.setUTCDate.apply(this._, arguments);\n    },\n    setDay: function () {\n      d3_time_prototype.setUTCDay.apply(this._, arguments);\n    },\n    setFullYear: function () {\n      d3_time_prototype.setUTCFullYear.apply(this._, arguments);\n    },\n    setHours: function () {\n      d3_time_prototype.setUTCHours.apply(this._, arguments);\n    },\n    setMilliseconds: function () {\n      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);\n    },\n    setMinutes: function () {\n      d3_time_prototype.setUTCMinutes.apply(this._, arguments);\n    },\n    setMonth: function () {\n      d3_time_prototype.setUTCMonth.apply(this._, arguments);\n    },\n    setSeconds: function () {\n      d3_time_prototype.setUTCSeconds.apply(this._, arguments);\n    },\n    setTime: function () {\n      d3_time_prototype.setTime.apply(this._, arguments);\n    }\n  };\n  var d3_time_prototype = Date.prototype;\n  var d3_time_formatDateTime = \"%a %b %e %X %Y\",\n      d3_time_formatDate = \"%m/%d/%Y\",\n      d3_time_formatTime = \"%H:%M:%S\";\n  var d3_time_days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n      d3_time_dayAbbreviations = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n      d3_time_months = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n      d3_time_monthAbbreviations = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n\n  d3.time.format = function (template) {\n    var n = template.length;\n\n    function format(date) {\n      var string = [],\n          i = -1,\n          j = 0,\n          c,\n          p,\n          f;\n\n      while (++i < n) {\n        if (template.charCodeAt(i) === 37) {\n          string.push(template.substring(j, i));\n          if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);\n          if (f = d3_time_formats[c]) c = f(date, p == null ? c === \"e\" ? \" \" : \"0\" : p);\n          string.push(c);\n          j = i + 1;\n        }\n      }\n\n      string.push(template.substring(j, i));\n      return string.join(\"\");\n    }\n\n    format.parse = function (string) {\n      var d = {\n        y: 1900,\n        m: 0,\n        d: 1,\n        H: 0,\n        M: 0,\n        S: 0,\n        L: 0\n      },\n          i = d3_time_parse(d, template, string, 0);\n      if (i != string.length) return null;\n      if (\"p\" in d) d.H = d.H % 12 + d.p * 12;\n      var date = new d3_time();\n      date.setFullYear(d.y, d.m, d.d);\n      date.setHours(d.H, d.M, d.S, d.L);\n      return date;\n    };\n\n    format.toString = function () {\n      return template;\n    };\n\n    return format;\n  };\n\n  function d3_time_parse(date, template, string, j) {\n    var c,\n        p,\n        i = 0,\n        n = template.length,\n        m = string.length;\n\n    while (i < n) {\n      if (j >= m) return -1;\n      c = template.charCodeAt(i++);\n\n      if (c === 37) {\n        p = d3_time_parsers[template.charAt(i++)];\n        if (!p || (j = p(date, string, j)) < 0) return -1;\n      } else if (c != string.charCodeAt(j++)) {\n        return -1;\n      }\n    }\n\n    return j;\n  }\n\n  function d3_time_formatRe(names) {\n    return new RegExp(\"^(?:\" + names.map(d3.requote).join(\"|\") + \")\", \"i\");\n  }\n\n  function d3_time_formatLookup(names) {\n    var map = new d3_Map(),\n        i = -1,\n        n = names.length;\n\n    while (++i < n) map.set(names[i].toLowerCase(), i);\n\n    return map;\n  }\n\n  function d3_time_formatPad(value, fill, width) {\n    value += \"\";\n    var length = value.length;\n    return length < width ? new Array(width - length + 1).join(fill) + value : value;\n  }\n\n  var d3_time_dayRe = d3_time_formatRe(d3_time_days),\n      d3_time_dayAbbrevRe = d3_time_formatRe(d3_time_dayAbbreviations),\n      d3_time_monthRe = d3_time_formatRe(d3_time_months),\n      d3_time_monthLookup = d3_time_formatLookup(d3_time_months),\n      d3_time_monthAbbrevRe = d3_time_formatRe(d3_time_monthAbbreviations),\n      d3_time_monthAbbrevLookup = d3_time_formatLookup(d3_time_monthAbbreviations);\n  var d3_time_formatPads = {\n    \"-\": \"\",\n    _: \" \",\n    \"0\": \"0\"\n  };\n  var d3_time_formats = {\n    a: function (d) {\n      return d3_time_dayAbbreviations[d.getDay()];\n    },\n    A: function (d) {\n      return d3_time_days[d.getDay()];\n    },\n    b: function (d) {\n      return d3_time_monthAbbreviations[d.getMonth()];\n    },\n    B: function (d) {\n      return d3_time_months[d.getMonth()];\n    },\n    c: d3.time.format(d3_time_formatDateTime),\n    d: function (d, p) {\n      return d3_time_formatPad(d.getDate(), p, 2);\n    },\n    e: function (d, p) {\n      return d3_time_formatPad(d.getDate(), p, 2);\n    },\n    H: function (d, p) {\n      return d3_time_formatPad(d.getHours(), p, 2);\n    },\n    I: function (d, p) {\n      return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);\n    },\n    j: function (d, p) {\n      return d3_time_formatPad(1 + d3.time.dayOfYear(d), p, 3);\n    },\n    L: function (d, p) {\n      return d3_time_formatPad(d.getMilliseconds(), p, 3);\n    },\n    m: function (d, p) {\n      return d3_time_formatPad(d.getMonth() + 1, p, 2);\n    },\n    M: function (d, p) {\n      return d3_time_formatPad(d.getMinutes(), p, 2);\n    },\n    p: function (d) {\n      return d.getHours() >= 12 ? \"PM\" : \"AM\";\n    },\n    S: function (d, p) {\n      return d3_time_formatPad(d.getSeconds(), p, 2);\n    },\n    U: function (d, p) {\n      return d3_time_formatPad(d3.time.sundayOfYear(d), p, 2);\n    },\n    w: function (d) {\n      return d.getDay();\n    },\n    W: function (d, p) {\n      return d3_time_formatPad(d3.time.mondayOfYear(d), p, 2);\n    },\n    x: d3.time.format(d3_time_formatDate),\n    X: d3.time.format(d3_time_formatTime),\n    y: function (d, p) {\n      return d3_time_formatPad(d.getFullYear() % 100, p, 2);\n    },\n    Y: function (d, p) {\n      return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);\n    },\n    Z: d3_time_zone,\n    \"%\": function () {\n      return \"%\";\n    }\n  };\n  var d3_time_parsers = {\n    a: d3_time_parseWeekdayAbbrev,\n    A: d3_time_parseWeekday,\n    b: d3_time_parseMonthAbbrev,\n    B: d3_time_parseMonth,\n    c: d3_time_parseLocaleFull,\n    d: d3_time_parseDay,\n    e: d3_time_parseDay,\n    H: d3_time_parseHour24,\n    I: d3_time_parseHour24,\n    L: d3_time_parseMilliseconds,\n    m: d3_time_parseMonthNumber,\n    M: d3_time_parseMinutes,\n    p: d3_time_parseAmPm,\n    S: d3_time_parseSeconds,\n    x: d3_time_parseLocaleDate,\n    X: d3_time_parseLocaleTime,\n    y: d3_time_parseYear,\n    Y: d3_time_parseFullYear\n  };\n\n  function d3_time_parseWeekdayAbbrev(date, string, i) {\n    d3_time_dayAbbrevRe.lastIndex = 0;\n    var n = d3_time_dayAbbrevRe.exec(string.substring(i));\n    return n ? i += n[0].length : -1;\n  }\n\n  function d3_time_parseWeekday(date, string, i) {\n    d3_time_dayRe.lastIndex = 0;\n    var n = d3_time_dayRe.exec(string.substring(i));\n    return n ? i += n[0].length : -1;\n  }\n\n  function d3_time_parseMonthAbbrev(date, string, i) {\n    d3_time_monthAbbrevRe.lastIndex = 0;\n    var n = d3_time_monthAbbrevRe.exec(string.substring(i));\n    return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i += n[0].length) : -1;\n  }\n\n  function d3_time_parseMonth(date, string, i) {\n    d3_time_monthRe.lastIndex = 0;\n    var n = d3_time_monthRe.exec(string.substring(i));\n    return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i += n[0].length) : -1;\n  }\n\n  function d3_time_parseLocaleFull(date, string, i) {\n    return d3_time_parse(date, d3_time_formats.c.toString(), string, i);\n  }\n\n  function d3_time_parseLocaleDate(date, string, i) {\n    return d3_time_parse(date, d3_time_formats.x.toString(), string, i);\n  }\n\n  function d3_time_parseLocaleTime(date, string, i) {\n    return d3_time_parse(date, d3_time_formats.X.toString(), string, i);\n  }\n\n  function d3_time_parseFullYear(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.substring(i, i + 4));\n    return n ? (date.y = +n[0], i += n[0].length) : -1;\n  }\n\n  function d3_time_parseYear(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.substring(i, i + 2));\n    return n ? (date.y = d3_time_expandYear(+n[0]), i += n[0].length) : -1;\n  }\n\n  function d3_time_expandYear(d) {\n    return d + (d > 68 ? 1900 : 2e3);\n  }\n\n  function d3_time_parseMonthNumber(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.substring(i, i + 2));\n    return n ? (date.m = n[0] - 1, i += n[0].length) : -1;\n  }\n\n  function d3_time_parseDay(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.substring(i, i + 2));\n    return n ? (date.d = +n[0], i += n[0].length) : -1;\n  }\n\n  function d3_time_parseHour24(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.substring(i, i + 2));\n    return n ? (date.H = +n[0], i += n[0].length) : -1;\n  }\n\n  function d3_time_parseMinutes(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.substring(i, i + 2));\n    return n ? (date.M = +n[0], i += n[0].length) : -1;\n  }\n\n  function d3_time_parseSeconds(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.substring(i, i + 2));\n    return n ? (date.S = +n[0], i += n[0].length) : -1;\n  }\n\n  function d3_time_parseMilliseconds(date, string, i) {\n    d3_time_numberRe.lastIndex = 0;\n    var n = d3_time_numberRe.exec(string.substring(i, i + 3));\n    return n ? (date.L = +n[0], i += n[0].length) : -1;\n  }\n\n  var d3_time_numberRe = /^\\s*\\d+/;\n\n  function d3_time_parseAmPm(date, string, i) {\n    var n = d3_time_amPmLookup.get(string.substring(i, i += 2).toLowerCase());\n    return n == null ? -1 : (date.p = n, i);\n  }\n\n  var d3_time_amPmLookup = d3.map({\n    am: 0,\n    pm: 1\n  });\n\n  function d3_time_zone(d) {\n    var z = d.getTimezoneOffset(),\n        zs = z > 0 ? \"-\" : \"+\",\n        zh = ~~(Math.abs(z) / 60),\n        zm = Math.abs(z) % 60;\n    return zs + d3_time_formatPad(zh, \"0\", 2) + d3_time_formatPad(zm, \"0\", 2);\n  }\n\n  d3.time.format.utc = function (template) {\n    var local = d3.time.format(template);\n\n    function format(date) {\n      try {\n        d3_time = d3_time_utc;\n        var utc = new d3_time();\n        utc._ = date;\n        return local(utc);\n      } finally {\n        d3_time = Date;\n      }\n    }\n\n    format.parse = function (string) {\n      try {\n        d3_time = d3_time_utc;\n        var date = local.parse(string);\n        return date && date._;\n      } finally {\n        d3_time = Date;\n      }\n    };\n\n    format.toString = local.toString;\n    return format;\n  };\n\n  var d3_time_formatIso = d3.time.format.utc(\"%Y-%m-%dT%H:%M:%S.%LZ\");\n  d3.time.format.iso = Date.prototype.toISOString ? d3_time_formatIsoNative : d3_time_formatIso;\n\n  function d3_time_formatIsoNative(date) {\n    return date.toISOString();\n  }\n\n  d3_time_formatIsoNative.parse = function (string) {\n    var date = new Date(string);\n    return isNaN(date) ? null : date;\n  };\n\n  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;\n\n  function d3_time_interval(local, step, number) {\n    function round(date) {\n      var d0 = local(date),\n          d1 = offset(d0, 1);\n      return date - d0 < d1 - date ? d0 : d1;\n    }\n\n    function ceil(date) {\n      step(date = local(new d3_time(date - 1)), 1);\n      return date;\n    }\n\n    function offset(date, k) {\n      step(date = new d3_time(+date), k);\n      return date;\n    }\n\n    function range(t0, t1, dt) {\n      var time = ceil(t0),\n          times = [];\n\n      if (dt > 1) {\n        while (time < t1) {\n          if (!(number(time) % dt)) times.push(new Date(+time));\n          step(time, 1);\n        }\n      } else {\n        while (time < t1) times.push(new Date(+time)), step(time, 1);\n      }\n\n      return times;\n    }\n\n    function range_utc(t0, t1, dt) {\n      try {\n        d3_time = d3_time_utc;\n        var utc = new d3_time_utc();\n        utc._ = t0;\n        return range(utc, t1, dt);\n      } finally {\n        d3_time = Date;\n      }\n    }\n\n    local.floor = local;\n    local.round = round;\n    local.ceil = ceil;\n    local.offset = offset;\n    local.range = range;\n    var utc = local.utc = d3_time_interval_utc(local);\n    utc.floor = utc;\n    utc.round = d3_time_interval_utc(round);\n    utc.ceil = d3_time_interval_utc(ceil);\n    utc.offset = d3_time_interval_utc(offset);\n    utc.range = range_utc;\n    return local;\n  }\n\n  function d3_time_interval_utc(method) {\n    return function (date, k) {\n      try {\n        d3_time = d3_time_utc;\n        var utc = new d3_time_utc();\n        utc._ = date;\n        return method(utc, k)._;\n      } finally {\n        d3_time = Date;\n      }\n    };\n  }\n\n  d3.time.second = d3_time_interval(function (date) {\n    return new d3_time(Math.floor(date / 1e3) * 1e3);\n  }, function (date, offset) {\n    date.setTime(date.getTime() + Math.floor(offset) * 1e3);\n  }, function (date) {\n    return date.getSeconds();\n  });\n  d3.time.seconds = d3.time.second.range;\n  d3.time.seconds.utc = d3.time.second.utc.range;\n  d3.time.minute = d3_time_interval(function (date) {\n    return new d3_time(Math.floor(date / 6e4) * 6e4);\n  }, function (date, offset) {\n    date.setTime(date.getTime() + Math.floor(offset) * 6e4);\n  }, function (date) {\n    return date.getMinutes();\n  });\n  d3.time.minutes = d3.time.minute.range;\n  d3.time.minutes.utc = d3.time.minute.utc.range;\n  d3.time.hour = d3_time_interval(function (date) {\n    var timezone = date.getTimezoneOffset() / 60;\n    return new d3_time((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);\n  }, function (date, offset) {\n    date.setTime(date.getTime() + Math.floor(offset) * 36e5);\n  }, function (date) {\n    return date.getHours();\n  });\n  d3.time.hours = d3.time.hour.range;\n  d3.time.hours.utc = d3.time.hour.utc.range;\n  d3.time.day = d3_time_interval(function (date) {\n    var day = new d3_time(1970, 0);\n    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n    return day;\n  }, function (date, offset) {\n    date.setDate(date.getDate() + offset);\n  }, function (date) {\n    return date.getDate() - 1;\n  });\n  d3.time.days = d3.time.day.range;\n  d3.time.days.utc = d3.time.day.utc.range;\n\n  d3.time.dayOfYear = function (date) {\n    var year = d3.time.year(date);\n    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);\n  };\n\n  d3_time_daySymbols.forEach(function (day, i) {\n    day = day.toLowerCase();\n    i = 7 - i;\n    var interval = d3.time[day] = d3_time_interval(function (date) {\n      (date = d3.time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);\n      return date;\n    }, function (date, offset) {\n      date.setDate(date.getDate() + Math.floor(offset) * 7);\n    }, function (date) {\n      var day = d3.time.year(date).getDay();\n      return Math.floor((d3.time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);\n    });\n    d3.time[day + \"s\"] = interval.range;\n    d3.time[day + \"s\"].utc = interval.utc.range;\n\n    d3.time[day + \"OfYear\"] = function (date) {\n      var day = d3.time.year(date).getDay();\n      return Math.floor((d3.time.dayOfYear(date) + (day + i) % 7) / 7);\n    };\n  });\n  d3.time.week = d3.time.sunday;\n  d3.time.weeks = d3.time.sunday.range;\n  d3.time.weeks.utc = d3.time.sunday.utc.range;\n  d3.time.weekOfYear = d3.time.sundayOfYear;\n  d3.time.month = d3_time_interval(function (date) {\n    date = d3.time.day(date);\n    date.setDate(1);\n    return date;\n  }, function (date, offset) {\n    date.setMonth(date.getMonth() + offset);\n  }, function (date) {\n    return date.getMonth();\n  });\n  d3.time.months = d3.time.month.range;\n  d3.time.months.utc = d3.time.month.utc.range;\n  d3.time.year = d3_time_interval(function (date) {\n    date = d3.time.day(date);\n    date.setMonth(0, 1);\n    return date;\n  }, function (date, offset) {\n    date.setFullYear(date.getFullYear() + offset);\n  }, function (date) {\n    return date.getFullYear();\n  });\n  d3.time.years = d3.time.year.range;\n  d3.time.years.utc = d3.time.year.utc.range;\n\n  function d3_time_scale(linear, methods, format) {\n    function scale(x) {\n      return linear(x);\n    }\n\n    scale.invert = function (x) {\n      return d3_time_scaleDate(linear.invert(x));\n    };\n\n    scale.domain = function (x) {\n      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);\n      linear.domain(x);\n      return scale;\n    };\n\n    scale.nice = function (m) {\n      return scale.domain(d3_scale_nice(scale.domain(), function () {\n        return m;\n      }));\n    };\n\n    scale.ticks = function (m, k) {\n      var extent = d3_time_scaleExtent(scale.domain());\n\n      if (typeof m !== \"function\") {\n        var span = extent[1] - extent[0],\n            target = span / m,\n            i = d3.bisect(d3_time_scaleSteps, target);\n        if (i == d3_time_scaleSteps.length) return methods.year(extent, m);\n        if (!i) return linear.ticks(m).map(d3_time_scaleDate);\n        if (Math.log(target / d3_time_scaleSteps[i - 1]) < Math.log(d3_time_scaleSteps[i] / target)) --i;\n        m = methods[i];\n        k = m[1];\n        m = m[0].range;\n      }\n\n      return m(extent[0], new Date(+extent[1] + 1), k);\n    };\n\n    scale.tickFormat = function () {\n      return format;\n    };\n\n    scale.copy = function () {\n      return d3_time_scale(linear.copy(), methods, format);\n    };\n\n    return d3.rebind(scale, linear, \"range\", \"rangeRound\", \"interpolate\", \"clamp\");\n  }\n\n  function d3_time_scaleExtent(domain) {\n    var start = domain[0],\n        stop = domain[domain.length - 1];\n    return start < stop ? [start, stop] : [stop, start];\n  }\n\n  function d3_time_scaleDate(t) {\n    return new Date(t);\n  }\n\n  function d3_time_scaleFormat(formats) {\n    return function (date) {\n      var i = formats.length - 1,\n          f = formats[i];\n\n      while (!f[1](date)) f = formats[--i];\n\n      return f[0](date);\n    };\n  }\n\n  function d3_time_scaleSetYear(y) {\n    var d = new Date(y, 0, 1);\n    d.setFullYear(y);\n    return d;\n  }\n\n  function d3_time_scaleGetYear(d) {\n    var y = d.getFullYear(),\n        d0 = d3_time_scaleSetYear(y),\n        d1 = d3_time_scaleSetYear(y + 1);\n    return y + (d - d0) / (d1 - d0);\n  }\n\n  var d3_time_scaleSteps = [1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6];\n  var d3_time_scaleLocalMethods = [[d3.time.second, 1], [d3.time.second, 5], [d3.time.second, 15], [d3.time.second, 30], [d3.time.minute, 1], [d3.time.minute, 5], [d3.time.minute, 15], [d3.time.minute, 30], [d3.time.hour, 1], [d3.time.hour, 3], [d3.time.hour, 6], [d3.time.hour, 12], [d3.time.day, 1], [d3.time.day, 2], [d3.time.week, 1], [d3.time.month, 1], [d3.time.month, 3], [d3.time.year, 1]];\n  var d3_time_scaleLocalFormats = [[d3.time.format(\"%Y\"), d3_true], [d3.time.format(\"%B\"), function (d) {\n    return d.getMonth();\n  }], [d3.time.format(\"%b %d\"), function (d) {\n    return d.getDate() != 1;\n  }], [d3.time.format(\"%a %d\"), function (d) {\n    return d.getDay() && d.getDate() != 1;\n  }], [d3.time.format(\"%I %p\"), function (d) {\n    return d.getHours();\n  }], [d3.time.format(\"%I:%M\"), function (d) {\n    return d.getMinutes();\n  }], [d3.time.format(\":%S\"), function (d) {\n    return d.getSeconds();\n  }], [d3.time.format(\".%L\"), function (d) {\n    return d.getMilliseconds();\n  }]];\n  var d3_time_scaleLinear = d3.scale.linear(),\n      d3_time_scaleLocalFormat = d3_time_scaleFormat(d3_time_scaleLocalFormats);\n\n  d3_time_scaleLocalMethods.year = function (extent, m) {\n    return d3_time_scaleLinear.domain(extent.map(d3_time_scaleGetYear)).ticks(m).map(d3_time_scaleSetYear);\n  };\n\n  d3.time.scale = function () {\n    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);\n  };\n\n  var d3_time_scaleUTCMethods = d3_time_scaleLocalMethods.map(function (m) {\n    return [m[0].utc, m[1]];\n  });\n  var d3_time_scaleUTCFormats = [[d3.time.format.utc(\"%Y\"), d3_true], [d3.time.format.utc(\"%B\"), function (d) {\n    return d.getUTCMonth();\n  }], [d3.time.format.utc(\"%b %d\"), function (d) {\n    return d.getUTCDate() != 1;\n  }], [d3.time.format.utc(\"%a %d\"), function (d) {\n    return d.getUTCDay() && d.getUTCDate() != 1;\n  }], [d3.time.format.utc(\"%I %p\"), function (d) {\n    return d.getUTCHours();\n  }], [d3.time.format.utc(\"%I:%M\"), function (d) {\n    return d.getUTCMinutes();\n  }], [d3.time.format.utc(\":%S\"), function (d) {\n    return d.getUTCSeconds();\n  }], [d3.time.format.utc(\".%L\"), function (d) {\n    return d.getUTCMilliseconds();\n  }]];\n  var d3_time_scaleUTCFormat = d3_time_scaleFormat(d3_time_scaleUTCFormats);\n\n  function d3_time_scaleUTCSetYear(y) {\n    var d = new Date(Date.UTC(y, 0, 1));\n    d.setUTCFullYear(y);\n    return d;\n  }\n\n  function d3_time_scaleUTCGetYear(d) {\n    var y = d.getUTCFullYear(),\n        d0 = d3_time_scaleUTCSetYear(y),\n        d1 = d3_time_scaleUTCSetYear(y + 1);\n    return y + (d - d0) / (d1 - d0);\n  }\n\n  d3_time_scaleUTCMethods.year = function (extent, m) {\n    return d3_time_scaleLinear.domain(extent.map(d3_time_scaleUTCGetYear)).ticks(m).map(d3_time_scaleUTCSetYear);\n  };\n\n  d3.time.scale.utc = function () {\n    return d3_time_scale(d3.scale.linear(), d3_time_scaleUTCMethods, d3_time_scaleUTCFormat);\n  };\n})();","map":null,"metadata":{},"sourceType":"script"}